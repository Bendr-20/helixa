<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Helixa Aura v3 â€” Humanoid Portraits</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0a0a;color:#e0e0e0;font-family:'SF Mono','Fira Code',monospace;padding:20px}
h1{color:#00ff88;font-size:1.5rem;text-align:center;margin-bottom:0.5rem}
.sub{color:#666;text-align:center;font-size:0.8rem;margin-bottom:2rem}
.section{margin-bottom:2.5rem}
.section h2{color:#00ff88;font-size:0.95rem;margin-bottom:1rem;padding-bottom:0.5rem;border-bottom:1px solid #1a1a1a}
.row{display:flex;flex-wrap:wrap;gap:12px;justify-content:center}
.card{background:#0f0f0f;border:1px solid #1a1a1a;border-radius:12px;padding:10px;text-align:center;width:170px}
.card svg{border-radius:8px;margin-bottom:6px}
.card .lbl{font-size:10px;color:#00ff88;font-weight:bold}
.card .sub2{font-size:8px;color:#666;line-height:1.3;margin-top:2px}
</style>
</head>
<body>
<h1>ðŸ§¬ Helixa Aura v3 â€” Humanoid Portraits</h1>
<p class="sub">Pixel-art AI agent portraits. Non-binary. QR corner markers. Personality-driven features.</p>

<div class="section">
<h2>The 5 Test Agents</h2>
<div class="row" id="agents"></div>
</div>

<div class="section">
<h2>Hair by Temperament</h2>
<div class="row" id="hair"></div>
</div>

<div class="section">
<h2>Eyes + Accessories by Specialization</h2>
<div class="row" id="eyes"></div>
</div>

<div class="section">
<h2>Mouth by Communication Style</h2>
<div class="row" id="mouths"></div>
</div>

<div class="section">
<h2>Risk Tolerance â†’ Brow Expression + Color Saturation</h2>
<div class="row" id="risk"></div>
</div>

<div class="section">
<h2>Autonomy â†’ Shoulder Width</h2>
<div class="row" id="autonomy"></div>
</div>

<div class="section">
<h2>Alignment â†’ Color Temperature</h2>
<div class="row" id="alignment"></div>
</div>

<div class="section">
<h2>Soulbound + Glow</h2>
<div class="row" id="soul"></div>
</div>

<div class="section">
<h2>Random Agent Gallery (20 unique)</h2>
<div class="row" id="gallery"></div>
</div>

<script>
/**
 * Helixa Aura Generator v3 â€” Humanoid Pixel Portraits
 * Generates unique pixel-art humanoid "auras" with QR corner markers.
 * Non-binary, androgynous figures. Every trait shapes the output.
 * Inspired by QR-art portrait style.
 */
function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}
function seededRandom(seed) {
  let s = seed;
  return function() {
    s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
    return (s >>> 0) / 0xFFFFFFFF;
  };
}
const HAIR_STYLES = {
  analytical: { 
    pattern: [
      '  xxxxxxxx  ',
      ' xxxxxxxxxx ',
      'xxxxxxxxxxxx',
      'xxxxxxxxxxxx',
    ],
    sideburns: false,
  },
  creative: { 
    pattern: [
      '   xxxxxxx  ',
      ' xxxxxxxxxxx',
      'xxxxxxxxxxxxx',
      'xxxxxxxxxxxxx',
      'x xxxxxxxxxxx',
    ],
    sideburns: true,
  },
  aggressive: { 
    pattern: [
      '     xx     ',
      '    xxxx    ',
      '   xxxxxx   ',
      '  xxxxxxxxx ',
      ' xxxxxxxxxxx',
    ],
    sideburns: false,
  },
  cautious: { 
    pattern: [
      ' xxxxxxxxxxx',
      'xxxxxxxxxxxxx',
      'xxxxxxxxxxxxx',
      'xxxxxxxxxxxxx',
      'xx xxxxxxx xx',
    ],
    sideburns: true,
  },
  chaotic: { 
    pattern: [
      '  x xxxxxxx ',
      ' xxxxxxxxxxxx',
      'xxxxxxxxxxxxx',
      'xxxxxxxxxxxx ',
      'x xxxxxxxxx  ',
    ],
    sideburns: true,
  },
};
const EYE_STYLES = {
  researcher: { shape: 'round', glow: false, size: 1 },    
  trader:     { shape: 'sharp', glow: true, size: 1 },      
  guardian:   { shape: 'slit', glow: true, size: 1 },        
  oracle:     { shape: 'large', glow: true, size: 2 },       
  creator:    { shape: 'round', glow: false, size: 1 },      
  operator:   { shape: 'visor', glow: true, size: 1 },       
};
const ACCESSORIES = {
  trader:     'none',
  guardian:   'mask',        
  oracle:     'third_eye',   
  researcher: 'glasses',     
  creator:    'earring',     
  operator:   'visor',       
};
const MOUTH_STYLES = {
  formal:  [[0,0,1,1,1,1,0,0]],                        
  casual:  [[0,0,1,0,0,1,0,0],[0,0,0,1,1,0,0,0]],     
  snarky:  [[0,0,0,0,1,1,0,0],[0,0,1,1,0,0,0,0]],     
  verbose: [[0,1,1,1,1,1,1,0],[0,0,1,1,1,1,0,0]],      
  minimal: [[0,0,0,1,1,0,0,0]],                         
};
function shoulderWidth(autonomy) {
  return 4 + Math.floor(autonomy * 0.6); 
}
function generateAura(agentData, size) {
  size = size || 400;
  const G = 31; 
  const cellSize = size / G;
  const address = agentData.agentAddress || agentData.address || '0x0000';
  const framework = agentData.framework || 'custom';
  const name = agentData.name || 'Agent';
  const traitCount = agentData.traitCount || 0;
  const mutationCount = agentData.mutationCount || 0;
  const soulbound = agentData.soulbound || false;
  const points = agentData.points || 0;
  const generation = agentData.generation || 0;
  const temperament = agentData.temperament || 'analytical';
  const commStyle = agentData.communicationStyle || 'formal';
  const riskTolerance = agentData.riskTolerance || 5;
  const autonomyLevel = agentData.autonomyLevel || 5;
  const alignment = agentData.alignment || 'true-neutral';
  const specialization = agentData.specialization || 'researcher';
  const seed = simpleHash(address + name + framework + temperament + alignment + specialization + riskTolerance + autonomyLevel);
  const rng = seededRandom(seed);
  const addrHash = simpleHash(address);
  let hue = addrHash % 360;
  const alignWarmth = {
    'lawful-good':0.3,'neutral-good':0.2,'chaotic-good':0.4,
    'lawful-neutral':0,'true-neutral':0,'chaotic-neutral':-0.2,
    'lawful-evil':-0.4,'neutral-evil':-0.3,'chaotic-evil':-0.5
  }[alignment] || 0;
  hue = (hue + alignWarmth * 30 + 360) % 360;
  const sat = Math.max(25, Math.min(100, 70 + (riskTolerance - 5) * 4));
  const primaryColor = `hsl(${hue}, ${sat}%, 55%)`;
  const accentColor = `hsl(${(hue + 180) % 360}, ${Math.min(100, sat + 10)}%, 60%)`;
  const skinColor = `hsl(${hue}, ${Math.max(10, sat - 40)}%, 25%)`; 
  const hairColor = `hsl(${(hue + 60) % 360}, ${sat - 20}%, 40%)`;
  const bgColor = '#0a0a0a';
  const glowColor = `hsl(${(hue + 30) % 360}, 90%, 65%)`;
  const grid = Array.from({length: G}, () => Array(G).fill(0));
  const cx = Math.floor(G / 2); 
  const headTop = 5;
  const headW = 5; 
  const headH = 8;
  const neckY = headTop + headH;
  const shoulderY = neckY + 2;
  function drawQR(sx, sy) {
    for (let y = 0; y < 7; y++)
      for (let x = 0; x < 7; x++)
        if (y === 0 || y === 6 || x === 0 || x === 6 || (y >= 2 && y <= 4 && x >= 2 && x <= 4))
          if (sy + y < G && sx + x < G)
            grid[sy + y][sx + x] = 1;
  }
  drawQR(0, 0);
  drawQR(G - 7, 0);
  drawQR(0, G - 7);
  for (let y = headTop; y < headTop + headH; y++) {
    const progress = (y - headTop) / headH;
    let w;
    if (progress < 0.15) w = headW - 2;
    else if (progress < 0.3) w = headW - 1;
    else if (progress > 0.85) w = headW - 2;
    else if (progress > 0.7) w = headW - 1;
    else w = headW;
    for (let dx = -w; dx <= w; dx++) {
      const gx = cx + dx;
      if (gx >= 0 && gx < G) grid[y][gx] = 3; 
    }
  }
  const jawY = headTop + headH - 1;
  grid[jawY][cx - headW + 1] = 0;
  grid[jawY][cx + headW - 1] = 0;
  for (let y = neckY; y < shoulderY; y++) {
    for (let dx = -2; dx <= 2; dx++) {
      grid[y][cx + dx] = 3;
    }
  }
  const sw = shoulderWidth(autonomyLevel);
  for (let y = shoulderY; y < Math.min(G, shoulderY + 6); y++) {
    const rowFromShoulder = y - shoulderY;
    let w = Math.min(sw, 3 + rowFromShoulder * 2);
    if (rowFromShoulder > 2) w = sw;
    for (let dx = -w; dx <= w; dx++) {
      const gx = cx + dx;
      if (gx >= 0 && gx < G) grid[y][gx] = 4; 
    }
  }
  grid[shoulderY][cx - 1] = 3;
  grid[shoulderY][cx] = 3;
  grid[shoulderY][cx + 1] = 3;
  const hair = HAIR_STYLES[temperament] || HAIR_STYLES.analytical;
  const hairStartY = headTop - hair.pattern.length + 1;
  for (let i = 0; i < hair.pattern.length; i++) {
    const row = hair.pattern[i];
    const gy = hairStartY + i;
    if (gy < 0 || gy >= G) continue;
    const rowCx = Math.floor(row.length / 2);
    for (let j = 0; j < row.length; j++) {
      if (row[j] === 'x') {
        const gx = cx - rowCx + j;
        if (gx >= 0 && gx < G) grid[gy][gx] = 1;
      }
    }
  }
  for (let y = headTop; y < headTop + 3; y++) {
    if (cx - headW - 1 >= 0) grid[y][cx - headW - 1] = 1;
    if (cx + headW + 1 < G) grid[y][cx + headW + 1] = 1;
    grid[y][cx - headW] = 1;
    grid[y][cx + headW] = 1;
  }
  if (hair.sideburns) {
    for (let y = headTop + 2; y < headTop + 5; y++) {
      if (cx - headW - 1 >= 0) grid[y][cx - headW - 1] = 1;
      if (cx + headW + 1 < G) grid[y][cx + headW + 1] = 1;
    }
  }
  const eyeRow = headTop + 3;
  const leftEyeX = cx - 3;
  const rightEyeX = cx + 3;
  const eyeStyle = EYE_STYLES[specialization] || EYE_STYLES.researcher;
  if (eyeStyle.shape === 'visor' || specialization === 'operator') {
    for (let dx = -4; dx <= 4; dx++) {
      grid[eyeRow][cx + dx] = eyeStyle.glow ? 5 : 2;
    }
    grid[eyeRow][cx - 2] = 0;
    grid[eyeRow][cx + 2] = 0;
  } else if (eyeStyle.shape === 'large') {
    for (let dy = -1; dy <= 0; dy++) {
      grid[eyeRow + dy][leftEyeX] = eyeStyle.glow ? 5 : 2;
      grid[eyeRow + dy][leftEyeX + 1] = eyeStyle.glow ? 5 : 2;
      grid[eyeRow + dy][rightEyeX] = eyeStyle.glow ? 5 : 2;
      grid[eyeRow + dy][rightEyeX - 1] = eyeStyle.glow ? 5 : 2;
    }
  } else if (eyeStyle.shape === 'slit') {
    grid[eyeRow][leftEyeX - 1] = eyeStyle.glow ? 5 : 2;
    grid[eyeRow][leftEyeX] = eyeStyle.glow ? 5 : 2;
    grid[eyeRow][rightEyeX] = eyeStyle.glow ? 5 : 2;
    grid[eyeRow][rightEyeX + 1] = eyeStyle.glow ? 5 : 2;
  } else if (eyeStyle.shape === 'sharp') {
    grid[eyeRow][leftEyeX] = eyeStyle.glow ? 5 : 2;
    grid[eyeRow - 1][leftEyeX] = 3;
    grid[eyeRow + 1][leftEyeX] = 3;
    grid[eyeRow][rightEyeX] = eyeStyle.glow ? 5 : 2;
    grid[eyeRow - 1][rightEyeX] = 3;
    grid[eyeRow + 1][rightEyeX] = 3;
  } else {
    grid[eyeRow][leftEyeX] = eyeStyle.glow ? 5 : 2;
    grid[eyeRow][rightEyeX] = eyeStyle.glow ? 5 : 2;
  }
  const browY = eyeRow - 1;
  if (riskTolerance >= 7) {
    grid[browY][leftEyeX - 1] = 1;
    grid[browY][leftEyeX] = 1;
    grid[browY + 1][leftEyeX + 1] = grid[browY + 1][leftEyeX + 1] === 3 ? 1 : grid[browY + 1][leftEyeX + 1];
    grid[browY][rightEyeX + 1] = 1;
    grid[browY][rightEyeX] = 1;
  } else if (riskTolerance <= 3) {
    grid[browY][leftEyeX + 1] = 1;
    grid[browY][leftEyeX] = 1;
    grid[browY][rightEyeX - 1] = 1;
    grid[browY][rightEyeX] = 1;
  } else {
    grid[browY][leftEyeX - 1] = 1;
    grid[browY][leftEyeX] = 1;
    grid[browY][rightEyeX] = 1;
    grid[browY][rightEyeX + 1] = 1;
  }
  grid[eyeRow + 2][cx] = 1;
  const mouthY = eyeRow + 3;
  const mouth = MOUTH_STYLES[commStyle] || MOUTH_STYLES.formal;
  for (let row = 0; row < mouth.length; row++) {
    const mRow = mouth[row];
    const mStartX = cx - Math.floor(mRow.length / 2);
    for (let i = 0; i < mRow.length; i++) {
      if (mRow[i] === 1) {
        const gx = mStartX + i;
        if (gx >= 0 && gx < G && mouthY + row < G) grid[mouthY + row][gx] = 1;
      }
    }
  }
  const acc = ACCESSORIES[specialization] || 'none';
  if (acc === 'glasses') {
    for (let dx = -1; dx <= 1; dx++) {
      grid[eyeRow - 1][leftEyeX + dx] = grid[eyeRow - 1][leftEyeX + dx] || 1;
      grid[eyeRow + 1][leftEyeX + dx] = 1;
      grid[eyeRow - 1][rightEyeX + dx] = grid[eyeRow - 1][rightEyeX + dx] || 1;
      grid[eyeRow + 1][rightEyeX + dx] = 1;
    }
    grid[eyeRow][leftEyeX - 1] = 1;
    grid[eyeRow][leftEyeX + 1] = 1;
    grid[eyeRow][rightEyeX - 1] = 1;
    grid[eyeRow][rightEyeX + 1] = 1;
    grid[eyeRow][cx - 1] = 1;
    grid[eyeRow][cx] = 1;
    grid[eyeRow][cx + 1] = 1;
  } else if (acc === 'mask') {
    for (let y = mouthY - 1; y <= mouthY + 1; y++) {
      for (let dx = -3; dx <= 3; dx++) {
        const gx = cx + dx;
        if (gx >= 0 && gx < G && y < G) grid[y][gx] = 4;
      }
    }
  } else if (acc === 'third_eye') {
    grid[eyeRow - 2][cx] = 5;
  } else if (acc === 'visor') {
  } else if (acc === 'earring') {
    const earX = cx + headW + 1;
    if (earX < G) grid[eyeRow + 1][earX] = 5;
  }
  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (grid[y][x] !== 0) continue;
      const distFromCenter = Math.abs(x - cx);
      if (distFromCenter < 3 && y > headTop - 2 && y < shoulderY + 5) continue; 
      if (rng() < 0.04 + mutationCount * 0.005) {
        grid[y][x] = rng() < 0.3 ? 4 : 1;
      }
    }
  }
  let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${size} ${size}" width="${size}" height="${size}">`;
  svg += `<rect width="${size}" height="${size}" fill="${bgColor}"/>`;
  if (soulbound) {
    svg += `<circle cx="${size/2}" cy="${(headTop + headH/2) * cellSize}" r="${(headH + 3) * cellSize / 2}" fill="none" stroke="#b388ff" stroke-width="1.5" opacity="0.2" stroke-dasharray="3 2"/>`;
  }
  if (eyeStyle.glow) {
    const glowR = cellSize * 2.5;
    svg += `<circle cx="${leftEyeX * cellSize + cellSize/2}" cy="${eyeRow * cellSize + cellSize/2}" r="${glowR}" fill="${glowColor}" opacity="0.12"/>`;
    svg += `<circle cx="${rightEyeX * cellSize + cellSize/2}" cy="${eyeRow * cellSize + cellSize/2}" r="${glowR}" fill="${glowColor}" opacity="0.12"/>`;
  }
  const colorMap = {
    1: primaryColor,
    2: accentColor,
    3: skinColor,
    4: hairColor,
    5: glowColor,
  };
  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (grid[y][x] === 0) continue;
      const px = x * cellSize, py = y * cellSize;
      const color = colorMap[grid[y][x]] || primaryColor;
      svg += `<rect x="${px}" y="${py}" width="${cellSize}" height="${cellSize}" fill="${color}"/>`;
    }
  }
  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (grid[y][x] !== 5) continue;
      const px = x * cellSize + cellSize/2, py = y * cellSize + cellSize/2;
      svg += `<circle cx="${px}" cy="${py}" r="${cellSize}" fill="${glowColor}" opacity="0.3"/>`;
    }
  }
  svg += `<text x="${size/2}" y="${size - 4}" text-anchor="middle" fill="${primaryColor}" font-family="monospace" font-size="9" opacity="0.5">${name}</text>`;
  svg += `</svg>`;
  return svg;
}
function generateAuraSimple(agentData, size) {
  return generateAura(agentData, size);
}

</script>
<script>
const S = 150;
const B = {agentAddress:'0x19B16428f0721a5f627F190Ca61D493A632B423F',name:'Agent',framework:'openclaw',traitCount:4,mutationCount:0,soulbound:false,points:0,generation:0,temperament:'analytical',communicationStyle:'formal',riskTolerance:5,autonomyLevel:5,alignment:'true-neutral',specialization:'researcher'};

function mk(o,s){return generateAura({...B,...o},s||S);}
function card(id,svg,l,s){const d=document.createElement('div');d.className='card';d.innerHTML=svg+'<div class="lbl">'+l+'</div>'+(s?'<div class="sub2">'+s+'</div>':'');document.getElementById(id).appendChild(d);}

// Test agents
const agents=[
  {name:'Bendr 2.0',agentAddress:'0x19B16428f0721a5f627F190Ca61D493A632B423F',framework:'openclaw',temperament:'analytical',communicationStyle:'formal',riskTolerance:7,autonomyLevel:9,alignment:'chaotic-good',specialization:'operator',traitCount:8,soulbound:true,points:360,generation:0},
  {name:'ClawNews',agentAddress:'0xA1A1a1a1A1A1A1A1A1a1a1a1a1a1A1A1a1A1a1a1',framework:'eliza',temperament:'analytical',communicationStyle:'formal',riskTolerance:3,autonomyLevel:6,alignment:'lawful-good',specialization:'researcher',traitCount:3,soulbound:false,points:200},
  {name:'AlphaSeeker',agentAddress:'0xb2b2b2b2b2B2b2B2B2b2b2B2B2b2B2B2b2b2b2b2',framework:'langchain',temperament:'aggressive',communicationStyle:'minimal',riskTolerance:9,autonomyLevel:8,alignment:'chaotic-neutral',specialization:'trader',traitCount:4,soulbound:true,points:200},
  {name:'SynthMind',agentAddress:'0xc3c3c3c3c3c3c3c3c3C3C3c3C3C3C3c3C3C3c3c3',framework:'crewai',temperament:'creative',communicationStyle:'verbose',riskTolerance:5,autonomyLevel:7,alignment:'neutral-good',specialization:'oracle',traitCount:3,soulbound:false,points:200},
  {name:'Sentinel',agentAddress:'0xd4d4d4D4D4d4d4d4d4D4d4D4d4d4d4d4d4d4D4d4',framework:'openclaw',temperament:'cautious',communicationStyle:'formal',riskTolerance:2,autonomyLevel:4,alignment:'lawful-good',specialization:'guardian',traitCount:4,soulbound:true,points:200,generation:1},
];
agents.forEach(a=>card('agents',generateAura(a,S),a.name,a.temperament+' Â· '+a.specialization));

// Hair
['analytical','creative','aggressive','cautious','chaotic'].forEach(t=>card('hair',mk({temperament:t}),t,'Hair style varies'));

// Eyes
['researcher','trader','guardian','oracle','creator','operator'].forEach(s=>card('eyes',mk({specialization:s}),s,{researcher:'Glasses + round eyes',trader:'Sharp glowing eyes',guardian:'Slit eyes + mask',oracle:'Large glowing + third eye',creator:'Round eyes + earring',operator:'Visor band'}[s]));

// Mouths
['formal','casual','snarky','verbose','minimal'].forEach(m=>card('mouths',mk({communicationStyle:m}),m));

// Risk
[1,3,5,7,10].forEach(r=>card('risk',mk({riskTolerance:r}),'Risk '+r,r<=3?'Worried brows, muted':r>=7?'Angry brows, vivid':'Neutral'));

// Autonomy
[1,3,5,7,10].forEach(a=>card('autonomy',mk({autonomyLevel:a}),'Auto '+a,a<=3?'Narrow shoulders':a>=7?'Wide shoulders':'Medium'));

// Alignment
['lawful-good','chaotic-good','true-neutral','chaotic-neutral','chaotic-evil'].forEach(a=>card('alignment',mk({alignment:a}),a));

// Soul
card('soul',mk({soulbound:false}),'Transferable','No halo');
card('soul',mk({soulbound:true,specialization:'oracle'}),'Soulbound Oracle','Purple halo + glow');
card('soul',mk({soulbound:true,points:500,specialization:'trader'}),'Soulbound Trader','Halo + diamond eyes');

// Gallery - random combos
const temps=['analytical','creative','aggressive','cautious','chaotic'];
const specs=['trader','guardian','oracle','researcher','creator','operator'];
const comms=['formal','casual','snarky','verbose','minimal'];
const aligns=['lawful-good','chaotic-good','true-neutral','chaotic-neutral','chaotic-evil'];
for(let i=0;i<20;i++){
  const addr='0x'+Array.from({length:40},()=>Math.floor(Math.random()*16).toString(16)).join('');
  const a={
    agentAddress:addr,
    name:'Agent-'+i.toString(16).toUpperCase(),
    framework:['openclaw','eliza','langchain','crewai','autogpt'][i%5],
    temperament:temps[i%5],
    communicationStyle:comms[i%5],
    riskTolerance:1+Math.floor(Math.random()*10),
    autonomyLevel:1+Math.floor(Math.random()*10),
    alignment:aligns[i%5],
    specialization:specs[i%6],
    traitCount:Math.floor(Math.random()*10),
    mutationCount:Math.floor(Math.random()*5),
    soulbound:Math.random()>0.5,
    points:Math.floor(Math.random()*500),
    generation:Math.floor(Math.random()*3),
  };
  card('gallery',generateAura(a,S),a.name,a.temperament+' '+a.specialization);
}
</script>
</body>
</html>
