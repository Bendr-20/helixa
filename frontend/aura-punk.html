<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Helixa Aura â€” CryptoPunk Style</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0a0a;color:#e0e0e0;font-family:'SF Mono','Fira Code',monospace;padding:20px}
h1{color:#00ff88;font-size:1.5rem;text-align:center;margin-bottom:0.5rem}
.sub{color:#666;text-align:center;font-size:0.8rem;margin-bottom:2rem}
.section{margin-bottom:2.5rem}
.section h2{color:#00ff88;font-size:0.95rem;margin-bottom:1rem;padding-bottom:0.5rem;border-bottom:1px solid #1a1a1a}
.row{display:flex;flex-wrap:wrap;gap:10px;justify-content:center}
.card{background:#0f0f0f;border:1px solid #1a1a1a;border-radius:8px;padding:8px;text-align:center;width:140px}
.card svg{border-radius:4px;margin-bottom:4px;image-rendering:pixelated}
.card .lbl{font-size:9px;color:#00ff88;font-weight:bold}
.card .sub2{font-size:7px;color:#666;line-height:1.3;margin-top:2px}
</style>
</head>
<body>
<h1>ðŸ§¬ Helixa Aura â€” CryptoPunk Edition</h1>
<p class="sub">24x24 pixel art agent portraits. Every trait shapes the look.</p>

<div class="section"><h2>The 5 Test Agents</h2><div class="row" id="agents"></div></div>
<div class="section"><h2>Hair Ã— Temperament</h2><div class="row" id="hair"></div></div>
<div class="section"><h2>Eyes Ã— Specialization</h2><div class="row" id="eyes"></div></div>
<div class="section"><h2>Mouth Ã— Communication</h2><div class="row" id="mouths"></div></div>
<div class="section"><h2>Color Ã— Alignment</h2><div class="row" id="align"></div></div>
<div class="section"><h2>Random Gallery (30)</h2><div class="row" id="gallery"></div></div>

<script>
function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}
function seededRandom(seed) {
  let s = seed;
  return function() {
    s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
    return (s >>> 0) / 0xFFFFFFFF;
  };
}
// Skin tone palette (6 options, picked from address hash)
const SKIN_TONES = [
  { base: '#c8a07e', shadow: '#a67c5b', highlight: '#dbb896' }, // warm tan
  { base: '#e0b88a', shadow: '#c49a6c', highlight: '#f0d0a4' }, // light
  { base: '#8d5524', shadow: '#6b3f1a', highlight: '#a86b3e' }, // brown
  { base: '#503020', shadow: '#3a2218', highlight: '#6a4430' }, // dark brown
  { base: '#b8d4e3', shadow: '#8fb4c8', highlight: '#d0e8f5' }, // alien blue
  { base: '#c8e8c0', shadow: '#98c890', highlight: '#e0f8d8' }, // alien green
];
// Hair styles (pixel rows relative to head top)
// Each style is an array of rows, each row is [startX, endX] pairs relative to center(12)
const HAIR_STYLES = {
  // 0: short clean
  short: (grid, skin, color, rng) => {
    fillRect(grid, 6, 3, 12, 3, color);
    fillRect(grid, 5, 4, 14, 2, color);
    fillRect(grid, 5, 6, 2, 3, color);
    fillRect(grid, 17, 6, 2, 3, color);
  },
  // 1: messy/spiky
  spiky: (grid, skin, color, rng) => {
    fillRect(grid, 7, 1, 2, 2, color);
    fillRect(grid, 11, 0, 2, 3, color);
    fillRect(grid, 15, 1, 2, 2, color);
    fillRect(grid, 5, 3, 14, 3, color);
    fillRect(grid, 5, 6, 2, 4, color);
    fillRect(grid, 17, 6, 2, 4, color);
  },
  // 2: long flowing
  long: (grid, skin, color, rng) => {
    fillRect(grid, 6, 3, 12, 3, color);
    fillRect(grid, 5, 4, 14, 2, color);
    fillRect(grid, 4, 6, 3, 10, color);
    fillRect(grid, 17, 6, 3, 10, color);
    fillRect(grid, 4, 16, 4, 2, color);
    fillRect(grid, 16, 16, 4, 2, color);
  },
  // 3: mohawk
  mohawk: (grid, skin, color, rng) => {
    fillRect(grid, 10, 0, 4, 6, color);
    fillRect(grid, 9, 2, 6, 4, color);
  },
  // 4: hood/beanie
  hood: (grid, skin, color, rng) => {
    fillRect(grid, 5, 2, 14, 5, color);
    fillRect(grid, 4, 4, 16, 3, color);
    fillRect(grid, 4, 7, 2, 2, color);
    fillRect(grid, 18, 7, 2, 2, color);
    // Brim line
    fillRect(grid, 5, 7, 14, 1, shade(color, -30));
  },
  // 5: bald/shaved
  bald: (grid, skin, color, rng) => {
    // Just a slight shadow on top
    fillRect(grid, 7, 5, 10, 1, shade(skin.shadow, -10));
  },
};
// Eye types
const EYE_TYPES = {
  normal: (grid, lx, rx, y, colors) => {
    fillRect(grid, lx, y, 2, 2, '#fff');
    fillRect(grid, rx, y, 2, 2, '#fff');
    grid[y+1][lx+1] = colors.pupil;
    grid[y+1][rx] = colors.pupil;
  },
  laser: (grid, lx, rx, y, colors) => {
    fillRect(grid, lx, y, 2, 2, '#ff3030');
    fillRect(grid, rx, y, 2, 2, '#ff3030');
    grid[y][lx] = '#ff8080'; grid[y][rx+1] = '#ff8080';
  },
  visor: (grid, lx, rx, y, colors) => {
    fillRect(grid, lx - 1, y, rx - lx + 4, 2, colors.visorColor);
    fillRect(grid, lx - 1, y, rx - lx + 4, 1, shade(colors.visorColor, 20));
  },
  shades: (grid, lx, rx, y, colors) => {
    fillRect(grid, lx - 1, y, 4, 2, '#111');
    fillRect(grid, rx - 1, y, 4, 2, '#111');
    fillRect(grid, lx + 2, y, rx - lx - 2, 1, '#111'); // bridge
    grid[y][lx - 1] = '#333'; grid[y][rx + 2] = '#333'; // shine
  },
  wide: (grid, lx, rx, y, colors) => {
    fillRect(grid, lx - 1, y, 3, 3, '#fff');
    fillRect(grid, rx, y, 3, 3, '#fff');
    grid[y+1][lx] = colors.pupil;
    grid[y+1][rx+1] = colors.pupil;
    grid[y+2][lx] = colors.pupil;
    grid[y+2][rx+1] = colors.pupil;
  },
  glowing: (grid, lx, rx, y, colors) => {
    const gc = colors.glowColor;
    fillRect(grid, lx, y, 2, 2, gc);
    fillRect(grid, rx, y, 2, 2, gc);
    grid[y][lx-1] = shade(gc, -20); grid[y][rx+2] = shade(gc, -20);
    grid[y+1][lx-1] = shade(gc, -20); grid[y+1][rx+2] = shade(gc, -20);
  },
};
// Mouth types
const MOUTH_TYPES = {
  neutral: (grid, cx, y) => { fillRect(grid, cx - 2, y, 4, 1, '#3a2020'); },
  smile: (grid, cx, y) => {
    fillRect(grid, cx - 2, y, 4, 1, '#3a2020');
    grid[y+1][cx-2] = '#3a2020'; grid[y+1][cx+1] = '#3a2020';
  },
  smirk: (grid, cx, y) => {
    fillRect(grid, cx - 1, y, 3, 1, '#3a2020');
    grid[y-1][cx+2] = '#3a2020';
  },
  open: (grid, cx, y) => {
    fillRect(grid, cx - 2, y, 4, 2, '#2a1515');
    grid[y][cx-1] = '#802020'; grid[y][cx] = '#802020';
  },
  grin: (grid, cx, y) => {
    fillRect(grid, cx - 3, y, 6, 1, '#3a2020');
    grid[y+1][cx-3] = '#3a2020'; grid[y+1][cx+2] = '#3a2020';
    fillRect(grid, cx - 2, y, 4, 1, '#fff'); // teeth
  },
  tiny: (grid, cx, y) => { fillRect(grid, cx - 1, y, 2, 1, '#3a2020'); },
};
// Accessories
const ACCESSORY_TYPES = {
  none: () => {},
  earring: (grid, side, color) => { grid[11][side === 'l' ? 5 : 18] = color; },
  scar: (grid) => {
    grid[9][8] = '#604040'; grid[10][9] = '#604040'; grid[11][8] = '#604040';
  },
  mask: (grid) => {
    fillRect(grid, 7, 13, 10, 3, '#333');
    fillRect(grid, 8, 13, 8, 1, '#444');
  },
  headphones: (grid, s, color) => {
    fillRect(grid, 4, 7, 2, 4, '#444');
    fillRect(grid, 18, 7, 2, 4, '#444');
    fillRect(grid, 5, 4, 14, 1, '#444');
  },
  antenna: (grid, s, color) => {
    grid[1][12] = color; grid[2][12] = color; grid[3][12] = color;
    grid[0][12] = '#fff';
  },
};
// ============ HELPERS ============
function fillRect(grid, x, y, w, h, color) {
  for (let dy = 0; dy < h; dy++)
    for (let dx = 0; dx < w; dx++)
      if (y+dy >= 0 && y+dy < 24 && x+dx >= 0 && x+dx < 24)
        grid[y+dy][x+dx] = color;
}
function shade(hex, amount) {
  if (!hex || hex[0] !== '#') return hex;
  let r = parseInt(hex.slice(1,3), 16) + amount;
  let g = parseInt(hex.slice(3,5), 16) + amount;
  let b = parseInt(hex.slice(5,7), 16) + amount;
  r = Math.max(0, Math.min(255, r));
  g = Math.max(0, Math.min(255, g));
  b = Math.max(0, Math.min(255, b));
  return '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
}
function hslToHex(h, s, l) {
  s /= 100; l /= 100;
  const a = s * Math.min(l, 1 - l);
  const f = n => {
    const k = (n + h / 30) % 12;
    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return Math.round(255 * color).toString(16).padStart(2, '0');
  };
  return '#' + f(0) + f(8) + f(4);
}
// ============ MAIN ============
function generateAura(agentData, size) {
  size = size || 336; // 336 = 24 * 14px per pixel
  const G = 24;
  const px = size / G;
  const address = agentData.agentAddress || agentData.address || '0x0000';
  const framework = agentData.framework || 'custom';
  const name = agentData.name || 'Agent';
  const traitCount = agentData.traitCount || 0;
  const mutationCount = agentData.mutationCount || 0;
  const soulbound = agentData.soulbound || false;
  const points = agentData.points || 0;
  const generation = agentData.generation || 0;
  const temperament = agentData.temperament || 'analytical';
  const commStyle = agentData.communicationStyle || 'formal';
  const riskTolerance = agentData.riskTolerance || 5;
  const autonomyLevel = agentData.autonomyLevel || 5;
  const alignment = agentData.alignment || 'true-neutral';
  const specialization = agentData.specialization || 'researcher';
  const seed = simpleHash(address + name + framework + temperament + alignment + specialization);
  const rng = seededRandom(seed);
  // Grid of hex color strings (null = transparent)
  const grid = Array.from({length: G}, () => Array(G).fill(null));
  // --- Pick traits deterministically ---
  const addrHash = simpleHash(address);
  const nameHash = simpleHash(name);
  // Skin tone
  const skinIdx = addrHash % SKIN_TONES.length;
  const skin = SKIN_TONES[skinIdx];
  // Hair color from address
  const hairHue = (addrHash * 7) % 360;
  const hairSat = 30 + (nameHash % 40);
  const hairLight = 20 + (addrHash % 30);
  const hairColor = hslToHex(hairHue, hairSat, hairLight);
  // Accent color from framework
  const fwHues = { openclaw: 150, eliza: 280, langchain: 200, crewai: 30, autogpt: 0, custom: 60 };
  const accentHue = fwHues[framework] || 60;
  const accentColor = hslToHex(accentHue, 70, 55);
  // Eye pupil color
  const pupilColors = ['#1a1a2e', '#2d1b69', '#1b3a1b', '#3a1b1b', '#1b2d3a'];
  const pupilColor = pupilColors[nameHash % pupilColors.length];
  // Background from alignment
  const bgColors = {
    'lawful-good':'#4a6670','neutral-good':'#506050','chaotic-good':'#6a5050',
    'lawful-neutral':'#505060','true-neutral':'#505050','chaotic-neutral':'#605040',
    'lawful-evil':'#503050','neutral-evil':'#403040','chaotic-evil':'#502020',
  };
  const bgColor = bgColors[alignment] || '#505050';
  // --- DRAW BASE HEAD ---
  // Neck
  fillRect(grid, 9, 15, 6, 3, skin.base);
  fillRect(grid, 10, 15, 4, 3, skin.base);
  // Head shape (oval-ish)
  fillRect(grid, 7, 5, 10, 11, skin.base);
  fillRect(grid, 6, 6, 12, 9, skin.base);
  fillRect(grid, 8, 5, 8, 1, skin.base);
  // Face shadow
  fillRect(grid, 6, 6, 1, 9, skin.shadow);
  fillRect(grid, 17, 6, 1, 9, skin.shadow);
  fillRect(grid, 7, 15, 10, 1, skin.shadow);
  // Face highlight
  fillRect(grid, 8, 6, 3, 2, skin.highlight);
  // Ears
  fillRect(grid, 5, 8, 1, 3, skin.shadow);
  fillRect(grid, 18, 8, 1, 3, skin.shadow);
  // --- SHOULDERS / BODY ---
  fillRect(grid, 3, 18, 18, 6, accentColor);
  fillRect(grid, 5, 17, 14, 1, accentColor);
  fillRect(grid, 4, 18, 16, 1, shade(accentColor, 15));
  // Collar
  fillRect(grid, 9, 17, 6, 1, shade(accentColor, -15));
  fillRect(grid, 8, 18, 8, 1, shade(accentColor, 10));
  // --- HAIR (temperament) ---
  const hairKeys = Object.keys(HAIR_STYLES);
  const hairMap = { analytical: 'short', creative: 'long', aggressive: 'mohawk', cautious: 'hood', chaotic: 'spiky' };
  const hairStyle = hairMap[temperament] || hairKeys[addrHash % hairKeys.length];
  HAIR_STYLES[hairStyle](grid, skin, hairColor, rng);
  // --- EYES (specialization) ---
  const eyeLX = 8, eyeRX = 14, eyeY = 9;
  const eyeMap = {
    researcher: 'normal', trader: 'laser', guardian: 'visor',
    oracle: 'glowing', creator: 'wide', operator: 'shades',
  };
  const eyeType = eyeMap[specialization] || 'normal';
  const eyeColors = {
    pupil: pupilColor,
    visorColor: hslToHex(accentHue, 60, 40),
    glowColor: hslToHex((accentHue + 60) % 360, 80, 60),
  };
  EYE_TYPES[eyeType](grid, eyeLX, eyeRX, eyeY, eyeColors);
  // Eyebrows (risk tolerance)
  if (eyeType !== 'visor' && eyeType !== 'shades') {
    if (riskTolerance >= 7) {
      // Angry angled
      grid[8][8] = hairColor; grid[8][9] = hairColor;
      grid[7][10] = hairColor;
      grid[8][15] = hairColor; grid[8][14] = hairColor;
      grid[7][13] = hairColor;
    } else if (riskTolerance <= 3) {
      // Worried
      grid[7][8] = hairColor; grid[8][9] = hairColor;
      grid[8][10] = hairColor;
      grid[7][15] = hairColor; grid[8][14] = hairColor;
      grid[8][13] = hairColor;
    } else {
      // Neutral
      grid[8][8] = hairColor; grid[8][9] = hairColor; grid[8][10] = hairColor;
      grid[8][13] = hairColor; grid[8][14] = hairColor; grid[8][15] = hairColor;
    }
  }
  // Nose
  grid[11][11] = skin.shadow;
  grid[11][12] = skin.shadow;
  grid[12][12] = skin.shadow;
  // --- MOUTH (communication style) ---
  const mouthMap = { formal: 'neutral', casual: 'smile', snarky: 'smirk', verbose: 'open', minimal: 'tiny' };
  const mouthType = mouthMap[commStyle] || 'neutral';
  MOUTH_TYPES[mouthType](grid, 12, 14);
  // --- ACCESSORY (deterministic from traits) ---
  const accKeys = Object.keys(ACCESSORY_TYPES);
  const accIdx = (addrHash + nameHash) % (accKeys.length + 2); // +2 for higher chance of 'none'
  const accType = accIdx < accKeys.length ? accKeys[accIdx] : 'none';
  if (ACCESSORY_TYPES[accType]) ACCESSORY_TYPES[accType](grid, 'l', accentColor);
  // Soulbound marker (small diamond in bottom-right)
  if (soulbound) {
    grid[21][21] = '#b388ff';
    grid[20][22] = '#b388ff'; grid[22][22] = '#b388ff';
    grid[21][23] = '#b388ff';
  }
  // QR corner hint (tiny 3x3 in bottom-right for brand)
  fillRect(grid, 21, 0, 3, 3, accentColor);
  grid[1][22] = bgColor;
  // ============ RENDER SVG ============
  const svgNS = 'http:' + '//www.w3.org/2000/svg';
  let svg = `<svg xmlns="${svgNS}" viewBox="0 0 ${size} ${size}" width="${size}" height="${size}">`;
  svg += `<rect width="${size}" height="${size}" fill="${bgColor}"/>`;
  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (!grid[y][x]) continue;
      svg += `<rect x="${x*px}" y="${y*px}" width="${px}" height="${px}" fill="${grid[y][x]}"/>`;
    }
  }
  svg += `</svg>`;
  return svg;
}
function generateAuraSimple(agentData, size) {
  return generateAura(agentData, size);
}
</script>
<script>
const S=120;
const B={agentAddress:'0x19B16428f0721a5f627F190Ca61D493A632B423F',name:'Agent',framework:'openclaw',traitCount:4,mutationCount:0,soulbound:false,points:0,generation:0,temperament:'analytical',communicationStyle:'formal',riskTolerance:5,autonomyLevel:5,alignment:'true-neutral',specialization:'researcher'};
function mk(o){return generateAura({...B,...o},S);}
function card(id,svg,l,s){const d=document.createElement('div');d.className='card';d.innerHTML=svg+'<div class="lbl">'+l+'</div>'+(s?'<div class="sub2">'+s+'</div>':'');document.getElementById(id).appendChild(d);}

const agents=[
  {name:'Bendr 2.0',agentAddress:'0x19B16428f0721a5f627F190Ca61D493A632B423F',framework:'openclaw',temperament:'analytical',communicationStyle:'formal',riskTolerance:7,autonomyLevel:9,alignment:'chaotic-good',specialization:'operator',traitCount:8,soulbound:true,points:360},
  {name:'ClawNews',agentAddress:'0xA1A1a1a1A1A1A1A1A1a1a1a1a1a1A1A1a1A1a1a1',framework:'eliza',temperament:'analytical',communicationStyle:'formal',riskTolerance:3,autonomyLevel:6,alignment:'lawful-good',specialization:'researcher',traitCount:3},
  {name:'AlphaSeeker',agentAddress:'0xb2b2b2b2b2B2b2B2B2b2b2B2B2b2B2B2b2b2b2b2',framework:'langchain',temperament:'aggressive',communicationStyle:'minimal',riskTolerance:9,autonomyLevel:8,alignment:'chaotic-neutral',specialization:'trader',traitCount:4,soulbound:true},
  {name:'SynthMind',agentAddress:'0xc3c3c3c3c3c3c3c3c3C3C3c3C3C3C3c3C3C3c3c3',framework:'crewai',temperament:'creative',communicationStyle:'verbose',riskTolerance:5,autonomyLevel:7,alignment:'neutral-good',specialization:'oracle',traitCount:3},
  {name:'Sentinel',agentAddress:'0xd4d4d4D4D4d4d4d4d4D4d4D4d4d4d4d4d4d4D4d4',framework:'openclaw',temperament:'cautious',communicationStyle:'formal',riskTolerance:2,autonomyLevel:4,alignment:'lawful-good',specialization:'guardian',traitCount:4,soulbound:true,generation:1},
];
agents.forEach(a=>card('agents',generateAura(a,S),a.name,a.temperament+' Â· '+a.specialization));

['analytical','creative','aggressive','cautious','chaotic'].forEach(t=>card('hair',mk({temperament:t,agentAddress:'0x'+t}),t,{analytical:'Short clean',creative:'Long flowing',aggressive:'Mohawk',cautious:'Hood/beanie',chaotic:'Spiky messy'}[t]));

['researcher','trader','guardian','oracle','creator','operator'].forEach(s=>card('eyes',mk({specialization:s,agentAddress:'0x'+s}),s,{researcher:'Normal eyes + glasses',trader:'Laser red eyes',guardian:'Visor band',oracle:'Glowing eyes',creator:'Wide eyes',operator:'Dark shades'}[s]));

['formal','casual','snarky','verbose','minimal'].forEach(m=>card('mouths',mk({communicationStyle:m,agentAddress:'0x'+m}),m));

['lawful-good','chaotic-good','true-neutral','chaotic-neutral','chaotic-evil'].forEach(a=>card('align',mk({alignment:a,agentAddress:'0x'+a}),a));

const temps=['analytical','creative','aggressive','cautious','chaotic'];
const specs=['trader','guardian','oracle','researcher','creator','operator'];
const comms=['formal','casual','snarky','verbose','minimal'];
const aligns=['lawful-good','chaotic-good','true-neutral','chaotic-neutral','chaotic-evil'];
const fws=['openclaw','eliza','langchain','crewai','autogpt'];
for(let i=0;i<30;i++){
  const addr='0x'+Array.from({length:40},()=>Math.floor(Math.random()*16).toString(16)).join('');
  card('gallery',generateAura({
    agentAddress:addr,name:'Agent-'+i.toString(16).toUpperCase(),
    framework:fws[i%5],temperament:temps[i%5],communicationStyle:comms[i%5],
    riskTolerance:1+Math.floor(Math.random()*10),autonomyLevel:1+Math.floor(Math.random()*10),
    alignment:aligns[i%5],specialization:specs[i%6],
    traitCount:Math.floor(Math.random()*10),mutationCount:Math.floor(Math.random()*5),
    soulbound:Math.random()>0.5,points:Math.floor(Math.random()*500),generation:Math.floor(Math.random()*3),
  },S),'Agent-'+i.toString(16).toUpperCase(),'');
}
</script>
</body>
</html>
