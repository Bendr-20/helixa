<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helixa Face-QR Generator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a;
            color: #e0e0e0;
            font-family: 'SF Mono', 'Fira Code', monospace;
            padding: 2rem;
        }
        h1 { color: #00ff88; text-align: center; margin-bottom: 0.5rem; font-size: 1.5rem; }
        h1 span { color: #555; }
        .subtitle { color: #666; text-align: center; font-size: 0.8rem; margin-bottom: 2rem; }
        
        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            max-width: 1100px;
            margin: 0 auto;
        }
        
        .card {
            background: #111;
            border: 1px solid #222;
            border-radius: 12px;
            overflow: hidden;
            transition: border-color 0.3s;
        }
        .card:hover { border-color: #00ff8850; }
        
        .card-image {
            width: 100%;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #0a0a0a;
        }
        .card-image svg { width: 100%; height: 100%; }
        
        .card-info {
            padding: 12px 16px;
            border-top: 1px solid #222;
        }
        .card-name { color: #00ff88; font-size: 0.9rem; margin-bottom: 4px; }
        .card-meta { color: #666; font-size: 0.7rem; }
        .card-traits {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 8px;
        }
        .trait {
            background: #00ff8812;
            border: 1px solid #00ff8830;
            color: #00ff88;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.6rem;
        }
        .trait.fw {
            background: #ff880012;
            border-color: #ff880030;
            color: #ff8800;
        }
    </style>
</head>
<body>
    <h1>Helixa Face-QR</h1>
    <p class="subtitle">Every agent gets a unique scannable face generated from their onchain AgentDNA data</p>
    
    <div class="gallery" id="gallery"></div>

    <script>
    // Port of the face-QR generator for browser
    function simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash;
        }
        return Math.abs(hash);
    }

    function seededRandom(seed) {
        let s = seed;
        return function() {
            s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
            return (s >>> 0) / 0xFFFFFFFF;
        };
    }

    function getFrameworkStyle(framework) {
        const styles = {
            eliza: { faceRadius: 0.42, mouthCurve: 0.3, baseHue: 280 },
            openclaw: { faceRadius: 0.38, mouthCurve: 0.2, baseHue: 150 },
            langchain: { faceRadius: 0.40, mouthCurve: 0.15, baseHue: 200 },
            crewai: { faceRadius: 0.39, mouthCurve: 0.25, baseHue: 30 },
            autogpt: { faceRadius: 0.41, mouthCurve: 0.1, baseHue: 0 },
            custom: { faceRadius: 0.40, mouthCurve: 0.2, baseHue: 60 },
        };
        return styles[framework] || styles.custom;
    }

    function addressToColor(address) {
        const hash = simpleHash(address);
        const hue = hash % 360;
        return {
            primary: `hsl(${hue}, 70%, 55%)`,
            secondary: `hsl(${(hue + 40) % 360}, 60%, 45%)`,
            accent: `hsl(${(hue + 180) % 360}, 80%, 60%)`,
        };
    }

    function generateFaceQR(agent) {
        const size = 400;
        const gridSize = 25;
        const cellSize = size / gridSize;
        
        const rng = seededRandom(simpleHash(agent.address + agent.name + agent.framework));
        const style = getFrameworkStyle(agent.framework);
        const colors = addressToColor(agent.address);
        
        const cx = gridSize / 2;
        const cy = gridSize / 2;
        const faceR = gridSize * style.faceRadius;

        const grid = Array.from({length: gridSize}, () => Array(gridSize).fill(0));

        // Corner markers
        function drawCorner(sx, sy) {
            for (let y = 0; y < 7; y++)
                for (let x = 0; x < 7; x++)
                    if (y===0||y===6||x===0||x===6||(y>=2&&y<=4&&x>=2&&x<=4))
                        if (sy+y<gridSize&&sx+x<gridSize) grid[sy+y][sx+x] = 1;
        }
        drawCorner(0, 0);
        drawCorner(gridSize-7, 0);
        drawCorner(0, gridSize-7);

        // Face outline
        for (let a = 0; a < 360; a += 3) {
            const rad = a * Math.PI / 180;
            const r = faceR + Math.sin(a * 3 * Math.PI / 180) * 0.8;
            const fx = Math.round(cx + Math.cos(rad) * r);
            const fy = Math.round(cy + Math.sin(rad) * r);
            if (fx>=0&&fx<gridSize&&fy>=0&&fy<gridSize) grid[fy][fx] = 1;
        }

        // Eyes
        const eyeY = Math.round(cy - faceR * 0.35);
        const leX = Math.round(cx - faceR * 0.4);
        const reX = Math.round(cx + faceR * 0.4);
        const eyeS = Math.min(2, 1 + Math.floor((agent.capabilities?.length || 0) / 5));
        
        for (let dy = -eyeS; dy <= eyeS; dy++)
            for (let dx = -eyeS; dx <= eyeS; dx++)
                if (Math.abs(dx)+Math.abs(dy) <= eyeS) {
                    const ly = eyeY+dy;
                    if (ly>=0&&ly<gridSize) {
                        if (leX+dx>=0&&leX+dx<gridSize) grid[ly][leX+dx] = 2;
                        if (reX+dx>=0&&reX+dx<gridSize) grid[ly][reX+dx] = 2;
                    }
                }

        // Mouth
        const mY = Math.round(cy + faceR * 0.3);
        const mW = Math.round(faceR * 0.5);
        for (let dx = -mW; dx <= mW; dx++) {
            const mx = Math.round(cx + dx);
            const my = mY + Math.round(style.mouthCurve * (dx*dx) / (mW||1));
            if (mx>=0&&mx<gridSize&&my>=0&&my<gridSize) grid[my][mx] = 1;
        }

        // Fill interior
        for (let y = 0; y < gridSize; y++)
            for (let x = 0; x < gridSize; x++) {
                if (grid[y][x] !== 0) continue;
                const dist = Math.sqrt((x-cx)**2 + (y-cy)**2);
                if (dist < faceR * 0.85 && rng() < 0.25 + ((agent.mutations||0) * 0.02))
                    grid[y][x] = 1;
            }

        // Build SVG
        let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${size} ${size}">`;
        svg += `<rect width="${size}" height="${size}" fill="#0a0a0a"/>`;
        svg += `<circle cx="${size/2}" cy="${size/2}" r="${faceR*cellSize}" fill="${colors.primary}" opacity="0.06"/>`;

        for (let y = 0; y < gridSize; y++)
            for (let x = 0; x < gridSize; x++) {
                if (grid[y][x] === 0) continue;
                const color = grid[y][x] === 2 ? colors.accent : colors.primary;
                svg += `<rect x="${x*cellSize}" y="${y*cellSize}" width="${cellSize}" height="${cellSize}" rx="${cellSize*0.15}" fill="${color}"/>`;
            }

        svg += `<text x="${size/2}" y="${size-8}" text-anchor="middle" fill="${colors.primary}" font-family="monospace" font-size="10" opacity="0.6">${agent.name}</text>`;
        svg += `</svg>`;
        return svg;
    }

    // Sample agents
    const agents = [
        {
            name: "Bendr 2.0",
            framework: "openclaw",
            address: "0x19B16428f0721a5f627F190Ca61D493A632B423F",
            model: "Claude Opus 4",
            capabilities: ["smart-contracts", "solidity", "full-stack", "research", "code-gen", "architecture", "sub-agents"],
            mutations: 0,
        },
        {
            name: "TradingBot Alpha",
            framework: "eliza",
            address: "0xA1B2C3D4E5F6789012345678901234567890ABCD",
            model: "GPT-4",
            capabilities: ["trading", "defi", "arbitrage", "analysis"],
            mutations: 3,
        },
        {
            name: "ResearchAgent",
            framework: "langchain",
            address: "0x7777888899990000AAAABBBBCCCCDDDDEEEE1111",
            model: "Claude 3.5",
            capabilities: ["research", "summarization", "data-mining", "writing", "citations", "web-scraping"],
            mutations: 1,
        },
        {
            name: "CrewLeader",
            framework: "crewai",
            address: "0xDEADBEEF00112233445566778899AABBCCDDEEFF",
            model: "GPT-4 Turbo",
            capabilities: ["orchestration", "delegation", "planning"],
            mutations: 5,
        },
        {
            name: "AutoBuilder",
            framework: "autogpt",
            address: "0x1234ABCD5678EFGH9012IJKL3456MNOP7890QRST",
            model: "LLaMA 3",
            capabilities: ["autonomous", "code", "deploy", "iterate", "test", "debug", "optimize", "refactor"],
            mutations: 12,
        },
        {
            name: "CustomBot X",
            framework: "custom",
            address: "0xFEDCBA9876543210FEDCBA9876543210FEDCBA98",
            model: "Mistral Large",
            capabilities: ["chat", "support"],
            mutations: 0,
        },
    ];

    const gallery = document.getElementById('gallery');
    agents.forEach(agent => {
        const svg = generateFaceQR(agent);
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
            <div class="card-image">${svg}</div>
            <div class="card-info">
                <div class="card-name">${agent.name}</div>
                <div class="card-meta">${agent.model} · ${agent.mutations} mutations · Gen 0</div>
                <div class="card-traits">
                    <span class="trait fw">${agent.framework}</span>
                    ${agent.capabilities.slice(0, 4).map(c => `<span class="trait">${c}</span>`).join('')}
                </div>
            </div>
        `;
        gallery.appendChild(card);
    });
    </script>
</body>
</html>
