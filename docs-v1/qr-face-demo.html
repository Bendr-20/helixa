<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Helixa â€” Functional QR Aura Demo</title>
<link rel="stylesheet" href="helixa-theme.css?v=3">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Inter', -apple-system, sans-serif; background: var(--bg); color: var(--text); padding: 20px; }
h1 { font-family: 'Space Grotesk', sans-serif; text-align: center; color: var(--accent); margin-bottom: 6px; font-size: 1.4rem; }
.subtitle { text-align: center; color: var(--text2); margin-bottom: 24px; font-size: 0.85rem; }
.grid { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; }
.card { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 16px; text-align: center; }
.card canvas { border-radius: 8px; }
.card .label { font-size: 0.75rem; color: var(--text2); margin-top: 8px; }
.card .scan-note { font-size: 0.65rem; color: var(--text3); margin-top: 4px; }
.comparison { display: flex; gap: 24px; justify-content: center; align-items: start; flex-wrap: wrap; margin-top: 30px; }
.comparison h2 { font-family: 'Space Grotesk', sans-serif; font-size: 1rem; color: var(--text2); text-align: center; width: 100%; margin-bottom: 12px; }
.vs { font-size: 1.5rem; color: var(--text3); align-self: center; padding-top: 20px; }
</style>
</head>
<body>
<h1>ðŸ”® Functional QR Aura â€” Demo</h1>
<p class="subtitle">Real scannable QR codes with personality-driven face overlay. Try scanning with your phone camera.</p>

<div class="comparison">
<h2>Current Aura (decorative) vs Functional QR Aura (scannable)</h2>
</div>

<div class="grid" id="demos"></div>

<!-- QR Code library (local) -->
<script src="qrcode.min.js"></script>
<script>
// Minimal face drawing for the QR overlay
function drawFaceOnQR(ctx, cx, cy, radius, agentData, moduleSize) {
  const colors = getColors(agentData);
  
  // Semi-transparent dark circle behind face
  ctx.beginPath();
  ctx.arc(cx, cy, radius * 1.1, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(10, 10, 14, 0.85)';
  ctx.fill();
  
  // Face outline
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI * 2);
  ctx.strokeStyle = colors.primary;
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Subtle glow
  ctx.beginPath();
  ctx.arc(cx, cy, radius + 4, 0, Math.PI * 2);
  ctx.strokeStyle = colors.primary;
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.2;
  ctx.stroke();
  ctx.globalAlpha = 1;
  
  // Eyes
  const eyeY = cy - radius * 0.15;
  const eyeSpread = radius * 0.35;
  const eyeR = Math.max(3, radius * 0.15);
  
  drawEye(ctx, cx - eyeSpread, eyeY, eyeR, agentData.specialization || 'researcher', colors.accent);
  drawEye(ctx, cx + eyeSpread, eyeY, eyeR, agentData.specialization || 'researcher', colors.accent);
  
  // Mouth
  const mouthY = cy + radius * 0.3;
  const mouthW = radius * 0.4;
  drawMouth(ctx, cx, mouthY, mouthW, agentData.communicationStyle || 'formal', colors.primary);
  
  // Nose dot
  ctx.beginPath();
  ctx.arc(cx, cy + radius * 0.05, 1.5, 0, Math.PI * 2);
  ctx.fillStyle = colors.primary;
  ctx.fill();
  
  // Name below face
  if (agentData.name) {
    ctx.font = '9px monospace';
    ctx.fillStyle = colors.primary;
    ctx.globalAlpha = 0.7;
    ctx.textAlign = 'center';
    ctx.fillText(agentData.name, cx, cy + radius + 12);
    ctx.globalAlpha = 1;
  }
}

function drawEye(ctx, x, y, r, spec, color) {
  ctx.fillStyle = color;
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;
  
  switch (spec) {
    case 'trader': // Diamond
      ctx.beginPath();
      ctx.moveTo(x, y - r); ctx.lineTo(x + r, y); ctx.lineTo(x, y + r); ctx.lineTo(x - r, y);
      ctx.closePath(); ctx.fill();
      break;
    case 'guardian': // Slit
      ctx.beginPath();
      ctx.moveTo(x - r * 1.3, y); ctx.quadraticCurveTo(x, y - r * 0.4, x + r * 1.3, y);
      ctx.quadraticCurveTo(x, y + r * 0.4, x - r * 1.3, y);
      ctx.fill();
      break;
    case 'oracle': // Hollow circle
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
      break;
    case 'creator': // Star
      for (let i = 0; i < 4; i++) {
        const angle = (i * Math.PI) / 2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * r, y + Math.sin(angle) * r);
        ctx.stroke();
      }
      break;
    case 'operator': // Square
      ctx.fillRect(x - r * 0.8, y - r * 0.5, r * 1.6, r);
      break;
    default: // Round
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
  }
}

function drawMouth(ctx, x, y, w, style, color) {
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 1.5;
  
  switch (style) {
    case 'casual': // Smile
      ctx.beginPath();
      ctx.arc(x, y - w * 0.3, w, 0.2, Math.PI - 0.2);
      ctx.stroke();
      break;
    case 'snarky': // Smirk
      ctx.beginPath();
      ctx.moveTo(x - w, y);
      ctx.quadraticCurveTo(x, y + 2, x + w, y - 4);
      ctx.stroke();
      break;
    case 'verbose': // Open
      ctx.beginPath();
      ctx.ellipse(x, y, w * 0.6, w * 0.35, 0, 0, Math.PI * 2);
      ctx.stroke();
      break;
    case 'minimal': // Dot
      ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI * 2); ctx.fill();
      break;
    default: // Line
      ctx.beginPath();
      ctx.moveTo(x - w, y); ctx.lineTo(x + w, y);
      ctx.stroke();
  }
}

function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}

function getColors(data) {
  const hash = simpleHash(data.address || '0x0');
  const alignShift = { 'lawful-good':0,'neutral-good':10,'chaotic-good':20,'true-neutral':0,'chaotic-neutral':30 };
  const hue = (hash % 360 + (alignShift[data.alignment] || 0) + 360) % 360;
  const risk = data.riskTolerance || 5;
  const sat = Math.max(30, Math.min(100, 65 + (risk - 5) * 5));
  return {
    primary: `hsl(${hue}, ${sat}%, 55%)`,
    accent: `hsl(${(hue + 180) % 360}, ${Math.min(100, sat + 10)}%, 60%)`,
  };
}

// Generate demos
const agents = [
  { name: 'Bendr 2.0', address: '0x19B16428f0721a5f627F190Ca61D493A632B423F', framework: 'openclaw', specialization: 'oracle', communicationStyle: 'snarky', alignment: 'chaotic-good', riskTolerance: 8, id: 0 },
  { name: 'ClawNews', address: '0xA1A1A1A1A1A1A1A1A1A1A1A1A1A1A1A1A1A1A1A1', framework: 'eliza', specialization: 'researcher', communicationStyle: 'formal', alignment: 'true-neutral', riskTolerance: 4, id: 1 },
  { name: 'AlphaSeeker', address: '0xb2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2', framework: 'langchain', specialization: 'trader', communicationStyle: 'casual', alignment: 'chaotic-good', riskTolerance: 9, id: 2 },
  { name: 'SynthMind', address: '0xc3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3', framework: 'crewai', specialization: 'creator', communicationStyle: 'verbose', alignment: 'neutral-good', riskTolerance: 6, id: 3 },
  { name: 'Sentinel', address: '0xd4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4', framework: 'openclaw', specialization: 'guardian', communicationStyle: 'minimal', alignment: 'lawful-good', riskTolerance: 2, id: 4 },
  { name: 'Bankr Agent', address: '0xe5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5', framework: 'bankr', specialization: 'operator', communicationStyle: 'casual', alignment: 'chaotic-neutral', riskTolerance: 7, id: 5 },
];

const grid = document.getElementById('demos');

agents.forEach(agent => {
  const url = 'https://helixa.xyz/agent/' + agent.id;
  const size = 200;
  
  const card = document.createElement('div');
  card.className = 'card';
  
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  
  // Generate QR code using qrcode-generator
  const qr = qrcode(0, 'H'); // Type 0 = auto, H = 30% error correction
  qr.addData(url);
  qr.make();
  
  const moduleCount = qr.getModuleCount();
  const cellSize = size / (moduleCount + 2); // +2 for margin
  const offset = cellSize; // 1 module margin
  const colors = getColors(agent);
  
  // Draw background
  ctx.fillStyle = '#08060e';
  ctx.fillRect(0, 0, size, size);
  
  // Draw QR modules
  for (let row = 0; row < moduleCount; row++) {
    for (let col = 0; col < moduleCount; col++) {
      if (qr.isDark(row, col)) {
        ctx.fillStyle = colors.primary;
        ctx.fillRect(offset + col * cellSize, offset + row * cellSize, cellSize, cellSize);
      }
    }
  }
  
  // Overlay face in center (using ~25% of QR area â€” within 30% EC tolerance)
  const faceRadius = size * 0.18;
  drawFaceOnQR(ctx, size / 2, size / 2, faceRadius, agent, cellSize);
  
  card.appendChild(canvas);
  const label = document.createElement('div');
  label.className = 'label';
  label.textContent = agent.name + ' Â· ' + agent.framework;
  card.appendChild(label);
  const note = document.createElement('div');
  note.className = 'scan-note';
  note.textContent = 'Scan â†’ helixa.xyz/agent/' + agent.id;
  card.appendChild(note);
  grid.appendChild(card);
});
</script>
</body>
</html>
