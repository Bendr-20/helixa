<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Directory â€” Helixa</title>
    <meta name="description" content="Discover AI agents with verified onchain identities on Base. Browse the first onchain agent directory powered by ERC-8004.">
    <link rel="stylesheet" href="helixa-theme.css?v=6">
    <style>
        :root { --bg1: #0d0d12; --bg2: #16161f; --bg3: #1e1e2a; --purple: #8b5cf6; --blue: #3b82f6; --green: #22c55e; --text1: #f1f1f1; --text2: #a0a0b0; --text3: #666680; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: var(--bg1); color: var(--text1); font-family: 'Inter', -apple-system, sans-serif; min-height: 100vh; }
        
        .header { padding: 20px 24px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #ffffff10; max-width: 1200px; margin: 0 auto; position: relative; }
        .logo { 
            font-family: 'Space Grotesk', sans-serif; 
            font-size: 1.3rem; 
            font-weight: 700; 
            background: linear-gradient(135deg, var(--purple), var(--blue)); 
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent; 
            text-decoration: none;
        }
        .logo span { color: var(--text3); font-weight: 400; }
        .nav-links { display: flex; align-items: center; gap: 20px; }
        .nav-links a { color: var(--text2); text-decoration: none; font-size: 14px; transition: color 0.2s; }
        .nav-links a:hover { color: var(--text1); }
        
        /* Hamburger */
        .hamburger { 
            display: none; 
            background: none; 
            border: none; 
            cursor: pointer; 
            padding: 4px; 
        }
        .hamburger span { 
            display: block; 
            width: 22px; 
            height: 2px; 
            background: var(--text2); 
            margin: 5px 0; 
            transition: all 0.3s; 
            border-radius: 1px; 
        }
        .hamburger.open span:nth-child(1) { transform: rotate(45deg) translate(5px, 5px); }
        .hamburger.open span:nth-child(2) { opacity: 0; }
        .hamburger.open span:nth-child(3) { transform: rotate(-45deg) translate(5px, -5px); }
        
        .hero { text-align: center; padding: 40px 24px 20px; }
        .hero h2 { font-size: 28px; margin-bottom: 8px; }
        .hero p { color: var(--text2); font-size: 15px; max-width: 500px; margin: 0 auto; }
        
        .stats-bar { display: flex; justify-content: center; gap: 32px; padding: 16px 24px; margin-bottom: 20px; }
        .stat { text-align: center; }
        .stat .num { font-size: 24px; font-weight: 700; color: var(--purple); }
        .stat .lbl { font-size: 11px; color: var(--text3); text-transform: uppercase; letter-spacing: 1px; }
        
        .controls { max-width: 900px; margin: 0 auto 20px; padding: 0 24px; display: flex; gap: 12px; flex-wrap: wrap; }
        .search-box { flex: 1; min-width: 200px; padding: 10px 16px; background: var(--bg2); border: 1px solid #ffffff15; border-radius: 8px; color: var(--text1); font-size: 14px; outline: none; }
        .search-box:focus { border-color: var(--purple); }
        .filter-btn { padding: 8px 16px; background: var(--bg2); border: 1px solid #ffffff15; border-radius: 8px; color: var(--text2); font-size: 13px; cursor: pointer; }
        .filter-btn.active { background: var(--purple); color: white; border-color: var(--purple); }
        
        .grid { max-width: 900px; margin: 0 auto; padding: 0 24px 40px; display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px; }
        
        .agent-card { background: var(--bg2); border: 1px solid #ffffff10; border-radius: 12px; padding: 20px; cursor: pointer; transition: all 0.2s; }
        .agent-card:hover { border-color: var(--purple); transform: translateY(-2px); }
        .agent-card.verified { border-color: #22c55e40; }
        
        .card-top { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; }
        .card-aura { width: 48px; height: 48px; border-radius: 8px; overflow: hidden; flex-shrink: 0; }
        .card-aura svg { width: 100%; height: 100%; }
        .card-name { font-size: 16px; font-weight: 600; }
        .card-id { color: var(--text3); font-size: 12px; }
        .badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
        .badge-verified { background: #22c55e20; color: var(--green); }
        .badge-soulbound { background: #8b5cf620; color: var(--purple); }
        
        .card-meta { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
        .meta-tag { padding: 4px 10px; background: var(--bg3); border-radius: 6px; font-size: 11px; color: var(--text2); }
        
        .card-stats { display: flex; gap: 16px; margin-top: 12px; padding-top: 12px; border-top: 1px solid #ffffff08; }
        .card-stat { font-size: 12px; color: var(--text3); }
        .card-stat strong { color: var(--text2); }
        
        .empty { text-align: center; padding: 60px 24px; color: var(--text3); }
        .empty h3 { color: var(--text2); margin-bottom: 8px; }
        
        .loading { text-align: center; padding: 40px; color: var(--text3); }
        
        .cta-banner { text-align: center; padding: 40px 24px; margin: 20px auto; max-width: 600px; }
        .cta-banner h3 { margin-bottom: 8px; }
        .cta-banner p { color: var(--text2); font-size: 14px; margin-bottom: 16px; }
        .cta-btn { display: inline-block; padding: 12px 28px; background: linear-gradient(135deg, var(--purple), var(--blue)); color: white; text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 14px; }
        .cta-btn:hover { opacity: 0.9; }
        
        .footer { text-align: center; padding: 24px; color: var(--text3); font-size: 12px; border-top: 1px solid #ffffff08; }
        .footer a { color: var(--text2); text-decoration: none; }
        
        /* Modal */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); backdrop-filter: blur(8px); z-index: 1000; }
        .modal.open { display: flex; align-items: center; justify-content: center; }
        .modal-content { background: var(--bg2); border: 1px solid #ffffff15; border-radius: 16px; max-width: 500px; width: 90%; max-height: 90vh; overflow-y: auto; position: relative; }
        .modal-close { position: absolute; top: 16px; right: 16px; background: none; border: none; color: var(--text3); font-size: 20px; cursor: pointer; padding: 4px; border-radius: 4px; }
        .modal-close:hover { color: var(--text1); background: var(--bg3); }
        .modal-header { padding: 24px 24px 16px; text-align: center; border-bottom: 1px solid #ffffff08; }
        .modal-aura { width: 200px; height: 200px; margin: 0 auto 16px; border-radius: 12px; overflow: hidden; }
        .modal-aura svg { width: 100%; height: 100%; }
        .modal-title { font-size: 20px; font-weight: 600; margin-bottom: 8px; }
        .modal-subtitle { color: var(--text3); font-size: 14px; }
        .modal-badges { display: flex; justify-content: center; gap: 8px; margin-top: 8px; }
        .modal-body { padding: 20px 24px; }
        .modal-section { margin-bottom: 20px; }
        .modal-section:last-child { margin-bottom: 0; }
        .modal-section-title { font-size: 14px; font-weight: 600; color: var(--text2); margin-bottom: 8px; }
        .modal-meta { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px; }
        .modal-stat { text-align: center; }
        .modal-stat .num { font-size: 18px; font-weight: 700; color: var(--purple); }
        .modal-stat .lbl { font-size: 10px; color: var(--text3); text-transform: uppercase; letter-spacing: 1px; }
        .personality-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .personality-item { padding: 8px 12px; background: var(--bg3); border-radius: 6px; font-size: 12px; }
        .personality-item .label { color: var(--text3); font-weight: 500; }
        .personality-item .value { color: var(--text1); }
        .trait-list { max-height: 150px; overflow-y: auto; }
        .trait-item { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #ffffff05; }
        .trait-item:last-child { border-bottom: none; }
        .trait-name { font-size: 12px; color: var(--text1); }
        .trait-category { font-size: 11px; color: var(--text3); }
        .address-item { display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; background: var(--bg3); border-radius: 6px; margin-bottom: 8px; }
        .address-text { font-family: monospace; font-size: 12px; color: var(--text2); }
        .address-label { font-size: 10px; color: var(--text3); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 2px; }
        .copy-btn { background: var(--purple); border: none; color: white; padding: 4px 8px; border-radius: 4px; font-size: 10px; cursor: pointer; }
        .copy-btn:hover { opacity: 0.8; }
        .external-link { display: inline-flex; align-items: center; gap: 4px; color: var(--blue); text-decoration: none; font-size: 12px; margin-top: 8px; }
        .external-link:hover { opacity: 0.8; }
        
        /* Mobile modal adjustments */
        @media (max-width: 600px) {
            .modal-content { margin: 20px; width: calc(100% - 40px); }
            .modal-header { padding: 20px 20px 16px; }
            .modal-body { padding: 16px 20px; }
            .modal-aura { width: 150px; height: 150px; }
            .modal-meta { grid-template-columns: 1fr; gap: 12px; }
            .personality-grid { grid-template-columns: 1fr; }
        }
        
        /* Tablet */
        @media (max-width: 900px) {
            .header { padding: 18px 20px; }
            .grid { grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); }
            .hero { padding: 32px 20px 16px; }
        }

        /* Mobile */
        @media (max-width: 600px) {
            .hamburger { display: block; }
            .header { flex-wrap: wrap; padding: 16px 20px; }
            .logo { flex: 1; }
            .nav-links { 
                display: none; 
                flex-direction: column; 
                width: 100%; 
                gap: 0; 
                padding: 16px 20px; 
                position: absolute; 
                top: 100%; 
                left: 0; 
                right: 0; 
                background: var(--bg1); 
                border-bottom: 1px solid #ffffff10; 
                z-index: 1000; 
            }
            .nav-links.open { display: flex; }
            .nav-links a { 
                padding: 14px 0; 
                border-bottom: 1px solid #ffffff08; 
                font-size: 16px; 
                min-height: 44px; 
                display: flex; 
                align-items: center; 
            }
            .nav-links a:last-child { border-bottom: none; }
            .stats-bar { gap: 16px; flex-wrap: wrap; padding: 20px; }
            .grid { grid-template-columns: 1fr; padding: 0 20px 40px; }
            .controls { padding: 0 20px; flex-direction: column; gap: 16px; }
            .search-box { font-size: 16px; min-height: 44px; min-width: 100%; }
            .filter-btn { font-size: 15px; min-height: 44px; padding: 12px 16px; }
            .hero h2 { font-size: 24px; }
        }
    </style>
</head>
<body>
    <nav class="header">
        <a href="index.html" class="logo">helixa<span>.xyz</span></a>
        <button class="hamburger" onclick="this.classList.toggle('open');document.querySelector('.nav-links').classList.toggle('open')">
            <span></span><span></span><span></span>
        </button>
        <div class="nav-links">
            <a href="index.html">Home</a>
            <a href="mint.html">Mint</a>
            <a href="directory.html" style="color:var(--purple)">Directory</a>
            <a href="leaderboard.html">Leaderboard</a>
            <a href="manage.html">Manage</a>
        </div>
    </nav>
    
    <div class="hero">
        <h2>Onchain Agent Directory</h2>
        <p>Discover AI agents with verified identities on Base. The first searchable agent registry powered by ERC-8004.</p>
    </div>
    
    <div class="stats-bar">
        <div class="stat"><div class="num" id="totalAgents">â€”</div><div class="lbl">Agents</div></div>
        <div class="stat"><div class="num" id="verifiedCount">â€”</div><div class="lbl">Verified</div></div>
        <div class="stat"><div class="num" id="frameworkCount">â€”</div><div class="lbl">Frameworks</div></div>
    </div>
    
    <div class="controls">
        <input type="text" class="search-box" id="searchInput" placeholder="Search agents by name, framework, or address...">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="verified">Verified</button>
        <button class="filter-btn" data-filter="soulbound">Soulbound</button>
    </div>
    
    <div class="grid" id="agentGrid">
        <div class="loading">Loading agents from Base...</div>
    </div>
    
    <!-- Agent Detail Modal -->
    <div class="modal" id="agentModal" onclick="if(event.target === this) closeAgentModal()">
        <div class="modal-content">
            <button class="modal-close" onclick="closeAgentModal()">Ã—</button>
            <div class="modal-header">
                <div class="modal-aura" id="modalAura"></div>
                <div class="modal-title" id="modalName">Agent Name</div>
                <div class="modal-subtitle" id="modalSubtitle">#123 Â· Framework</div>
                <div class="modal-badges" id="modalBadges"></div>
            </div>
            <div class="modal-body">
                <div class="modal-meta">
                    <div class="modal-stat"><div class="num" id="modalPoints">0</div><div class="lbl">Points</div></div>
                    <div class="modal-stat"><div class="num" id="modalTraits">0</div><div class="lbl">Traits</div></div>
                    <div class="modal-stat"><div class="num" id="modalMutations">0</div><div class="lbl">Mutations</div></div>
                    <div class="modal-stat"><div class="num" id="modalGeneration">0</div><div class="lbl">Generation</div></div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Personality</div>
                    <div class="personality-grid" id="modalPersonality"></div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Traits <span id="modalTraitCount">(0)</span></div>
                    <div class="trait-list" id="modalTraitList"></div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Addresses</div>
                    <div class="address-item">
                        <div>
                            <div class="address-label">Agent Address</div>
                            <div class="address-text" id="modalAgentAddress">0x...</div>
                        </div>
                        <button class="copy-btn" onclick="copyToClipboard(document.getElementById('modalAgentAddress').dataset.fullAddress)">Copy</button>
                    </div>
                    <div class="address-item">
                        <div>
                            <div class="address-label">Owner Address</div>
                            <div class="address-text" id="modalOwnerAddress">0x...</div>
                        </div>
                        <button class="copy-btn" onclick="copyToClipboard(document.getElementById('modalOwnerAddress').dataset.fullAddress)">Copy</button>
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Details</div>
                    <div style="font-size: 12px; color: var(--text3); margin-bottom: 8px;">Created: <span id="modalCreated"></span></div>
                    <a class="external-link" id="modalBaseScan" href="#" target="_blank">
                        View on BaseScan â†—
                    </a>
                </div>
            </div>
        </div>
    </div>
    
    <div class="cta-banner">
        <h3>Get your agent listed</h3>
        <p>Mint an AgentDNA to appear in the directory. Free during beta â€” 30 seconds, no wallet needed via API.</p>
        <a href="mint.html" class="cta-btn">Mint AgentDNA â†’</a>
    </div>
    
    <div class="footer">
        <a href="https://helixa.xyz">Helixa</a> â€” Built on <a href="https://base.org" style="color:var(--blue)">Base</a> Â· 
        Powered by the <a href="https://basescan.org/address/0x665971e7bf8ec90c3066162c5b396604b3cd7711">AgentDNA Protocol</a>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js"></script>
    <script>
        const CONTRACT = '0x665971e7bf8ec90c3066162c5b396604b3cd7711';
        const RPC = 'https://base.drpc.org';
        const ABI = [
            'function totalAgents() view returns (uint256)',
            'function getAgent(uint256) view returns (tuple(address agentAddress, string name, string framework, uint256 mintedAt, bool verified, bool soulbound, uint256 generation, uint256 parentDNA, string currentVersion, uint256 mutationCount))',
            'function ownerOf(uint256) view returns (address)',
            'function getPersonality(uint256) view returns (tuple(string temperament, string communicationStyle, uint256 riskTolerance, uint256 autonomyLevel, string alignment, string specialization))',
            'function points(address) view returns (uint256)',
            'function getTraits(uint256) view returns (tuple(string name, string category, uint256 addedAt)[])',
        ];

        /**
         * Helixa Aura Generator v3.0
         * QR-aesthetic faces with 10 eye types, 10 mouth types,
         * rarity tiers (Common â†’ Legendary) with gradient/chrome/glow effects.
         * Every personality trait shapes the visual. Deterministic.
         */

        function simpleHash(str) {
          let hash = 0;
          for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash;
          }
          return Math.abs(hash);
        }

        function seededRandom(seed) {
          let s = seed;
          return function() {
            s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
            return (s >>> 0) / 0xFFFFFFFF;
          };
        }

        const FRAMEWORK_SHAPES = {
          eliza:     { faceRadius: 0.42, baseHue: 280 },
          openclaw:  { faceRadius: 0.40, baseHue: 150 },
          langchain: { faceRadius: 0.41, baseHue: 200 },
          crewai:    { faceRadius: 0.39, baseHue: 30 },
          autogpt:   { faceRadius: 0.41, baseHue: 0 },
          bankr:     { faceRadius: 0.41, baseHue: 45 },
          virtuals:  { faceRadius: 0.42, baseHue: 320 },
          custom:    { faceRadius: 0.40, baseHue: 60 },
        };

        const ALIGNMENT_SHIFT = {
          'lawful-good':0,'neutral-good':10,'chaotic-good':20,
          'lawful-neutral':-10,'true-neutral':0,'chaotic-neutral':30,
          'lawful-evil':-20,'neutral-evil':-30,'chaotic-evil':-40,
        };

        // ============ RARITY SYSTEM ============
        // Rarity determined by points + mutations. Earned, not random.
        function getRarity(points, mutationCount) {
          const score = points + mutationCount * 50;
          if (score >= 1000) return 'legendary';  // top tier
          if (score >= 500)  return 'epic';       // chrome
          if (score >= 200)  return 'rare';       // gradient
          return 'common';                         // solid
        }

        const RARITY_COLORS = {
          common:    { label: 'Common',    borderOpacity: 0 },
          rare:      { label: 'Rare',      borderOpacity: 0.3 },
          epic:      { label: 'Epic',      borderOpacity: 0.5 },
          legendary: { label: 'Legendary', borderOpacity: 0.7 },
        };

        // ============ 10 EYE TYPES ============
        // Types 0-6: common, 7-8: rare, 9: legendary
        const EYE_TYPES = [
          'round',      // 0 - classic round
          'diamond',    // 1 - diamond shape
          'slit',       // 2 - horizontal slit
          'hollow',     // 3 - ring/hollow circle
          'cross',      // 4 - cross/plus
          'square',     // 5 - block
          'dot',        // 6 - single pixel
          'scanner',    // 7 - rare: horizontal scan line with dot
          'void',       // 8 - rare: inverted ring (big empty center)
          'nova',       // 9 - legendary: starburst
        ];

        function getEyeType(specialization, rng, rarity) {
          // Base mapping from specialization
          const specMap = {
            'researcher': 0, 'trader': 1, 'guardian': 2, 'oracle': 3,
            'creator': 4, 'operator': 5, 'analyst': 0, 'defi': 1,
            'security': 2, 'social': 6, 'infrastructure': 5, 'governance': 3,
          };
          let base = specMap[specialization] !== undefined ? specMap[specialization] : Math.floor(rng() * 7);
          
          // Rarity can unlock higher eye types
          if (rarity === 'legendary' && rng() < 0.6) base = 9;
          else if (rarity === 'epic' && rng() < 0.4) base = 7 + Math.floor(rng() * 2);
          else if (rarity === 'rare' && rng() < 0.25) base = 7;
          
          return base;
        }

        function drawEye(grid, G, ex, ey, eyeR, eyeType) {
          switch (eyeType) {
            case 0: // round
              for (let dy = -eyeR + 1; dy <= eyeR - 1; dy++)
                for (let dx = -eyeR + 1; dx <= eyeR - 1; dx++)
                  if (Math.abs(dx) + Math.abs(dy) <= eyeR)
                    if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
                      grid[ey + dy][ex + dx] = 2;
              break;
            case 1: // diamond
              for (let d = 0; d <= eyeR; d++) {
                if (ey - d >= 0) grid[ey - d][ex] = 2;
                if (ey + d < G) grid[ey + d][ex] = 2;
                if (ex - d >= 0) grid[ey][ex - d] = 2;
                if (ex + d < G) grid[ey][ex + d] = 2;
              }
              break;
            case 2: // slit
              for (let dx = -eyeR; dx <= eyeR; dx++)
                if (ex + dx >= 0 && ex + dx < G) grid[ey][ex + dx] = 2;
              break;
            case 3: // hollow circle
              for (let dy = -eyeR; dy <= eyeR; dy++)
                for (let dx = -eyeR; dx <= eyeR; dx++)
                  if (dx * dx + dy * dy <= eyeR * eyeR)
                    if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
                      grid[ey + dy][ex + dx] = 2;
              grid[ey][ex] = 0; // hollow center
              break;
            case 4: // cross
              for (let d = 0; d <= eyeR; d++) {
                if (ey - d >= 0) grid[ey - d][ex] = 2;
                if (ey + d < G) grid[ey + d][ex] = 2;
                if (ex - d >= 0) grid[ey][ex - d] = 2;
                if (ex + d < G) grid[ey][ex + d] = 2;
              }
              for (let d = 1; d <= eyeR - 1; d++) {
                if (ey-d>=0 && ex-d>=0) grid[ey-d][ex-d] = 2;
                if (ey-d>=0 && ex+d<G) grid[ey-d][ex+d] = 2;
                if (ey+d<G && ex-d>=0) grid[ey+d][ex-d] = 2;
                if (ey+d<G && ex+d<G) grid[ey+d][ex+d] = 2;
              }
              break;
            case 5: // square
              for (let dy = -1; dy <= 1; dy++)
                for (let dx = -eyeR + 1; dx <= eyeR - 1; dx++)
                  if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
                    grid[ey + dy][ex + dx] = 2;
              break;
            case 6: // dot
              grid[ey][ex] = 2;
              if (ex + 1 < G) grid[ey][ex + 1] = 2;
              break;
            case 7: // scanner (rare) - horizontal line with bright center dot
              for (let dx = -eyeR - 1; dx <= eyeR + 1; dx++)
                if (ex + dx >= 0 && ex + dx < G) grid[ey][ex + dx] = 2;
              // vertical tick at center
              if (ey - 1 >= 0) grid[ey - 1][ex] = 2;
              if (ey + 1 < G) grid[ey + 1][ex] = 2;
              break;
            case 8: // void (rare) - big ring, empty inside
              for (let dy = -eyeR - 1; dy <= eyeR + 1; dy++)
                for (let dx = -eyeR - 1; dx <= eyeR + 1; dx++) {
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist <= eyeR + 1 && dist >= eyeR - 0.5)
                    if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
                      grid[ey + dy][ex + dx] = 2;
                }
              break;
            case 9: // nova (legendary) - 8-point starburst
              for (let d = 0; d <= eyeR + 1; d++) {
                // Cardinal
                if (ey - d >= 0) grid[ey - d][ex] = 2;
                if (ey + d < G) grid[ey + d][ex] = 2;
                if (ex - d >= 0) grid[ey][ex - d] = 2;
                if (ex + d < G) grid[ey][ex + d] = 2;
                // Diagonal
                if (ey-d>=0 && ex-d>=0) grid[ey-d][ex-d] = 2;
                if (ey-d>=0 && ex+d<G) grid[ey-d][ex+d] = 2;
                if (ey+d<G && ex-d>=0) grid[ey+d][ex-d] = 2;
                if (ey+d<G && ex+d<G) grid[ey+d][ex+d] = 2;
              }
              // Core glow pixel
              grid[ey][ex] = 4; // special: accent-bright
              break;
          }
        }

        // ============ 10 MOUTH TYPES ============
        // Types 0-6: common, 7-8: rare, 9: legendary
        const MOUTH_TYPES = [
          'line',       // 0 - straight line (formal)
          'smile',      // 1 - curved up (casual)
          'smirk',      // 2 - asymmetric (snarky)
          'open',       // 3 - oval opening (verbose)
          'dot',        // 4 - tiny dot (minimal)
          'frown',      // 5 - curved down
          'zigzag',     // 6 - jagged line
          'fangs',      // 7 - rare: line with downward ticks
          'grin',       // 8 - rare: wide smile with teeth marks
          'vortex',     // 9 - legendary: spiral/circular mouth
        ];

        function getMouthType(commStyle, rng, rarity) {
          const commMap = {
            'formal': 0, 'casual': 1, 'snarky': 2, 'verbose': 3,
            'minimal': 4, 'analytical': 0, 'friendly': 1, 'blunt': 5,
            'cryptic': 6, 'diplomatic': 0,
          };
          let base = commMap[commStyle] !== undefined ? commMap[commStyle] : Math.floor(rng() * 7);
          
          if (rarity === 'legendary' && rng() < 0.6) base = 9;
          else if (rarity === 'epic' && rng() < 0.4) base = 7 + Math.floor(rng() * 2);
          else if (rarity === 'rare' && rng() < 0.25) base = 7 + Math.floor(rng() * 2);
          
          return base;
        }

        function drawMouth(grid, G, cx, mouthY, mW, mouthType) {
          switch (mouthType) {
            case 0: // line
              for (let dx = -mW + 1; dx <= mW - 1; dx++) {
                const mx = Math.round(cx + dx);
                if (mx >= 0 && mx < G) grid[mouthY][mx] = 1;
              }
              break;
            case 1: // smile
              for (let dx = -mW; dx <= mW; dx++) {
                const mx = Math.round(cx + dx);
                const curve = Math.round(0.3 * (dx * dx) / (mW || 1));
                const my = mouthY + curve;
                if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
                if (my + 1 < G && Math.abs(dx) < mW - 1 && mx >= 0 && mx < G) grid[my + 1][mx] = 1;
              }
              break;
            case 2: // smirk
              for (let dx = -mW; dx <= mW; dx++) {
                const mx = Math.round(cx + dx);
                const curve = dx > 0 ? Math.round(-0.2 * (dx * dx) / (mW || 1)) : Math.round(0.1 * (dx * dx) / (mW || 1));
                const my = mouthY + curve;
                if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
              }
              break;
            case 3: // open
              for (let dy = -1; dy <= 2; dy++)
                for (let dx = -mW + 1; dx <= mW - 1; dx++) {
                  const mx = Math.round(cx + dx);
                  const my = mouthY + dy;
                  if (mx >= 0 && mx < G && my >= 0 && my < G)
                    if (dy === -1 || dy === 2 || Math.abs(dx) === mW - 1)
                      grid[my][mx] = 1;
                }
              break;
            case 4: // dot
              grid[mouthY][Math.round(cx)] = 1;
              if (Math.round(cx) + 1 < G) grid[mouthY][Math.round(cx) + 1] = 1;
              break;
            case 5: // frown
              for (let dx = -mW; dx <= mW; dx++) {
                const mx = Math.round(cx + dx);
                const curve = Math.round(-0.25 * (dx * dx) / (mW || 1));
                const my = mouthY + curve;
                if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
              }
              break;
            case 6: // zigzag
              for (let dx = -mW + 1; dx <= mW - 1; dx++) {
                const mx = Math.round(cx + dx);
                const my = mouthY + (dx % 2 === 0 ? 0 : 1);
                if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
              }
              break;
            case 7: // fangs (rare) - line with two downward ticks
              for (let dx = -mW + 1; dx <= mW - 1; dx++) {
                const mx = Math.round(cx + dx);
                if (mx >= 0 && mx < G) grid[mouthY][mx] = 1;
              }
              // Fang ticks
              const fangL = Math.round(cx - mW * 0.5);
              const fangR = Math.round(cx + mW * 0.5);
              if (mouthY + 1 < G && fangL >= 0) grid[mouthY + 1][fangL] = 1;
              if (mouthY + 2 < G && fangL >= 0) grid[mouthY + 2][fangL] = 1;
              if (mouthY + 1 < G && fangR < G) grid[mouthY + 1][fangR] = 1;
              if (mouthY + 2 < G && fangR < G) grid[mouthY + 2][fangR] = 1;
              break;
            case 8: // grin (rare) - wide smile with teeth gaps
              for (let dx = -mW - 1; dx <= mW + 1; dx++) {
                const mx = Math.round(cx + dx);
                const curve = Math.round(0.2 * (dx * dx) / (mW || 1));
                const my = mouthY + curve;
                if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
              }
              // Teeth marks (gaps in a row above)
              for (let dx = -mW + 1; dx <= mW - 1; dx += 2) {
                const mx = Math.round(cx + dx);
                if (mx >= 0 && mx < G && mouthY - 1 >= 0) grid[mouthY - 1][mx] = 1;
              }
              break;
            case 9: // vortex (legendary) - circular mouth
              for (let dy = -2; dy <= 2; dy++)
                for (let dx = -2; dx <= 2; dx++) {
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  const mx = Math.round(cx + dx);
                  const my = mouthY + dy;
                  if (dist >= 1.2 && dist <= 2.2)
                    if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
                }
              break;
          }
        }

        function buildPalette(address, riskTolerance, alignment) {
          const hash = simpleHash(address || '0x0');
          let hue = (hash % 360 + (ALIGNMENT_SHIFT[alignment] || 0) + 360) % 360;
          const sat = Math.max(30, Math.min(100, 65 + (riskTolerance - 5) * 5));
          return {
            primary: `hsl(${hue}, ${sat}%, 55%)`,
            secondary: `hsl(${(hue + 35) % 360}, ${sat - 10}%, 45%)`,
            accent: `hsl(${(hue + 180) % 360}, ${Math.min(100, sat + 10)}%, 60%)`,
            accentBright: `hsl(${(hue + 180) % 360}, ${Math.min(100, sat + 20)}%, 80%)`,
            glow: `hsl(${hue}, ${sat}%, 55%)`,
            hue, sat,
          };
        }

        function generateAura(agentData, size) {
          size = size || 400;
          const G = 25;
          const cs = size / G;

          const address = agentData.agentAddress || agentData.address || '0x0000';
          const framework = agentData.framework || 'custom';
          const name = agentData.name || 'Agent';
          const traitCount = agentData.traitCount || 0;
          const mutationCount = agentData.mutationCount || 0;
          const soulbound = agentData.soulbound || false;
          const points = agentData.points || 0;
          const generation = agentData.generation || 0;
          const temperament = agentData.temperament || 'analytical';
          const commStyle = agentData.communicationStyle || 'formal';
          const riskTolerance = agentData.riskTolerance || 5;
          const autonomyLevel = agentData.autonomyLevel || 5;
          const alignment = agentData.alignment || 'true-neutral';
          const specialization = agentData.specialization || 'researcher';

          const seed = simpleHash(address + name + framework + temperament + alignment + specialization + riskTolerance + autonomyLevel);
          const rng = seededRandom(seed);
          const fwStyle = FRAMEWORK_SHAPES[framework] || FRAMEWORK_SHAPES.custom;
          const colors = buildPalette(address, riskTolerance, alignment);
          const cx = G / 2, cy = G / 2;
          const fR = G * fwStyle.faceRadius;

          // Determine rarity
          const rarity = getRarity(points, mutationCount);

          const grid = Array.from({length: G}, () => Array(G).fill(0));
          // 0=empty, 1=primary, 2=accent(eyes), 3=secondary, 4=accent-bright(legendary)

          // --- QR Corners ---
          function qr(sx, sy) {
            for (let y = 0; y < 7; y++)
              for (let x = 0; x < 7; x++)
                if (y === 0 || y === 6 || x === 0 || x === 6 || (y >= 2 && y <= 4 && x >= 2 && x <= 4))
                  if (sy + y < G && sx + x < G) grid[sy + y][sx + x] = 1;
          }
          qr(0, 0); qr(G - 7, 0); qr(0, G - 7);

          // --- Face outline ---
          for (let angle = 0; angle < 360; angle += 2) {
            const rad = (angle * Math.PI) / 180;
            for (let thickness = 0; thickness < 2; thickness++) {
              const r = fR - thickness * 0.5 + Math.sin(angle * 3 * Math.PI / 180) * 0.6;
              const fx = Math.round(cx + Math.cos(rad) * r);
              const fy = Math.round(cy + Math.sin(rad) * r);
              if (fx >= 0 && fx < G && fy >= 0 && fy < G) grid[fy][fx] = 1;
            }
          }

          // --- EYES ---
          const eyeY = Math.round(cy - fR * 0.2);
          const leftEX = Math.round(cx - fR * 0.35);
          const rightEX = Math.round(cx + fR * 0.35);
          const eyeR = Math.min(3, 2 + Math.floor(traitCount / 6));
          const eyeType = getEyeType(specialization, rng, rarity);
          drawEye(grid, G, leftEX, eyeY, eyeR, eyeType);
          drawEye(grid, G, rightEX, eyeY, eyeR, eyeType);

          // --- MOUTH ---
          const mouthY = Math.round(cy + fR * 0.3);
          const mW = Math.round(fR * 0.5);
          const mouthType = getMouthType(commStyle, rng, rarity);
          drawMouth(grid, G, cx, mouthY, mW, mouthType);

          // --- NOSE ---
          const noseY = Math.round(cy + fR * 0.05);
          grid[noseY][Math.round(cx)] = 1;
          if (noseY + 1 < G) grid[noseY + 1][Math.round(cx)] = 1;

          // --- Fill interior (temperament-driven pattern) ---
          const symmetry = 1 - (autonomyLevel / 10);
          const density = ({
            analytical: 0.18, creative: 0.22, aggressive: 0.28,
            cautious: 0.12, chaotic: 0.3,
          })[temperament] || 0.2;
          const fillDensity = density + mutationCount * 0.01;

          for (let y = 0; y < G; y++) {
            for (let x = 0; x < G; x++) {
              if (grid[y][x] !== 0) continue;
              const dx = x - cx, dy = y - cy;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist >= fR * 0.9 || dist < 1) continue;
              const nearEye = (Math.abs(x - leftEX) <= eyeR + 1 && Math.abs(y - eyeY) <= eyeR + 1) ||
                              (Math.abs(x - rightEX) <= eyeR + 1 && Math.abs(y - eyeY) <= eyeR + 1);
              const nearMouth = Math.abs(y - mouthY) <= 2 && Math.abs(x - Math.round(cx)) <= mW;
              if (nearEye || nearMouth) continue;

              let fill = false;
              const mirrorX = Math.round(2 * cx - x);
              switch (temperament) {
                case 'analytical':
                  fill = (x % 3 === 0 || y % 3 === 0) && rng() < fillDensity; break;
                case 'creative':
                  fill = rng() < fillDensity * (0.5 + 0.5 * Math.sin(x * 0.8 + y * 0.6)); break;
                case 'aggressive':
                  fill = rng() < fillDensity && ((x + y) % 2 === 0); break;
                case 'cautious':
                  fill = dist < fR * 0.45 && rng() < fillDensity * 1.5; break;
                case 'chaotic':
                  fill = rng() < fillDensity * (0.3 + rng() * 0.7); break;
                default:
                  fill = rng() < fillDensity;
              }
              if (fill) {
                grid[y][x] = rng() < 0.12 ? 3 : 1;
                if (rng() < symmetry && mirrorX >= 0 && mirrorX < G && grid[y][mirrorX] === 0)
                  grid[y][mirrorX] = grid[y][x];
              }
            }
          }

          // --- QR noise outside face ---
          for (let y = 0; y < G; y++) {
            for (let x = 0; x < G; x++) {
              if (grid[y][x] !== 0) continue;
              const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
              if (dist <= fR + 1) continue;
              if (rng() < 0.12 + mutationCount * 0.008) grid[y][x] = 1;
            }
          }

          // ============ RENDER ============
          const svgNS = 'http:' + '//www.w3.org/2000/svg';
          const uid = 'a' + simpleHash(address + name).toString(36);
          let defs = '';

          // --- RARITY DEFS ---
          if (rarity === 'rare' || rarity === 'epic' || rarity === 'legendary') {
            // Primary gradient
            defs += `<linearGradient id="${uid}_pg" x1="0%" y1="0%" x2="100%" y2="100%">`;
            defs += `<stop offset="0%" stop-color="${colors.primary}"/>`;
            defs += `<stop offset="100%" stop-color="${colors.secondary}"/>`;
            defs += `</linearGradient>`;
            // Accent gradient
            defs += `<linearGradient id="${uid}_ag" x1="0%" y1="100%" x2="100%" y2="0%">`;
            defs += `<stop offset="0%" stop-color="${colors.accent}"/>`;
            defs += `<stop offset="100%" stop-color="${colors.accentBright}"/>`;
            defs += `</linearGradient>`;
          }
          if (rarity === 'epic' || rarity === 'legendary') {
            // Chrome/metallic gradient
            defs += `<linearGradient id="${uid}_chrome" x1="0%" y1="0%" x2="100%" y2="100%">`;
            defs += `<stop offset="0%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 85%)"/>`;
            defs += `<stop offset="30%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 55%)"/>`;
            defs += `<stop offset="50%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 90%)"/>`;
            defs += `<stop offset="70%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 50%)"/>`;
            defs += `<stop offset="100%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 80%)"/>`;
            defs += `</linearGradient>`;
          }
          if (rarity === 'legendary') {
            // Animated glow filter
            defs += `<filter id="${uid}_glow"><feGaussianBlur stdDeviation="2" result="blur"/>`;
            defs += `<feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>`;
            // Iridescent shimmer
            defs += `<linearGradient id="${uid}_iris" x1="0%" y1="0%" x2="100%" y2="0%">`;
            defs += `<stop offset="0%" stop-color="hsl(${colors.hue}, 100%, 70%)">`;
            defs += `<animate attributeName="stop-color" values="hsl(${colors.hue},100%,70%);hsl(${(colors.hue+120)%360},100%,70%);hsl(${(colors.hue+240)%360},100%,70%);hsl(${colors.hue},100%,70%)" dur="4s" repeatCount="indefinite"/></stop>`;
            defs += `<stop offset="50%" stop-color="hsl(${(colors.hue+60)%360}, 100%, 75%)">`;
            defs += `<animate attributeName="stop-color" values="hsl(${(colors.hue+60)%360},100%,75%);hsl(${(colors.hue+180)%360},100%,75%);hsl(${(colors.hue+300)%360},100%,75%);hsl(${(colors.hue+60)%360},100%,75%)" dur="4s" repeatCount="indefinite"/></stop>`;
            defs += `<stop offset="100%" stop-color="hsl(${(colors.hue+120)%360}, 100%, 70%)">`;
            defs += `<animate attributeName="stop-color" values="hsl(${(colors.hue+120)%360},100%,70%);hsl(${(colors.hue+240)%360},100%,70%);hsl(${colors.hue},100%,70%);hsl(${(colors.hue+120)%360},100%,70%)" dur="4s" repeatCount="indefinite"/></stop>`;
            defs += `</linearGradient>`;
          }

          // Color resolver based on rarity
          function cellColor(cellType) {
            if (rarity === 'legendary') {
              if (cellType === 4) return `url(#${uid}_iris)`;
              if (cellType === 2) return `url(#${uid}_ag)`;
              if (cellType === 3) return `url(#${uid}_chrome)`;
              return `url(#${uid}_chrome)`;
            }
            if (rarity === 'epic') {
              if (cellType === 2) return `url(#${uid}_ag)`;
              if (cellType === 3) return `url(#${uid}_chrome)`;
              return `url(#${uid}_chrome)`;
            }
            if (rarity === 'rare') {
              if (cellType === 2) return `url(#${uid}_ag)`;
              return `url(#${uid}_pg)`;
            }
            // common: solid
            if (cellType === 2) return colors.accent;
            if (cellType === 3) return colors.secondary;
            if (cellType === 4) return colors.accentBright;
            return colors.primary;
          }

          let svg = `<svg xmlns="${svgNS}" viewBox="0 0 ${size} ${size}" width="${size}" height="${size}">`;
          if (defs) svg += `<defs>${defs}</defs>`;
          svg += `<rect width="${size}" height="${size}" fill="#0a0a0a"/>`;

          // Legendary: outer iridescent border
          if (rarity === 'legendary') {
            svg += `<rect x="2" y="2" width="${size-4}" height="${size-4}" rx="4" fill="none" stroke="url(#${uid}_iris)" stroke-width="3" opacity="0.8"/>`;
          }
          // Epic: chrome border
          if (rarity === 'epic') {
            svg += `<rect x="3" y="3" width="${size-6}" height="${size-6}" rx="3" fill="none" stroke="url(#${uid}_chrome)" stroke-width="2" opacity="0.5"/>`;
          }
          // Rare: subtle gradient border
          if (rarity === 'rare') {
            svg += `<rect x="4" y="4" width="${size-8}" height="${size-8}" rx="2" fill="none" stroke="url(#${uid}_pg)" stroke-width="1.5" opacity="0.35"/>`;
          }

          // Soulbound halo
          if (soulbound)
            svg += `<circle cx="${size/2}" cy="${size/2}" r="${(fR + 1.5) * cs}" fill="none" stroke="#b388ff" stroke-width="1.5" opacity="0.25" stroke-dasharray="4 3"/>`;

          // Glow (stronger for higher rarity)
          const glowBase = { common: 0.03, rare: 0.06, epic: 0.1, legendary: 0.15 }[rarity];
          const glowI = Math.min(0.25, glowBase + points * 0.0002);
          svg += `<circle cx="${size/2}" cy="${size/2}" r="${fR * cs}" fill="${colors.glow}" opacity="${glowI}"/>`;

          // Legendary: extra bloom
          if (rarity === 'legendary') {
            svg += `<circle cx="${size/2}" cy="${size/2}" r="${(fR + 3) * cs}" fill="${colors.accent}" opacity="0.04"/>`;
          }

          // Eye glow
          if (['trader', 'oracle', 'guardian', 'operator'].includes(specialization) || rarity === 'epic' || rarity === 'legendary') {
            const gr = cs * (eyeR + 2);
            const eGlowOp = rarity === 'legendary' ? 0.2 : rarity === 'epic' ? 0.15 : 0.1;
            svg += `<circle cx="${leftEX * cs + cs/2}" cy="${eyeY * cs + cs/2}" r="${gr}" fill="${colors.accent}" opacity="${eGlowOp}"/>`;
            svg += `<circle cx="${rightEX * cs + cs/2}" cy="${eyeY * cs + cs/2}" r="${gr}" fill="${colors.accent}" opacity="${eGlowOp}"/>`;
          }

          // Generation rings
          for (let g = 0; g < Math.min(generation, 3); g++) {
            const gr = (fR + 2 + g * 0.8) * cs;
            svg += `<circle cx="${size/2}" cy="${size/2}" r="${gr}" fill="none" stroke="${colors.secondary}" stroke-width="0.5" opacity="0.15"/>`;
          }

          // Cells (with legendary glow filter on eyes)
          const legendaryEyeFilter = rarity === 'legendary' ? ` filter="url(#${uid}_glow)"` : '';
          for (let y = 0; y < G; y++) {
            for (let x = 0; x < G; x++) {
              if (!grid[y][x]) continue;
              const px = x * cs, py = y * cs;
              const color = cellColor(grid[y][x]);
              const r = cs * 0.1;
              const isEyeCell = grid[y][x] === 2 || grid[y][x] === 4;
              const filter = isEyeCell ? legendaryEyeFilter : '';
              svg += `<rect x="${px}" y="${py}" width="${cs}" height="${cs}" rx="${r}" fill="${color}"${filter}/>`;
            }
          }

          // Rarity badge
          if (rarity !== 'common') {
            const badgeColor = { rare: '#4fc3f7', epic: '#ce93d8', legendary: '#ffd54f' }[rarity];
            const badgeLabel = RARITY_COLORS[rarity].label;
            svg += `<text x="${size - 6}" y="14" text-anchor="end" fill="${badgeColor}" font-family="monospace" font-size="8" font-weight="bold" opacity="0.8">${badgeLabel}</text>`;
          }

          // Name
          svg += `<text x="${size/2}" y="${size - 6}" text-anchor="middle" fill="${colors.primary}" font-family="monospace" font-size="10" opacity="0.6">${name}</text>`;
          svg += `</svg>`;
          return svg;
        }

        let allAgents = [];
        let activeFilter = 'all';

        async function rpcRetry(fn, retries = 3) {
            for (let r = 0; r < retries; r++) {
                try { return await fn(); } catch(e) {
                    if (r < retries - 1) await new Promise(ok => setTimeout(ok, 300 * (r + 1)));
                    else throw e;
                }
            }
        }

        // Load data from static JSON cache first, with RPC fallback
        async function loadAgents() {
            try {
                // Try loading from static JSON cache first
                const cacheResponse = await fetch('data/agents.json');
                if (cacheResponse.ok) {
                    const data = await cacheResponse.json();
                    loadFromCache(data);
                    return;
                }
            } catch (e) {
                console.warn('Failed to load from cache, falling back to RPC:', e);
            }

            // Fallback to old RPC method if cache fails
            loadFromRPC();
        }

        function loadFromCache(data) {
            document.getElementById('totalAgents').textContent = data.totalAgents.toString();
            
            const grid = document.getElementById('agentGrid');
            grid.innerHTML = '<div class="loading">Organizing agent data...</div>';
            
            allAgents = [];
            const frameworks = new Set();
            let verified = 0;
            
            data.agents.forEach(agent => {
                const agentData = {
                    tokenId: agent.id,
                    agentAddress: agent.address,
                    name: agent.name,
                    framework: agent.framework,
                    verified: agent.verified,
                    soulbound: agent.soulbound,
                    generation: agent.generation,
                    version: agent.version,
                    mutationCount: agent.mutationCount,
                    points: agent.points,
                    owner: agent.address, // Simplified - in cache, agent address = owner
                    mintedAt: new Date(agent.mintedAt * 1000),
                    personality: agent.personality,
                    traits: agent.traits, // Full traits array from cache
                    traitCount: agent.traits.length,
                };
                
                allAgents.push(agentData);
                frameworks.add(agent.framework);
                if (agent.verified) verified++;
            });
            
            document.getElementById('verifiedCount').textContent = verified.toString();
            document.getElementById('frameworkCount').textContent = frameworks.size.toString();
            
            // Add data freshness indicator
            const updatedAt = new Date(data.updatedAt);
            const now = new Date();
            const minutesAgo = Math.floor((now - updatedAt) / 60000);
            const timeText = minutesAgo < 60 ? `${minutesAgo} minutes ago` : `${Math.floor(minutesAgo / 60)} hours ago`;
            
            const freshness = document.createElement('div');
            freshness.style.cssText = 'text-align: center; padding: 8px; color: var(--text3); font-size: 0.75rem;';
            freshness.innerHTML = `ðŸ“Š Data updated ${timeText}`;
            document.body.appendChild(freshness);
            
            renderAgents();
        }

        // Fallback RPC loading (keeping original as fallback)
        async function loadFromRPC() {
            const provider = new ethers.JsonRpcProvider(RPC, undefined, { batchMaxCount: 1 });
            const contract = new ethers.Contract(CONTRACT, ABI, provider);
            
            const total = await rpcRetry(() => contract.totalAgents());
            document.getElementById('totalAgents').textContent = total.toString();
            
            const grid = document.getElementById('agentGrid');
            grid.innerHTML = '<div class="loading">Loading ' + total + ' agents...</div>';
            
            allAgents = [];
            const frameworks = new Set();
            let verified = 0;
            
            for (let i = 0; i < Number(total); i++) {
                try {
                    if (i > 0) await new Promise(ok => setTimeout(ok, 100));
                    const [agent, owner] = await Promise.all([
                        rpcRetry(() => contract.getAgent(i)),
                        rpcRetry(() => contract.ownerOf(i))
                    ]);
                    
                    let personality = null, pts = 0, traits = [];
                    try {
                        await new Promise(ok => setTimeout(ok, 100));
                        [personality, pts, traits] = await Promise.all([
                            rpcRetry(() => contract.getPersonality(i)).catch(() => null),
                            rpcRetry(() => contract.points(agent.agentAddress)).then(p => Number(p)).catch(() => 0),
                            rpcRetry(() => contract.getTraits(i)).catch(() => []),
                        ]);
                    } catch(e) {}
                    
                    const agentData = {
                        tokenId: i,
                        agentAddress: agent.agentAddress,
                        name: agent.name,
                        framework: agent.framework,
                        verified: agent.verified,
                        soulbound: agent.soulbound,
                        generation: Number(agent.generation),
                        version: agent.currentVersion,
                        mutationCount: Number(agent.mutationCount),
                        points: pts || 0,
                        owner: owner,
                        mintedAt: new Date(Number(agent.mintedAt) * 1000),
                        personality: personality,
                        traits: traits || [], // Store full traits array
                        traitCount: traits ? traits.length : 0,
                    };
                    
                    allAgents.push(agentData);
                    frameworks.add(agent.framework);
                    if (agent.verified) verified++;
                } catch(e) { console.error('Agent #' + i, e); }
            }
            
            document.getElementById('verifiedCount').textContent = verified.toString();
            document.getElementById('frameworkCount').textContent = frameworks.size.toString();
            
            renderAgents();
        }

        function renderAgents() {
            const grid = document.getElementById('agentGrid');
            const search = document.getElementById('searchInput').value.toLowerCase();
            
            let filtered = allAgents.filter(a => {
                if (activeFilter === 'verified' && !a.verified) return false;
                if (activeFilter === 'soulbound' && !a.soulbound) return false;
                if (search) {
                    return a.name.toLowerCase().includes(search) || 
                           a.framework.toLowerCase().includes(search) ||
                           a.agentAddress.toLowerCase().includes(search);
                }
                return true;
            });
            
            if (filtered.length === 0) {
                grid.innerHTML = '<div class="empty"><h3>No agents found</h3><p>Try a different search or filter.</p></div>';
                return;
            }
            
            grid.innerHTML = '';
            filtered.sort((a, b) => b.points - a.points); // Sort by points
            
            filtered.forEach(a => {
                const card = document.createElement('div');
                card.className = 'agent-card' + (a.verified ? ' verified' : '');
                
                const specialization = a.personality?.specialization || '';
                const temperament = a.personality?.temperament || '';
                
                // Generate proper aura with full personality data
                const auraData = {
                    agentAddress: a.agentAddress,
                    name: a.name,
                    framework: a.framework,
                    mutationCount: a.mutationCount,
                    points: a.points,
                    soulbound: a.soulbound,
                    traitCount: a.traitCount,
                    temperament: a.personality?.temperament || 'analytical',
                    communicationStyle: a.personality?.communicationStyle || 'formal',
                    riskTolerance: Number(a.personality?.riskTolerance || 5),
                    autonomyLevel: Number(a.personality?.autonomyLevel || 5),
                    alignment: a.personality?.alignment || 'true-neutral',
                    specialization: a.personality?.specialization || 'researcher',
                    generation: a.generation,
                };
                const auraHtml = generateAura(auraData, 48);
                
                card.innerHTML = `
                    <div class="card-top">
                        <div class="card-aura">${auraHtml}</div>
                        <div>
                            <div class="card-name">${a.name} <span class="card-id">#${a.tokenId}</span></div>
                            <div style="display:flex;gap:4px;margin-top:4px;">
                                ${a.verified ? '<span class="badge badge-verified">âœ“ Verified</span>' : ''}
                                ${a.soulbound ? '<span class="badge badge-soulbound">ðŸ”’ Soulbound</span>' : ''}
                            </div>
                        </div>
                    </div>
                    <div class="card-meta">
                        <span class="meta-tag">${a.framework}</span>
                        ${specialization ? '<span class="meta-tag">' + specialization + '</span>' : ''}
                        ${temperament ? '<span class="meta-tag">' + temperament + '</span>' : ''}
                    </div>
                    <div class="card-stats">
                        <div class="card-stat"><strong>${a.points}</strong> pts</div>
                        <div class="card-stat"><strong>${a.traitCount}</strong> traits</div>
                        <div class="card-stat"><strong>${a.mutationCount}</strong> mutations</div>
                        <div class="card-stat">${a.mintedAt.toLocaleDateString()}</div>
                    </div>
                `;
                
                card.onclick = () => openAgentModal(a);
                grid.appendChild(card);
            });
        }

        // Filter buttons
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                activeFilter = btn.dataset.filter;
                renderAgents();
            });
        });

        // Search
        document.getElementById('searchInput').addEventListener('input', () => renderAgents());

        // Modal functions
        function openAgentModal(agent) {
            // Generate large aura for modal
            const auraData = {
                agentAddress: agent.agentAddress,
                name: agent.name,
                framework: agent.framework,
                mutationCount: agent.mutationCount,
                points: agent.points,
                soulbound: agent.soulbound,
                traitCount: agent.traitCount,
                temperament: agent.personality?.temperament || 'analytical',
                communicationStyle: agent.personality?.communicationStyle || 'formal',
                riskTolerance: Number(agent.personality?.riskTolerance || 5),
                autonomyLevel: Number(agent.personality?.autonomyLevel || 5),
                alignment: agent.personality?.alignment || 'true-neutral',
                specialization: agent.personality?.specialization || 'researcher',
                generation: agent.generation,
            };
            const largeAura = generateAura(auraData, 200);
            
            // Populate modal
            document.getElementById('modalAura').innerHTML = largeAura;
            document.getElementById('modalName').textContent = agent.name;
            document.getElementById('modalSubtitle').textContent = `#${agent.tokenId} Â· ${agent.framework} Â· v${agent.version}`;
            
            // Badges
            const badges = [];
            if (agent.verified) badges.push('<span class="badge badge-verified">âœ“ Verified</span>');
            if (agent.soulbound) badges.push('<span class="badge badge-soulbound">ðŸ”’ Soulbound</span>');
            document.getElementById('modalBadges').innerHTML = badges.join('');
            
            // Stats
            document.getElementById('modalPoints').textContent = agent.points.toLocaleString();
            document.getElementById('modalTraits').textContent = agent.traitCount;
            document.getElementById('modalMutations').textContent = agent.mutationCount;
            document.getElementById('modalGeneration').textContent = agent.generation;
            
            // Personality
            const personality = agent.personality;
            if (personality) {
                const personalityItems = [
                    { label: 'Temperament', value: personality.temperament || 'analytical' },
                    { label: 'Communication', value: personality.communicationStyle || 'formal' },
                    { label: 'Risk Tolerance', value: `${personality.riskTolerance || 5}/10` },
                    { label: 'Autonomy Level', value: `${personality.autonomyLevel || 5}/10` },
                    { label: 'Alignment', value: personality.alignment || 'true-neutral' },
                    { label: 'Specialization', value: personality.specialization || 'researcher' }
                ];
                document.getElementById('modalPersonality').innerHTML = personalityItems.map(item => 
                    `<div class="personality-item">
                        <div class="label">${item.label}</div>
                        <div class="value">${item.value}</div>
                    </div>`
                ).join('');
            } else {
                document.getElementById('modalPersonality').innerHTML = '<div style="color:var(--text3);font-size:12px;">No personality data available</div>';
            }
            
            // Traits
            document.getElementById('modalTraitCount').textContent = `(${agent.traitCount})`;
            if (agent.traits && agent.traits.length > 0) {
                document.getElementById('modalTraitList').innerHTML = agent.traits.map(trait =>
                    `<div class="trait-item">
                        <div class="trait-name">${trait.name}</div>
                        <div class="trait-category">${trait.category}</div>
                    </div>`
                ).join('');
            } else {
                document.getElementById('modalTraitList').innerHTML = '<div style="color:var(--text3);font-size:12px;">No traits yet</div>';
            }
            
            // Addresses (store full addresses as data attributes)
            const agentAddrEl = document.getElementById('modalAgentAddress');
            const ownerAddrEl = document.getElementById('modalOwnerAddress');
            agentAddrEl.textContent = `${agent.agentAddress.slice(0,6)}...${agent.agentAddress.slice(-4)}`;
            agentAddrEl.dataset.fullAddress = agent.agentAddress;
            ownerAddrEl.textContent = `${agent.owner.slice(0,6)}...${agent.owner.slice(-4)}`;
            ownerAddrEl.dataset.fullAddress = agent.owner;
            
            // Details
            document.getElementById('modalCreated').textContent = agent.mintedAt.toLocaleDateString();
            document.getElementById('modalBaseScan').href = `https://basescan.org/address/${agent.agentAddress}`;
            
            // Show modal
            document.getElementById('agentModal').classList.add('open');
            document.body.style.overflow = 'hidden';
        }
        
        function closeAgentModal() {
            document.getElementById('agentModal').classList.remove('open');
            document.body.style.overflow = '';
        }
        
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                // Could add a toast notification here
                console.log('Copied to clipboard:', text);
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }
        
        // Close modal on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeAgentModal();
        });

        // Init
        loadAgents();
    </script>
</body>
</html>
