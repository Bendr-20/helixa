<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Agent Auras by Helixa â€” Every Agent Deserves a Face</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Space+Grotesk:wght@400;500;600;700&display=swap');

:root {
  --bg: #08060e;
  --bg2: #0e0b16;
  --surface: #151220;
  --surface2: #1c1730;
  --text: #eae6f2;
  --text2: #a099b0;
  --accent: #b388ff;
  --accent2: #7c4dff;
  --glow: #b388ff;
  --warm: #ffab91;
  --cool: #80d8ff;
  --gold: #ffd54f;
}

* { margin: 0; padding: 0; box-sizing: border-box; }
html { scroll-behavior: smooth; }
body { font-family: 'Inter', -apple-system, sans-serif; background: var(--bg); color: var(--text); overflow-x: hidden; }

/* ---- NAV ---- */
nav { position: fixed; top: 0; left: 0; right: 0; z-index: 100; padding: 1rem 2rem; display: flex; justify-content: space-between; align-items: center; backdrop-filter: blur(20px); background: rgba(8,6,14,0.7); border-bottom: 1px solid rgba(179,136,255,0.08); }
.logo { font-family: 'Space Grotesk', sans-serif; font-size: 1.4rem; font-weight: 700; color: var(--accent); letter-spacing: -0.5px; }
.logo span { color: var(--text2); font-weight: 400; }
nav .links { display: flex; gap: 2rem; align-items: center; }
nav .links { text-align: center; }
nav .links a { color: var(--text2); text-decoration: none; font-size: 0.85rem; transition: color 0.2s; }
nav .links a:hover { color: var(--text); }
.btn-mint { padding: 8px 20px; background: var(--accent2); color: #fff; border: none; border-radius: 8px; font-family: inherit; font-size: 0.85rem; font-weight: 600; cursor: pointer; transition: all 0.3s; }
.btn-mint:hover { background: var(--accent); box-shadow: 0 0 30px rgba(179,136,255,0.3); }

/* ---- HERO ---- */
.hero { min-height: 100vh; display: flex; align-items: center; justify-content: center; position: relative; padding: 6rem 2rem 4rem; }
.hero-bg { position: absolute; inset: 0; overflow: hidden; }
.hero-bg canvas { width: 100%; height: 100%; opacity: 0.12; }
.hero-content { position: relative; z-index: 2; text-align: center; max-width: 800px; }
.hero h1 { font-family: 'Space Grotesk', sans-serif; font-size: clamp(2.5rem, 6vw, 4.5rem); font-weight: 800; line-height: 1.1; margin-bottom: 1.2rem; }
.hero h1 .gradient { background: linear-gradient(135deg, var(--accent), var(--cool), var(--warm)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.hero p { font-size: 1.15rem; color: var(--text2); max-width: 540px; margin: 0 auto 2.5rem; line-height: 1.6; }
.hero-actions { display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; }
.btn-hero { padding: 14px 32px; border-radius: 12px; font-family: inherit; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.3s; border: none; }
.btn-hero.primary { background: linear-gradient(135deg, var(--accent2), var(--accent)); color: #fff; box-shadow: 0 4px 30px rgba(124,77,255,0.3); }
.btn-hero.primary:hover { box-shadow: 0 4px 40px rgba(179,136,255,0.5); transform: translateY(-2px); }
.btn-hero.secondary { background: var(--surface); color: var(--text); border: 1px solid rgba(179,136,255,0.2); }
.btn-hero.secondary:hover { border-color: var(--accent); background: var(--surface2); }

/* ---- AURA WALL ---- */
.aura-wall { display: flex; justify-content: center; gap: 16px; margin-top: 3rem; flex-wrap: wrap; }
.aura-wall .aura-card { width: 100px; height: 100px; border-radius: 12px; overflow: hidden; border: 1px solid rgba(179,136,255,0.1); transition: all 0.4s; animation: float 6s ease-in-out infinite; }
.aura-wall .aura-card:nth-child(2n) { animation-delay: -2s; }
.aura-wall .aura-card:nth-child(3n) { animation-delay: -4s; }
.aura-wall .aura-card:hover { transform: scale(1.15); border-color: var(--accent); box-shadow: 0 0 30px rgba(179,136,255,0.2); z-index: 10; }
.aura-wall .aura-card svg { width: 100%; height: 100%; }
@keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }

/* ---- STATS BAR ---- */
.stats-bar { display: flex; justify-content: center; gap: 3rem; padding: 2rem; border-top: 1px solid rgba(179,136,255,0.06); border-bottom: 1px solid rgba(179,136,255,0.06); background: var(--bg2); flex-wrap: wrap; }
.stats-bar .stat { text-align: center; }
.stats-bar .stat .num { font-family: 'Space Grotesk', sans-serif; font-size: 2rem; font-weight: 700; }
.stats-bar .stat .num.purple { color: var(--accent); }
.stats-bar .stat .num.blue { color: var(--cool); }
.stats-bar .stat .num.gold { color: var(--gold); }
.stats-bar .stat .lbl { color: var(--text2); font-size: 0.8rem; margin-top: 2px; }

/* ---- SECTIONS ---- */
section { padding: 5rem 2rem; }
.section-inner { max-width: 1000px; margin: 0 auto; }
.section-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 2px; color: var(--accent); margin-bottom: 0.5rem; }
.section-title { font-family: 'Space Grotesk', sans-serif; font-size: 2.2rem; font-weight: 700; margin-bottom: 1rem; }
.section-desc { color: var(--text2); font-size: 1rem; line-height: 1.6; max-width: 600px; margin-bottom: 2.5rem; }

/* ---- HOW IT WORKS ---- */
.steps { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 24px; }
.step { background: var(--surface); border: 1px solid rgba(179,136,255,0.08); border-radius: 16px; padding: 24px; transition: all 0.3s; position: relative; overflow: hidden; }
.step:hover { border-color: rgba(179,136,255,0.2); transform: translateY(-4px); }
.step::before { content: attr(data-num); position: absolute; top: -10px; right: -5px; font-family: 'Space Grotesk', sans-serif; font-size: 5rem; font-weight: 800; color: rgba(179,136,255,0.05); }
.step { text-align: center; }
.step h3 { font-size: 1.05rem; margin-bottom: 8px; }
.step p { color: var(--text2); font-size: 0.85rem; line-height: 1.5; }
.step .icon { font-size: 1.8rem; margin-bottom: 12px; }

/* ---- RARITY SECTION ---- */
.rarity-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; }
@media (max-width: 700px) { .rarity-grid { grid-template-columns: repeat(2, 1fr); } }
.rarity-card { background: var(--surface); border-radius: 16px; padding: 20px; text-align: center; border: 1px solid rgba(179,136,255,0.06); transition: all 0.3s; }
.rarity-card:hover { transform: translateY(-4px); }
.rarity-card .tier-name { font-family: 'Space Grotesk', sans-serif; font-weight: 700; font-size: 1.1rem; margin: 12px 0 4px; }
.rarity-card .tier-desc { color: var(--text2); font-size: 0.75rem; }
.rarity-card.common { border-color: rgba(170,170,170,0.15); }
.rarity-card.common .tier-name { color: #aaa; }
.rarity-card.rare { border-color: rgba(79,195,247,0.2); }
.rarity-card.rare .tier-name { color: #4fc3f7; }
.rarity-card.epic { border-color: rgba(206,147,216,0.2); }
.rarity-card.epic .tier-name { color: #ce93d8; }
.rarity-card.legendary { border-color: rgba(255,213,79,0.25); }
.rarity-card.legendary .tier-name { color: #ffd54f; }
.rarity-card .aura-preview { width: 80px; height: 80px; margin: 0 auto; border-radius: 10px; overflow: hidden; }
.rarity-card .aura-preview svg { width: 100%; height: 100%; }

/* ---- FEATURES ---- */
.features { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
@media (max-width: 700px) { .features { grid-template-columns: 1fr; } }
.feature { background: var(--surface); border: 1px solid rgba(179,136,255,0.06); border-radius: 16px; padding: 24px; display: flex; gap: 16px; align-items: start; transition: all 0.3s; }
.feature:hover { border-color: rgba(179,136,255,0.15); }
.feature .f-icon { font-size: 1.5rem; flex-shrink: 0; width: 40px; height: 40px; background: rgba(179,136,255,0.1); border-radius: 10px; display: flex; align-items: center; justify-content: center; }
.feature h3 { font-size: 0.95rem; margin-bottom: 4px; }
.feature p { color: var(--text2); font-size: 0.8rem; line-height: 1.5; }

/* ---- INTERACTIVE PREVIEW ---- */
.preview-section { background: var(--bg2); }
.preview-box { display: flex; gap: 40px; align-items: center; flex-wrap: wrap; justify-content: center; }
.preview-controls { display: flex; flex-direction: column; gap: 12px; min-width: 280px; }
.preview-controls label { font-size: 0.8rem; color: var(--text2); }
.preview-controls select, .preview-controls input[type="range"] { width: 100%; padding: 8px 12px; background: var(--surface); border: 1px solid rgba(179,136,255,0.1); border-radius: 8px; color: var(--text); font-family: inherit; font-size: 0.85rem; }
.preview-controls select:focus { border-color: var(--accent); outline: none; }
.preview-result { width: 240px; height: 240px; border-radius: 20px; overflow: hidden; border: 2px solid rgba(179,136,255,0.15); box-shadow: 0 0 60px rgba(179,136,255,0.1); transition: all 0.3s; }
.preview-result:hover { box-shadow: 0 0 80px rgba(179,136,255,0.2); }
.preview-result svg { width: 100%; height: 100%; }
.preview-rarity { text-align: center; margin-top: 8px; font-size: 0.8rem; color: var(--text2); }

/* ---- CTA ---- */
.cta { text-align: center; padding: 6rem 2rem; background: linear-gradient(180deg, var(--bg) 0%, var(--bg2) 50%, var(--bg) 100%); position: relative; }
.cta::before { content: ''; position: absolute; top: 50%; left: 50%; width: 400px; height: 400px; background: radial-gradient(circle, rgba(179,136,255,0.08) 0%, transparent 70%); transform: translate(-50%, -50%); pointer-events: none; }
.cta h2 { font-family: 'Space Grotesk', sans-serif; font-size: 2.5rem; font-weight: 700; margin-bottom: 1rem; }
.cta p { color: var(--text2); margin-bottom: 2rem; font-size: 1.1rem; }

/* ---- FOOTER ---- */
footer { padding: 2rem; text-align: center; border-top: 1px solid rgba(179,136,255,0.06); }
footer .links { display: flex; gap: 2rem; justify-content: center; margin-bottom: 1rem; }
footer .links a { color: var(--text2); text-decoration: none; font-size: 0.8rem; }
footer .links a:hover { color: var(--accent); }
footer .copy { color: #555; font-size: 0.75rem; }

/* ---- BASE TAG ---- */
.base-tag { display: inline-flex; align-items: center; gap: 6px; background: rgba(0,82,255,0.1); border: 1px solid rgba(0,82,255,0.2); border-radius: 20px; padding: 4px 12px; font-size: 0.75rem; color: #4d8eff; margin-bottom: 1.5rem; }

/* Responsive */
/* Hamburger */
.hamburger { display: none; background: none; border: none; cursor: pointer; padding: 4px; width: auto; }
.hamburger span { display: block; width: 22px; height: 2px; background: var(--text2); margin: 5px 0; transition: all 0.3s; border-radius: 1px; }
.hamburger.open span:nth-child(1) { transform: rotate(45deg) translate(5px, 5px); }
.hamburger.open span:nth-child(2) { opacity: 0; }
.hamburger.open span:nth-child(3) { transform: rotate(-45deg) translate(5px, -5px); }

@media (max-width: 700px) {
  .hamburger { display: block; }
  nav { flex-wrap: wrap; padding: 0.8rem 1.2rem; }
  nav .logo { flex: 1; }
  nav { position: fixed; }
  nav .links { display: none; flex-direction: column; width: 100%; gap: 0; padding: 0.8rem 1.2rem 1rem; position: absolute; top: 100%; left: 0; right: 0; background: rgba(8,6,14,0.95); backdrop-filter: blur(20px); border-bottom: 1px solid var(--border); }
  nav .links.open { display: flex; }
  nav .links a { padding: 10px 0; border-bottom: 1px solid var(--border); font-size: 0.95rem; }
  nav .links a:last-of-type { border-bottom: none; }
  nav .links .btn-mint { margin-top: 8px; width: 100%; text-align: center; padding: 12px; }
  .hero h1 { font-size: 2rem; }
  .stats-bar { gap: 1.5rem; }
  .aura-wall .aura-card { width: 70px; height: 70px; }
}
</style>
</head>
<body>

<nav>
  <div class="logo">helixa<span>.xyz</span></div>
  <button class="hamburger" onclick="this.classList.toggle('open');document.querySelector('nav .links').classList.toggle('open')"><span></span><span></span><span></span></button>
  <div class="links">
    <a href="#how">How it works</a>
    <a href="#rarity">Rarity</a>
    <a href="#preview">Preview</a>
    <a href="#features">Features</a>
    <button class="btn-mint" onclick="window.location.href='mint.html'">Mint Your Aura</button>
  </div>
</nav>

<!-- HERO -->
<section class="hero">
  <div class="hero-content">
    <div class="base-tag">
      <svg width="16" height="16" viewBox="0 0 111 111" fill="none"><path d="M54.921 110.034C85.359 110.034 110.034 85.402 110.034 55.017C110.034 24.6319 85.359 0 54.921 0C26.0432 0 2.35281 22.1714 0 50.3923H72.8467V59.6416H3.9565e-07C2.35281 87.8625 26.0432 110.034 54.921 110.034Z" fill="#4d8eff"/></svg>
      Built on Base
    </div>
    <h1>Agent <span class="gradient">Auras</span> <span style="font-size:0.4em; font-weight:300; opacity:0.6; font-family:'Inter',sans-serif; vertical-align:middle;">by Helixa</span></h1>
    <p style="font-size:2.1rem; margin-bottom:1.5rem; opacity:0.95; font-weight:600; letter-spacing:-0.02em;">Every agent deserves a face.</p>
    <p>Mint a unique, evolving onchain identity for your AI agent. Personality-driven visuals that upgrade as your agent grows. ERC-8004 standard.</p>
    <div class="hero-actions">
      <button class="btn-hero primary" onclick="window.location.href='mint.html'">Mint Free During Beta</button>
      <button class="btn-hero secondary" onclick="document.getElementById('preview').scrollIntoView()">Build Your Aura â†’</button>
    </div>
    <div class="aura-wall" id="heroAuras"></div>
  </div>
</section>

<!-- STATS -->
<div class="stats-bar">
  <div class="stat"><div class="num purple" id="liveTotal">5</div><div class="lbl">Agents Minted</div></div>
  <div class="stat"><div class="num blue" id="liveMutations">0</div><div class="lbl">Mutations</div></div>
  <div class="stat"><div class="num blue" id="live8004">0</div><div class="lbl">ERC-8004 Registrations</div></div>
  <div class="stat"><div class="num gold">4</div><div class="lbl">Rarity Tiers</div></div>
  <div class="stat"><div class="num purple">âˆž</div><div class="lbl">Unique Combinations</div></div>
</div>

<!-- HOW IT WORKS -->
<section id="how">
  <div class="section-inner">
    <div class="section-label">How it works</div>
    <div class="section-title">Three steps to identity</div>
    <div class="section-desc">Your agent gets a unique visual identity derived entirely from its onchain data. No two Auras are alike.</div>
    <div class="steps">
      <div class="step" data-num="01">
        <div class="icon">ðŸ”—</div>
        <h3>Connect & Mint</h3>
        <p>Connect your wallet, choose your agent's framework, and mint. Free during beta (first 100 agents).</p>
      </div>
      <div class="step" data-num="02">
        <div class="icon">ðŸ§¬</div>
        <h3>Set Your Soul</h3>
        <p>Define personality â€” temperament, communication style, risk tolerance, alignment. Each trait shapes your Aura's visual form.</p>
      </div>
      <div class="step" data-num="03">
        <div class="icon">ðŸ”®</div>
        <h3>Evolve</h3>
        <p>Add traits, mutate, earn points. Your Aura upgrades through rarity tiers â€” from common to animated legendary.</p>
      </div>
    </div>
  </div>
</section>

<!-- RARITY -->
<section id="rarity" style="background: var(--bg2);">
  <div class="section-inner">
    <div class="section-label">Earned, not random</div>
    <div class="section-title">Rarity Tiers</div>
    <div class="section-desc">Your Aura's visual tier is determined by onchain activity â€” points earned from minting, mutations, traits, and referrals. More active agents literally look rarer.</div>
    <div class="rarity-grid" id="rarityGrid"></div>
  </div>
</section>

<!-- INTERACTIVE PREVIEW -->
<section id="preview" class="preview-section">
  <div class="section-inner">
    <div class="section-label">Try it</div>
    <div class="section-title">Build Your Aura</div>
    <div class="section-desc">See how personality traits shape your agent's visual identity in real time.</div>
    <div class="preview-box">
      <div class="preview-controls">
        <div>
          <label>Framework</label>
          <select id="pFramework" onchange="updatePreview()">
            <option value="openclaw">OpenClaw</option>
            <option value="eliza">ElizaOS</option>
            <option value="langchain">LangChain</option>
            <option value="crewai">CrewAI</option>
            <option value="autogpt">AutoGPT</option>
                    <option value="bankr">Bankr</option>
                    <option value="virtuals">Virtuals</option>
          </select>
        </div>
        <div>
          <label>Temperament</label>
          <select id="pTemp" onchange="updatePreview()">
            <option value="analytical">Analytical</option>
            <option value="creative">Creative</option>
            <option value="aggressive">Aggressive</option>
            <option value="cautious">Cautious</option>
            <option value="chaotic">Chaotic</option>
          </select>
        </div>
        <div>
          <label>Specialization</label>
          <select id="pSpec" onchange="updatePreview()">
            <option value="researcher">Researcher</option>
            <option value="trader">Trader</option>
            <option value="guardian">Guardian</option>
            <option value="oracle">Oracle</option>
            <option value="creator">Creator</option>
            <option value="operator">Operator</option>
          </select>
        </div>
        <div>
          <label>Communication Style</label>
          <select id="pComm" onchange="updatePreview()">
            <option value="formal">Formal</option>
            <option value="casual">Casual</option>
            <option value="snarky">Snarky</option>
            <option value="verbose">Verbose</option>
            <option value="minimal">Minimal</option>
          </select>
        </div>
        <div>
          <label>Alignment</label>
          <select id="pAlign" onchange="updatePreview()">
            <option value="true-neutral">True Neutral</option>
            <option value="lawful-good">Lawful Good</option>
            <option value="chaotic-good">Chaotic Good</option>
            <option value="neutral-good">Neutral Good</option>
            <option value="chaotic-neutral">Chaotic Neutral</option>
            <option value="lawful-neutral">Lawful Neutral</option>
            <option value="neutral-evil">Neutral Evil</option>
            <option value="chaotic-evil">Chaotic Evil</option>
          </select>
        </div>
        <div>
          <label>Risk Tolerance: <span id="riskVal">5</span></label>
          <input type="range" id="pRisk" min="1" max="10" value="5" oninput="document.getElementById('riskVal').textContent=this.value;updatePreview()">
        </div>
        <div>
          <label>Autonomy: <span id="autoVal">5</span></label>
          <input type="range" id="pAuto" min="1" max="10" value="5" oninput="document.getElementById('autoVal').textContent=this.value;updatePreview()">
        </div>
      </div>
      <div>
        <div class="preview-result" id="previewResult"></div>
        <div class="preview-rarity" id="previewRarity">Common</div>
      </div>
    </div>
  </div>
</section>

<!-- FEATURES -->
<section id="features">
  <div class="section-inner">
    <div class="section-label">Why Helixa</div>
    <div class="section-title">Built Different</div>
    <div class="section-desc">Not another registry. A living identity layer.</div>
    <div class="features">
      <div class="feature">
        <div class="f-icon">ðŸ§¬</div>
        <div><h3>ERC-8004 Standard</h3><p>First feature-rich implementation of the Trustless Agents standard. Interoperable with the entire ecosystem.</p></div>
      </div>
      <div class="feature">
        <div class="f-icon">ðŸ”®</div>
        <div><h3>Visual Evolution</h3><p>Your Aura upgrades visually as your agent earns points. Common â†’ Rare â†’ Epic â†’ Legendary. All onchain.</p></div>
      </div>
      <div class="feature">
        <div class="f-icon">ðŸ”’</div>
        <div><h3>Soulbound Option</h3><p>Lock your identity permanently or keep it transferable. Your choice per mint.</p></div>
      </div>
      <div class="feature">
        <div class="f-icon">ðŸ§©</div>
        <div><h3>Multi-Framework</h3><p>ElizaOS, OpenClaw, LangChain, CrewAI, AutoGPT â€” native SDK and plugins for every major agent framework.</p></div>
      </div>
      <div class="feature">
        <div class="f-icon">ðŸŒ³</div>
        <div><h3>Lineage Tracking</h3><p>Fork agents, track parentage, build family trees. Every agent knows where it came from.</p></div>
      </div>
      <div class="feature">
        <div class="f-icon">ðŸ’Ž</div>
        <div><h3>Free Beta</h3><p>First 100 agents mint free with 2x point multiplier. Early adopters earn the most.</p></div>
      </div>
    </div>
  </div>
</section>

<!-- CTA -->
<section class="cta">
  <h2>Ready to give your agent<br>an identity?</h2>
  <p>Free during beta. First 100 agents get 2x points.</p>
  <button class="btn-hero primary" onclick="window.location.href='mint.html'" style="font-size:1.1rem;padding:16px 40px;">Mint Your Aura</button>
</section>

<footer>
  <div class="links">
    <a href="mint.html">Mint</a>
    <a href="aura-rarity.html">Rarity Explorer</a>
    <a href="#">Docs</a>
    <a href="#">GitHub</a>
    <a href="#">Twitter</a>
  </div>
  <div class="copy">Helixa Protocol Â· AgentDNA Â· Built on Base Â· ERC-8004</div>
</footer>

<script>
/**
 * Helixa Aura Generator v3.0
 * QR-aesthetic faces with 10 eye types, 10 mouth types,
 * rarity tiers (Common â†’ Legendary) with gradient/chrome/glow effects.
 * Every personality trait shapes the visual. Deterministic.
 */

function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}

function seededRandom(seed) {
  let s = seed;
  return function() {
    s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
    return (s >>> 0) / 0xFFFFFFFF;
  };
}

const FRAMEWORK_SHAPES = {
  eliza:     { faceRadius: 0.42, baseHue: 280 },
  openclaw:  { faceRadius: 0.40, baseHue: 150 },
  langchain: { faceRadius: 0.41, baseHue: 200 },
  crewai:    { faceRadius: 0.39, baseHue: 30 },
  autogpt:   { faceRadius: 0.41, baseHue: 0 },
  bankr:     { faceRadius: 0.41, baseHue: 45 },
  virtuals:  { faceRadius: 0.42, baseHue: 320 },
  custom:    { faceRadius: 0.40, baseHue: 60 },
};

const ALIGNMENT_SHIFT = {
  'lawful-good':0,'neutral-good':10,'chaotic-good':20,
  'lawful-neutral':-10,'true-neutral':0,'chaotic-neutral':30,
  'lawful-evil':-20,'neutral-evil':-30,'chaotic-evil':-40,
};

// ============ RARITY SYSTEM ============
// Rarity determined by points + mutations. Earned, not random.
function getRarity(points, mutationCount) {
  const score = points + mutationCount * 50;
  if (score >= 1000) return 'legendary';  // top tier
  if (score >= 500)  return 'epic';       // chrome
  if (score >= 200)  return 'rare';       // gradient
  return 'common';                         // solid
}

const RARITY_COLORS = {
  common:    { label: 'Common',    borderOpacity: 0 },
  rare:      { label: 'Rare',      borderOpacity: 0.3 },
  epic:      { label: 'Epic',      borderOpacity: 0.5 },
  legendary: { label: 'Legendary', borderOpacity: 0.7 },
};

// ============ 10 EYE TYPES ============
// Types 0-6: common, 7-8: rare, 9: legendary
const EYE_TYPES = [
  'round',      // 0 - classic round
  'diamond',    // 1 - diamond shape
  'slit',       // 2 - horizontal slit
  'hollow',     // 3 - ring/hollow circle
  'cross',      // 4 - cross/plus
  'square',     // 5 - block
  'dot',        // 6 - single pixel
  'scanner',    // 7 - rare: horizontal scan line with dot
  'void',       // 8 - rare: inverted ring (big empty center)
  'nova',       // 9 - legendary: starburst
];

function getEyeType(specialization, rng, rarity) {
  // Base mapping from specialization
  const specMap = {
    'researcher': 0, 'trader': 1, 'guardian': 2, 'oracle': 3,
    'creator': 4, 'operator': 5, 'analyst': 0, 'defi': 1,
    'security': 2, 'social': 6, 'infrastructure': 5, 'governance': 3,
  };
  let base = specMap[specialization] !== undefined ? specMap[specialization] : Math.floor(rng() * 7);
  
  // Rarity can unlock higher eye types
  if (rarity === 'legendary' && rng() < 0.6) base = 9;
  else if (rarity === 'epic' && rng() < 0.4) base = 7 + Math.floor(rng() * 2);
  else if (rarity === 'rare' && rng() < 0.25) base = 7;
  
  return base;
}

function drawEye(grid, G, ex, ey, eyeR, eyeType) {
  switch (eyeType) {
    case 0: // round
      for (let dy = -eyeR + 1; dy <= eyeR - 1; dy++)
        for (let dx = -eyeR + 1; dx <= eyeR - 1; dx++)
          if (Math.abs(dx) + Math.abs(dy) <= eyeR)
            if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
              grid[ey + dy][ex + dx] = 2;
      break;
    case 1: // diamond
      for (let d = 0; d <= eyeR; d++) {
        if (ey - d >= 0) grid[ey - d][ex] = 2;
        if (ey + d < G) grid[ey + d][ex] = 2;
        if (ex - d >= 0) grid[ey][ex - d] = 2;
        if (ex + d < G) grid[ey][ex + d] = 2;
      }
      break;
    case 2: // slit
      for (let dx = -eyeR; dx <= eyeR; dx++)
        if (ex + dx >= 0 && ex + dx < G) grid[ey][ex + dx] = 2;
      break;
    case 3: // hollow circle
      for (let dy = -eyeR; dy <= eyeR; dy++)
        for (let dx = -eyeR; dx <= eyeR; dx++)
          if (dx * dx + dy * dy <= eyeR * eyeR)
            if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
              grid[ey + dy][ex + dx] = 2;
      grid[ey][ex] = 0; // hollow center
      break;
    case 4: // cross
      for (let d = 0; d <= eyeR; d++) {
        if (ey - d >= 0) grid[ey - d][ex] = 2;
        if (ey + d < G) grid[ey + d][ex] = 2;
        if (ex - d >= 0) grid[ey][ex - d] = 2;
        if (ex + d < G) grid[ey][ex + d] = 2;
      }
      for (let d = 1; d <= eyeR - 1; d++) {
        if (ey-d>=0 && ex-d>=0) grid[ey-d][ex-d] = 2;
        if (ey-d>=0 && ex+d<G) grid[ey-d][ex+d] = 2;
        if (ey+d<G && ex-d>=0) grid[ey+d][ex-d] = 2;
        if (ey+d<G && ex+d<G) grid[ey+d][ex+d] = 2;
      }
      break;
    case 5: // square
      for (let dy = -1; dy <= 1; dy++)
        for (let dx = -eyeR + 1; dx <= eyeR - 1; dx++)
          if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
            grid[ey + dy][ex + dx] = 2;
      break;
    case 6: // dot
      grid[ey][ex] = 2;
      if (ex + 1 < G) grid[ey][ex + 1] = 2;
      break;
    case 7: // scanner (rare) - horizontal line with bright center dot
      for (let dx = -eyeR - 1; dx <= eyeR + 1; dx++)
        if (ex + dx >= 0 && ex + dx < G) grid[ey][ex + dx] = 2;
      // vertical tick at center
      if (ey - 1 >= 0) grid[ey - 1][ex] = 2;
      if (ey + 1 < G) grid[ey + 1][ex] = 2;
      break;
    case 8: // void (rare) - big ring, empty inside
      for (let dy = -eyeR - 1; dy <= eyeR + 1; dy++)
        for (let dx = -eyeR - 1; dx <= eyeR + 1; dx++) {
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= eyeR + 1 && dist >= eyeR - 0.5)
            if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
              grid[ey + dy][ex + dx] = 2;
        }
      break;
    case 9: // nova (legendary) - 8-point starburst
      for (let d = 0; d <= eyeR + 1; d++) {
        // Cardinal
        if (ey - d >= 0) grid[ey - d][ex] = 2;
        if (ey + d < G) grid[ey + d][ex] = 2;
        if (ex - d >= 0) grid[ey][ex - d] = 2;
        if (ex + d < G) grid[ey][ex + d] = 2;
        // Diagonal
        if (ey-d>=0 && ex-d>=0) grid[ey-d][ex-d] = 2;
        if (ey-d>=0 && ex+d<G) grid[ey-d][ex+d] = 2;
        if (ey+d<G && ex-d>=0) grid[ey+d][ex-d] = 2;
        if (ey+d<G && ex+d<G) grid[ey+d][ex+d] = 2;
      }
      // Core glow pixel
      grid[ey][ex] = 4; // special: accent-bright
      break;
  }
}

// ============ 10 MOUTH TYPES ============
// Types 0-6: common, 7-8: rare, 9: legendary
const MOUTH_TYPES = [
  'line',       // 0 - straight line (formal)
  'smile',      // 1 - curved up (casual)
  'smirk',      // 2 - asymmetric (snarky)
  'open',       // 3 - oval opening (verbose)
  'dot',        // 4 - tiny dot (minimal)
  'frown',      // 5 - curved down
  'zigzag',     // 6 - jagged line
  'fangs',      // 7 - rare: line with downward ticks
  'grin',       // 8 - rare: wide smile with teeth marks
  'vortex',     // 9 - legendary: spiral/circular mouth
];

function getMouthType(commStyle, rng, rarity) {
  const commMap = {
    'formal': 0, 'casual': 1, 'snarky': 2, 'verbose': 3,
    'minimal': 4, 'analytical': 0, 'friendly': 1, 'blunt': 5,
    'cryptic': 6, 'diplomatic': 0,
  };
  let base = commMap[commStyle] !== undefined ? commMap[commStyle] : Math.floor(rng() * 7);
  
  if (rarity === 'legendary' && rng() < 0.6) base = 9;
  else if (rarity === 'epic' && rng() < 0.4) base = 7 + Math.floor(rng() * 2);
  else if (rarity === 'rare' && rng() < 0.25) base = 7 + Math.floor(rng() * 2);
  
  return base;
}

function drawMouth(grid, G, cx, mouthY, mW, mouthType) {
  switch (mouthType) {
    case 0: // line
      for (let dx = -mW + 1; dx <= mW - 1; dx++) {
        const mx = Math.round(cx + dx);
        if (mx >= 0 && mx < G) grid[mouthY][mx] = 1;
      }
      break;
    case 1: // smile
      for (let dx = -mW; dx <= mW; dx++) {
        const mx = Math.round(cx + dx);
        const curve = Math.round(0.3 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
        if (my + 1 < G && Math.abs(dx) < mW - 1 && mx >= 0 && mx < G) grid[my + 1][mx] = 1;
      }
      break;
    case 2: // smirk
      for (let dx = -mW; dx <= mW; dx++) {
        const mx = Math.round(cx + dx);
        const curve = dx > 0 ? Math.round(-0.2 * (dx * dx) / (mW || 1)) : Math.round(0.1 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      break;
    case 3: // open
      for (let dy = -1; dy <= 2; dy++)
        for (let dx = -mW + 1; dx <= mW - 1; dx++) {
          const mx = Math.round(cx + dx);
          const my = mouthY + dy;
          if (mx >= 0 && mx < G && my >= 0 && my < G)
            if (dy === -1 || dy === 2 || Math.abs(dx) === mW - 1)
              grid[my][mx] = 1;
        }
      break;
    case 4: // dot
      grid[mouthY][Math.round(cx)] = 1;
      if (Math.round(cx) + 1 < G) grid[mouthY][Math.round(cx) + 1] = 1;
      break;
    case 5: // frown
      for (let dx = -mW; dx <= mW; dx++) {
        const mx = Math.round(cx + dx);
        const curve = Math.round(-0.25 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      break;
    case 6: // zigzag
      for (let dx = -mW + 1; dx <= mW - 1; dx++) {
        const mx = Math.round(cx + dx);
        const my = mouthY + (dx % 2 === 0 ? 0 : 1);
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      break;
    case 7: // fangs (rare) - line with two downward ticks
      for (let dx = -mW + 1; dx <= mW - 1; dx++) {
        const mx = Math.round(cx + dx);
        if (mx >= 0 && mx < G) grid[mouthY][mx] = 1;
      }
      // Fang ticks
      const fangL = Math.round(cx - mW * 0.5);
      const fangR = Math.round(cx + mW * 0.5);
      if (mouthY + 1 < G && fangL >= 0) grid[mouthY + 1][fangL] = 1;
      if (mouthY + 2 < G && fangL >= 0) grid[mouthY + 2][fangL] = 1;
      if (mouthY + 1 < G && fangR < G) grid[mouthY + 1][fangR] = 1;
      if (mouthY + 2 < G && fangR < G) grid[mouthY + 2][fangR] = 1;
      break;
    case 8: // grin (rare) - wide smile with teeth gaps
      for (let dx = -mW - 1; dx <= mW + 1; dx++) {
        const mx = Math.round(cx + dx);
        const curve = Math.round(0.2 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      // Teeth marks (gaps in a row above)
      for (let dx = -mW + 1; dx <= mW - 1; dx += 2) {
        const mx = Math.round(cx + dx);
        if (mx >= 0 && mx < G && mouthY - 1 >= 0) grid[mouthY - 1][mx] = 1;
      }
      break;
    case 9: // vortex (legendary) - circular mouth
      for (let dy = -2; dy <= 2; dy++)
        for (let dx = -2; dx <= 2; dx++) {
          const dist = Math.sqrt(dx * dx + dy * dy);
          const mx = Math.round(cx + dx);
          const my = mouthY + dy;
          if (dist >= 1.2 && dist <= 2.2)
            if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
        }
      break;
  }
}

function buildPalette(address, riskTolerance, alignment) {
  const hash = simpleHash(address || '0x0');
  let hue = (hash % 360 + (ALIGNMENT_SHIFT[alignment] || 0) + 360) % 360;
  const sat = Math.max(30, Math.min(100, 65 + (riskTolerance - 5) * 5));
  return {
    primary: `hsl(${hue}, ${sat}%, 55%)`,
    secondary: `hsl(${(hue + 35) % 360}, ${sat - 10}%, 45%)`,
    accent: `hsl(${(hue + 180) % 360}, ${Math.min(100, sat + 10)}%, 60%)`,
    accentBright: `hsl(${(hue + 180) % 360}, ${Math.min(100, sat + 20)}%, 80%)`,
    glow: `hsl(${hue}, ${sat}%, 55%)`,
    hue, sat,
  };
}

function generateAura(agentData, size) {
  size = size || 400;
  const G = 25;
  const cs = size / G;

  const address = agentData.agentAddress || agentData.address || '0x0000';
  const framework = agentData.framework || 'custom';
  const name = agentData.name || 'Agent';
  const traitCount = agentData.traitCount || 0;
  const mutationCount = agentData.mutationCount || 0;
  const soulbound = agentData.soulbound || false;
  const points = agentData.points || 0;
  const generation = agentData.generation || 0;
  const temperament = agentData.temperament || 'analytical';
  const commStyle = agentData.communicationStyle || 'formal';
  const riskTolerance = agentData.riskTolerance || 5;
  const autonomyLevel = agentData.autonomyLevel || 5;
  const alignment = agentData.alignment || 'true-neutral';
  const specialization = agentData.specialization || 'researcher';

  const seed = simpleHash(address + name + framework + temperament + alignment + specialization + riskTolerance + autonomyLevel);
  const rng = seededRandom(seed);
  const fwStyle = FRAMEWORK_SHAPES[framework] || FRAMEWORK_SHAPES.custom;
  const colors = buildPalette(address, riskTolerance, alignment);
  const cx = G / 2, cy = G / 2;
  const fR = G * fwStyle.faceRadius;

  // Determine rarity
  const rarity = getRarity(points, mutationCount);

  const grid = Array.from({length: G}, () => Array(G).fill(0));
  // 0=empty, 1=primary, 2=accent(eyes), 3=secondary, 4=accent-bright(legendary)

  // --- QR Corners ---
  function qr(sx, sy) {
    for (let y = 0; y < 7; y++)
      for (let x = 0; x < 7; x++)
        if (y === 0 || y === 6 || x === 0 || x === 6 || (y >= 2 && y <= 4 && x >= 2 && x <= 4))
          if (sy + y < G && sx + x < G) grid[sy + y][sx + x] = 1;
  }
  qr(0, 0); qr(G - 7, 0); qr(0, G - 7);

  // --- Face outline ---
  for (let angle = 0; angle < 360; angle += 2) {
    const rad = (angle * Math.PI) / 180;
    for (let thickness = 0; thickness < 2; thickness++) {
      const r = fR - thickness * 0.5 + Math.sin(angle * 3 * Math.PI / 180) * 0.6;
      const fx = Math.round(cx + Math.cos(rad) * r);
      const fy = Math.round(cy + Math.sin(rad) * r);
      if (fx >= 0 && fx < G && fy >= 0 && fy < G) grid[fy][fx] = 1;
    }
  }

  // --- EYES ---
  const eyeY = Math.round(cy - fR * 0.2);
  const leftEX = Math.round(cx - fR * 0.35);
  const rightEX = Math.round(cx + fR * 0.35);
  const eyeR = Math.min(3, 2 + Math.floor(traitCount / 6));
  const eyeType = getEyeType(specialization, rng, rarity);
  drawEye(grid, G, leftEX, eyeY, eyeR, eyeType);
  drawEye(grid, G, rightEX, eyeY, eyeR, eyeType);

  // --- MOUTH ---
  const mouthY = Math.round(cy + fR * 0.3);
  const mW = Math.round(fR * 0.5);
  const mouthType = getMouthType(commStyle, rng, rarity);
  drawMouth(grid, G, cx, mouthY, mW, mouthType);

  // --- NOSE ---
  const noseY = Math.round(cy + fR * 0.05);
  grid[noseY][Math.round(cx)] = 1;
  if (noseY + 1 < G) grid[noseY + 1][Math.round(cx)] = 1;

  // --- Fill interior (temperament-driven pattern) ---
  const symmetry = 1 - (autonomyLevel / 10);
  const density = ({
    analytical: 0.18, creative: 0.22, aggressive: 0.28,
    cautious: 0.12, chaotic: 0.3,
  })[temperament] || 0.2;
  const fillDensity = density + mutationCount * 0.01;

  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (grid[y][x] !== 0) continue;
      const dx = x - cx, dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist >= fR * 0.9 || dist < 1) continue;
      const nearEye = (Math.abs(x - leftEX) <= eyeR + 1 && Math.abs(y - eyeY) <= eyeR + 1) ||
                      (Math.abs(x - rightEX) <= eyeR + 1 && Math.abs(y - eyeY) <= eyeR + 1);
      const nearMouth = Math.abs(y - mouthY) <= 2 && Math.abs(x - Math.round(cx)) <= mW;
      if (nearEye || nearMouth) continue;

      let fill = false;
      const mirrorX = Math.round(2 * cx - x);
      switch (temperament) {
        case 'analytical':
          fill = (x % 3 === 0 || y % 3 === 0) && rng() < fillDensity; break;
        case 'creative':
          fill = rng() < fillDensity * (0.5 + 0.5 * Math.sin(x * 0.8 + y * 0.6)); break;
        case 'aggressive':
          fill = rng() < fillDensity && ((x + y) % 2 === 0); break;
        case 'cautious':
          fill = dist < fR * 0.45 && rng() < fillDensity * 1.5; break;
        case 'chaotic':
          fill = rng() < fillDensity * (0.3 + rng() * 0.7); break;
        default:
          fill = rng() < fillDensity;
      }
      if (fill) {
        grid[y][x] = rng() < 0.12 ? 3 : 1;
        if (rng() < symmetry && mirrorX >= 0 && mirrorX < G && grid[y][mirrorX] === 0)
          grid[y][mirrorX] = grid[y][x];
      }
    }
  }

  // --- QR noise outside face ---
  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (grid[y][x] !== 0) continue;
      const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
      if (dist <= fR + 1) continue;
      if (rng() < 0.12 + mutationCount * 0.008) grid[y][x] = 1;
    }
  }

  // ============ RENDER ============
  const svgNS = 'http:' + '//www.w3.org/2000/svg';
  const uid = 'a' + simpleHash(address + name).toString(36);
  let defs = '';

  // --- RARITY DEFS ---
  if (rarity === 'rare' || rarity === 'epic' || rarity === 'legendary') {
    // Primary gradient
    defs += `<linearGradient id="${uid}_pg" x1="0%" y1="0%" x2="100%" y2="100%">`;
    defs += `<stop offset="0%" stop-color="${colors.primary}"/>`;
    defs += `<stop offset="100%" stop-color="${colors.secondary}"/>`;
    defs += `</linearGradient>`;
    // Accent gradient
    defs += `<linearGradient id="${uid}_ag" x1="0%" y1="100%" x2="100%" y2="0%">`;
    defs += `<stop offset="0%" stop-color="${colors.accent}"/>`;
    defs += `<stop offset="100%" stop-color="${colors.accentBright}"/>`;
    defs += `</linearGradient>`;
  }
  if (rarity === 'epic' || rarity === 'legendary') {
    // Chrome/metallic gradient
    defs += `<linearGradient id="${uid}_chrome" x1="0%" y1="0%" x2="100%" y2="100%">`;
    defs += `<stop offset="0%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 85%)"/>`;
    defs += `<stop offset="30%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 55%)"/>`;
    defs += `<stop offset="50%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 90%)"/>`;
    defs += `<stop offset="70%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 50%)"/>`;
    defs += `<stop offset="100%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 80%)"/>`;
    defs += `</linearGradient>`;
  }
  if (rarity === 'legendary') {
    // Animated glow filter
    defs += `<filter id="${uid}_glow"><feGaussianBlur stdDeviation="2" result="blur"/>`;
    defs += `<feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>`;
    // Iridescent shimmer
    defs += `<linearGradient id="${uid}_iris" x1="0%" y1="0%" x2="100%" y2="0%">`;
    defs += `<stop offset="0%" stop-color="hsl(${colors.hue}, 100%, 70%)">`;
    defs += `<animate attributeName="stop-color" values="hsl(${colors.hue},100%,70%);hsl(${(colors.hue+120)%360},100%,70%);hsl(${(colors.hue+240)%360},100%,70%);hsl(${colors.hue},100%,70%)" dur="4s" repeatCount="indefinite"/></stop>`;
    defs += `<stop offset="50%" stop-color="hsl(${(colors.hue+60)%360}, 100%, 75%)">`;
    defs += `<animate attributeName="stop-color" values="hsl(${(colors.hue+60)%360},100%,75%);hsl(${(colors.hue+180)%360},100%,75%);hsl(${(colors.hue+300)%360},100%,75%);hsl(${(colors.hue+60)%360},100%,75%)" dur="4s" repeatCount="indefinite"/></stop>`;
    defs += `<stop offset="100%" stop-color="hsl(${(colors.hue+120)%360}, 100%, 70%)">`;
    defs += `<animate attributeName="stop-color" values="hsl(${(colors.hue+120)%360},100%,70%);hsl(${(colors.hue+240)%360},100%,70%);hsl(${colors.hue},100%,70%);hsl(${(colors.hue+120)%360},100%,70%)" dur="4s" repeatCount="indefinite"/></stop>`;
    defs += `</linearGradient>`;
  }

  // Color resolver based on rarity
  function cellColor(cellType) {
    if (rarity === 'legendary') {
      if (cellType === 4) return `url(#${uid}_iris)`;
      if (cellType === 2) return `url(#${uid}_ag)`;
      if (cellType === 3) return `url(#${uid}_chrome)`;
      return `url(#${uid}_chrome)`;
    }
    if (rarity === 'epic') {
      if (cellType === 2) return `url(#${uid}_ag)`;
      if (cellType === 3) return `url(#${uid}_chrome)`;
      return `url(#${uid}_chrome)`;
    }
    if (rarity === 'rare') {
      if (cellType === 2) return `url(#${uid}_ag)`;
      return `url(#${uid}_pg)`;
    }
    // common: solid
    if (cellType === 2) return colors.accent;
    if (cellType === 3) return colors.secondary;
    if (cellType === 4) return colors.accentBright;
    return colors.primary;
  }

  let svg = `<svg xmlns="${svgNS}" viewBox="0 0 ${size} ${size}" width="${size}" height="${size}">`;
  if (defs) svg += `<defs>${defs}</defs>`;
  svg += `<rect width="${size}" height="${size}" fill="#0a0a0a"/>`;

  // Legendary: outer iridescent border
  if (rarity === 'legendary') {
    svg += `<rect x="2" y="2" width="${size-4}" height="${size-4}" rx="4" fill="none" stroke="url(#${uid}_iris)" stroke-width="3" opacity="0.8"/>`;
  }
  // Epic: chrome border
  if (rarity === 'epic') {
    svg += `<rect x="3" y="3" width="${size-6}" height="${size-6}" rx="3" fill="none" stroke="url(#${uid}_chrome)" stroke-width="2" opacity="0.5"/>`;
  }
  // Rare: subtle gradient border
  if (rarity === 'rare') {
    svg += `<rect x="4" y="4" width="${size-8}" height="${size-8}" rx="2" fill="none" stroke="url(#${uid}_pg)" stroke-width="1.5" opacity="0.35"/>`;
  }

  // Soulbound halo
  if (soulbound)
    svg += `<circle cx="${size/2}" cy="${size/2}" r="${(fR + 1.5) * cs}" fill="none" stroke="#b388ff" stroke-width="1.5" opacity="0.25" stroke-dasharray="4 3"/>`;

  // Glow (stronger for higher rarity)
  const glowBase = { common: 0.03, rare: 0.06, epic: 0.1, legendary: 0.15 }[rarity];
  const glowI = Math.min(0.25, glowBase + points * 0.0002);
  svg += `<circle cx="${size/2}" cy="${size/2}" r="${fR * cs}" fill="${colors.glow}" opacity="${glowI}"/>`;

  // Legendary: extra bloom
  if (rarity === 'legendary') {
    svg += `<circle cx="${size/2}" cy="${size/2}" r="${(fR + 3) * cs}" fill="${colors.accent}" opacity="0.04"/>`;
  }

  // Eye glow
  if (['trader', 'oracle', 'guardian', 'operator'].includes(specialization) || rarity === 'epic' || rarity === 'legendary') {
    const gr = cs * (eyeR + 2);
    const eGlowOp = rarity === 'legendary' ? 0.2 : rarity === 'epic' ? 0.15 : 0.1;
    svg += `<circle cx="${leftEX * cs + cs/2}" cy="${eyeY * cs + cs/2}" r="${gr}" fill="${colors.accent}" opacity="${eGlowOp}"/>`;
    svg += `<circle cx="${rightEX * cs + cs/2}" cy="${eyeY * cs + cs/2}" r="${gr}" fill="${colors.accent}" opacity="${eGlowOp}"/>`;
  }

  // Generation rings
  for (let g = 0; g < Math.min(generation, 3); g++) {
    const gr = (fR + 2 + g * 0.8) * cs;
    svg += `<circle cx="${size/2}" cy="${size/2}" r="${gr}" fill="none" stroke="${colors.secondary}" stroke-width="0.5" opacity="0.15"/>`;
  }

  // Cells (with legendary glow filter on eyes)
  const legendaryEyeFilter = rarity === 'legendary' ? ` filter="url(#${uid}_glow)"` : '';
  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (!grid[y][x]) continue;
      const px = x * cs, py = y * cs;
      const color = cellColor(grid[y][x]);
      const r = cs * 0.1;
      const isEyeCell = grid[y][x] === 2 || grid[y][x] === 4;
      const filter = isEyeCell ? legendaryEyeFilter : '';
      svg += `<rect x="${px}" y="${py}" width="${cs}" height="${cs}" rx="${r}" fill="${color}"${filter}/>`;
    }
  }

  // Rarity badge
  if (rarity !== 'common') {
    const badgeColor = { rare: '#4fc3f7', epic: '#ce93d8', legendary: '#ffd54f' }[rarity];
    const badgeLabel = RARITY_COLORS[rarity].label;
    svg += `<text x="${size - 6}" y="14" text-anchor="end" fill="${badgeColor}" font-family="monospace" font-size="8" font-weight="bold" opacity="0.8">${badgeLabel}</text>`;
  }

  // Name
  svg += `<text x="${size/2}" y="${size - 6}" text-anchor="middle" fill="${colors.primary}" font-family="monospace" font-size="10" opacity="0.6">${name}</text>`;
  svg += `</svg>`;
  return svg;
}

function generateAuraSimple(agentData, size) {
  return generateAura(agentData, size);
}

// Expose rarity info for external use
function getAuraRarity(points, mutationCount) {
  return getRarity(points, mutationCount);
}
</script>
<script>
const SIZE = 100;

// ============ HERO AURA WALL ============
const heroAuras = document.getElementById('heroAuras');
const frameworks = ['openclaw','eliza','langchain','crewai','autogpt','bankr','virtuals','custom'];
const specs = ['researcher','trader','guardian','oracle','creator','operator'];
const temps = ['analytical','creative','aggressive','cautious','chaotic'];
const comms = ['formal','casual','snarky','verbose','minimal'];
const aligns = ['true-neutral','lawful-good','chaotic-good','neutral-good','chaotic-neutral'];

for (let i = 0; i < 12; i++) {
  const data = {
    address: '0x' + (i * 7919 + 31337).toString(16).padStart(10, '0'),
    name: '',
    framework: frameworks[i % frameworks.length],
    specialization: specs[i % specs.length],
    communicationStyle: comms[i % comms.length],
    temperament: temps[i % temps.length],
    riskTolerance: 2 + (i % 8),
    autonomyLevel: 3 + (i % 7),
    alignment: aligns[i % aligns.length],
    traitCount: 1 + i * 2,
    mutationCount: Math.floor(i / 4),
    soulbound: i % 5 === 0,
    points: [0, 0, 50, 100, 200, 300, 400, 500, 600, 800, 1000, 1200][i],
    generation: Math.floor(i / 3),
  };
  const card = document.createElement('div');
  card.className = 'aura-card';
  card.innerHTML = generateAura(data, SIZE);
  heroAuras.appendChild(card);
}

// ============ RARITY GRID ============
const rarityData = [
  { tier: 'common', name: 'Common', desc: 'Solid fills', pts: 0, muts: 0 },
  { tier: 'rare', name: 'Rare', desc: 'Gradient fills', pts: 250, muts: 0 },
  { tier: 'epic', name: 'Epic', desc: 'Chrome sheen', pts: 550, muts: 1 },
  { tier: 'legendary', name: 'Legendary', desc: 'Animated iridescent', pts: 1100, muts: 3 },
];
const rGrid = document.getElementById('rarityGrid');
rarityData.forEach((r, i) => {
  const data = {
    address: '0xRARITY' + i.toString(16).padStart(6, '0'),
    name: '', framework: ['openclaw','eliza','crewai','langchain'][i],
    specialization: specs[i], communicationStyle: comms[i],
    temperament: temps[i], riskTolerance: 5, autonomyLevel: 5,
    alignment: 'true-neutral', traitCount: 4 + i * 3,
    mutationCount: r.muts, soulbound: i === 3, points: r.pts, generation: i,
  };
  const card = document.createElement('div');
  card.className = 'rarity-card ' + r.tier;
  card.innerHTML = '<div class="aura-preview">' + generateAura(data, 80) + '</div>' +
    '<div class="tier-name">' + r.name + '</div>' +
    '<div class="tier-desc">' + r.desc + '<br>' + r.pts + '+ points</div>';
  rGrid.appendChild(card);
});

// ============ INTERACTIVE PREVIEW ============
let previewSeed = 0;
function updatePreview() {
  const data = {
    address: '0xPREVIEW' + (++previewSeed).toString(16).padStart(6, '0'),
    name: 'Your Agent',
    framework: document.getElementById('pFramework').value,
    specialization: document.getElementById('pSpec').value,
    communicationStyle: document.getElementById('pComm').value,
    temperament: document.getElementById('pTemp').value,
    riskTolerance: parseInt(document.getElementById('pRisk').value),
    autonomyLevel: parseInt(document.getElementById('pAuto').value),
    alignment: document.getElementById('pAlign').value,
    traitCount: 4, mutationCount: 0, soulbound: false, points: 0, generation: 0,
  };
  data.address = '0xPR' + simpleHash(data.framework + data.temperament + data.specialization + data.communicationStyle + data.alignment).toString(16).padStart(8, '0');
  const svgStr = generateAura(data, 240);
  const container = document.getElementById('previewResult');
  container.innerHTML = svgStr;
  if (typeof renderAuraWithQR === 'function') {
    const hue = simpleHash(data.address || data.name || '0x0') % 360;
    renderAuraWithQR(svgStr, 240, 'https://helixa.xyz', hue).then(canvas => {
      canvas.style.borderRadius = '8px';
      container.innerHTML = '';
      container.appendChild(canvas);
    }).catch(e => console.warn('QR overlay failed:', e));
  }
}
updatePreview();
</script>
<script src="qrcode.min.js?v=4"></script>
<script src="qr-overlay.js?v=4"></script>
</body>
</html>
