<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Helixa ‚Äî Agent Trading Cards</title>
<link rel="stylesheet" href="helixa-theme.css?v=2">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Inter', -apple-system, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; }

/* Nav */
nav { padding: 1rem 2rem; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border); }
.logo { font-family: 'Space Grotesk', sans-serif; font-size: 1.3rem; font-weight: 700; color: var(--accent); text-decoration: none; }
.logo span { color: var(--text3); font-weight: 400; }
.nav-links { display: flex; gap: 1.5rem; align-items: center; }
.nav-links a { color: var(--text2); text-decoration: none; font-size: 0.85rem; transition: color 0.2s; }
.nav-links a:hover { color: var(--text); }
.nav-links a.active { color: var(--accent); }

/* Main container */
.container { max-width: 1200px; margin: 0 auto; padding: 2rem; }

/* Header */
.page-header { text-align: center; padding: 2rem 0 1.5rem; }
.page-header h1 { font-family: 'Space Grotesk', sans-serif; font-size: 2rem; font-weight: 700; margin-bottom: 0.5rem; }
.page-header h1 .gradient { background: linear-gradient(135deg, var(--accent), var(--gold)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
.page-header p { color: var(--text2); font-size: 0.9rem; }

/* Grid view */
.grid-view { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1.5rem; }
.mini-card { 
  aspect-ratio: 2.5/3.5; 
  background: var(--surface); 
  border: 1px solid var(--border); 
  border-radius: 12px; 
  cursor: pointer; 
  transition: all 0.2s; 
  position: relative;
  overflow: hidden;
}
.mini-card:hover { transform: translateY(-4px); border-color: var(--accent); }
.mini-card .mini-aura { width: 100%; height: 60%; overflow: hidden; }
.mini-card .mini-aura svg { width: 100%; height: 100%; }
.mini-card .mini-info { padding: 0.5rem; height: 40%; }
.mini-card .mini-name { font-size: 0.8rem; font-weight: 600; margin-bottom: 0.2rem; }
.mini-card .mini-meta { font-size: 0.6rem; color: var(--text3); }
.mini-card .mini-rarity { position: absolute; top: 4px; right: 4px; padding: 2px 6px; border-radius: 8px; font-size: 0.6rem; font-weight: 600; }

/* Single card view */
.card-view { display: flex; justify-content: center; align-items: center; min-height: 600px; }
.trading-card {
  width: 350px;
  height: 490px;
  position: relative;
  background: var(--surface);
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 20px 40px rgba(0,0,0,0.3);
}

/* Card rarity frames */
.trading-card.common { border: 3px solid #666; }
.trading-card.rare { 
  border: 3px solid #4fc3f7; 
  box-shadow: 0 0 30px rgba(79, 195, 247, 0.3);
  animation: shimmer 3s ease-in-out infinite;
}
.trading-card.epic { 
  border: 3px solid #ce93d8; 
  box-shadow: 0 0 40px rgba(206, 147, 216, 0.4);
  background: linear-gradient(135deg, rgba(206,147,216,0.05), rgba(124,77,255,0.05));
  animation: chrome 4s ease-in-out infinite;
}
.trading-card.legendary { 
  border: 3px solid #ffd54f; 
  box-shadow: 0 0 50px rgba(255, 213, 79, 0.5);
  background: linear-gradient(135deg, rgba(255,213,79,0.08), rgba(206,147,216,0.08));
  animation: iridescent 5s linear infinite;
}

@keyframes shimmer { 0%, 100% { box-shadow: 0 0 30px rgba(79, 195, 247, 0.3); } 50% { box-shadow: 0 0 50px rgba(79, 195, 247, 0.6); } }
@keyframes chrome { 0%, 100% { filter: hue-rotate(0deg); } 50% { filter: hue-rotate(30deg); } }
@keyframes iridescent { 0% { filter: hue-rotate(0deg) saturate(1.2); } 25% { filter: hue-rotate(90deg) saturate(1.4); } 50% { filter: hue-rotate(180deg) saturate(1.2); } 75% { filter: hue-rotate(270deg) saturate(1.4); } 100% { filter: hue-rotate(360deg) saturate(1.2); } }

/* Card sections */
.card-header { padding: 12px 16px; display: flex; justify-content: space-between; align-items: flex-start; }
.card-name { font-family: 'Space Grotesk', sans-serif; font-size: 1.2rem; font-weight: 700; }
.card-hp { font-family: 'Space Grotesk', sans-serif; font-size: 1rem; font-weight: 700; color: var(--accent); }
.card-token-id { position: absolute; top: 8px; right: 12px; background: rgba(0,0,0,0.6); padding: 2px 6px; border-radius: 6px; font-size: 0.7rem; color: #fff; }

/* Cred Score Badge */
.cred-badge {
  position: absolute;
  top: -8px;
  right: -8px;
  width: 64px;
  height: 64px;
  border-radius: 50%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 10;
  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
  border: 2px solid rgba(255,255,255,0.15);
}
.cred-badge .cred-number {
  font-family: 'Space Grotesk', sans-serif;
  font-size: 1.4rem;
  font-weight: 800;
  line-height: 1;
}
.cred-badge .cred-label {
  font-size: 0.5rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  opacity: 0.9;
}
/* Cred tiers */
.cred-badge.cred-elite { background: linear-gradient(135deg, #ffd54f, #ff8f00); color: #1a1a1a; box-shadow: 0 4px 20px rgba(255,213,79,0.5); }
.cred-badge.cred-high { background: linear-gradient(135deg, #ce93d8, #7b1fa2); color: #fff; box-shadow: 0 4px 20px rgba(206,147,216,0.4); }
.cred-badge.cred-mid { background: linear-gradient(135deg, #4fc3f7, #0277bd); color: #fff; box-shadow: 0 4px 20px rgba(79,195,247,0.3); }
.cred-badge.cred-low { background: linear-gradient(135deg, #666, #333); color: #aaa; }

.card-artwork { height: 200px; margin: 0 16px; border-radius: 12px; overflow: hidden; position: relative; }
.card-artwork .aura-container { width: 100%; height: 100%; }
.card-artwork .aura-container svg { width: 100%; height: 100%; }
.card-rarity-badge { position: absolute; bottom: 8px; right: 8px; padding: 4px 10px; border-radius: 12px; font-size: 0.7rem; font-weight: 600; }

.card-type-bar { padding: 8px 16px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
.type-pill { padding: 3px 8px; border-radius: 12px; font-size: 0.7rem; font-weight: 600; }
.verified-badge, .soulbound-badge { font-size: 0.8rem; }

.card-stats { padding: 12px 16px; background: rgba(255,255,255,0.02); }
.card-stats h3 { font-size: 0.8rem; margin-bottom: 8px; color: var(--text2); font-weight: 600; }
.stat-row { display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.75rem; }
.stat-bar { width: 60px; height: 4px; background: var(--border); border-radius: 2px; position: relative; }
.stat-fill { height: 100%; background: var(--accent); border-radius: 2px; }

.card-moves { padding: 12px 16px; }
.card-moves h3 { font-size: 0.8rem; margin-bottom: 8px; color: var(--text2); font-weight: 600; }
.move-item { display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; padding: 4px 8px; background: rgba(255,255,255,0.05); border-radius: 6px; }
.move-name { font-size: 0.7rem; font-weight: 500; }
.move-type { font-size: 0.6rem; padding: 2px 6px; border-radius: 8px; }

.personality-bar { padding: 8px 16px; display: flex; gap: 6px; flex-wrap: wrap; }
.personality-tag { padding: 3px 8px; border-radius: 10px; font-size: 0.65rem; font-weight: 500; }

.card-footer { padding: 12px 16px; font-size: 0.7rem; color: var(--text3); }
.card-footer .address { font-family: monospace; }
.card-footer .helixa-brand { text-align: center; margin-top: 8px; font-weight: 600; }

/* Controls */
.controls { display: flex; gap: 1rem; justify-content: center; margin: 2rem 0; }
.btn { padding: 0.75rem 1.5rem; border: 1px solid var(--border); background: var(--surface); color: var(--text); border-radius: 8px; text-decoration: none; font-weight: 500; transition: all 0.2s; cursor: pointer; }
.btn:hover { background: var(--accent); border-color: var(--accent); color: white; }
.btn.primary { background: var(--accent); border-color: var(--accent); color: white; }

/* Loading */
.loading { text-align: center; padding: 3rem; color: var(--text3); }
.spinner { display: inline-block; width: 24px; height: 24px; border: 2px solid var(--border2); border-top: 2px solid var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }

/* Rarity colors */
.rarity-common { color: #aaa; background: rgba(170,170,170,0.15); }
.rarity-rare { color: #4fc3f7; background: rgba(79,195,247,0.15); }
.rarity-epic { color: #ce93d8; background: rgba(206,147,216,0.15); }
.rarity-legendary { color: #ffd54f; background: rgba(255,213,79,0.15); }

/* Type colors */
.type-eliza { background: linear-gradient(135deg, #7c4dff, #b388ff); color: white; }
.type-openclaw { background: linear-gradient(135deg, #00c853, #69f0ae); color: black; }
.type-langchain { background: linear-gradient(135deg, #2196f3, #64b5f6); color: white; }
.type-crewai { background: linear-gradient(135deg, #ff9800, #ffb74d); color: black; }
.type-autogpt { background: linear-gradient(135deg, #f44336, #e57373); color: white; }
.type-custom { background: linear-gradient(135deg, #9c27b0, #ba68c8); color: white; }

/* Personality colors */
.personality-analytical { background: rgba(33,150,243,0.2); color: #2196f3; }
.personality-creative { background: rgba(156,39,176,0.2); color: #9c27b0; }
.personality-aggressive { background: rgba(244,67,54,0.2); color: #f44336; }
.personality-cautious { background: rgba(76,175,80,0.2); color: #4caf50; }
.personality-chaotic { background: rgba(255,152,0,0.2); color: #ff9800; }
.personality-formal { background: rgba(96,125,139,0.2); color: #607d8b; }
.personality-casual { background: rgba(76,175,80,0.2); color: #4caf50; }
.personality-snarky { background: rgba(244,67,54,0.2); color: #f44336; }
.personality-verbose { background: rgba(156,39,176,0.2); color: #9c27b0; }
.personality-minimal { background: rgba(158,158,158,0.2); color: #9e9e9e; }
.personality-lawful-good { background: rgba(255,213,79,0.2); color: #ffd54f; }
.personality-chaotic-evil { background: rgba(244,67,54,0.2); color: #f44336; }
.personality-true-neutral { background: rgba(158,158,158,0.2); color: #9e9e9e; }

/* Mobile */
@media (max-width: 768px) {
  .container { padding: 1rem; }
  .trading-card { width: 280px; height: 392px; }
  .grid-view { grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 1rem; }
  .controls { flex-wrap: wrap; gap: 0.5rem; }
}
</style>
</head>
<body>

<nav>
  <a href="index.html" class="logo">helixa<span>.xyz</span></a>
  <div class="nav-links">
    <a href="index.html">Home</a>
    <a href="mint.html">Mint</a>
    <a href="directory.html">Directory</a>
    <a href="leaderboard.html">Leaderboard</a>
    <a href="manage.html">Manage</a>
  </div>
</nav>

<div class="container">
  <div class="page-header">
    <h1>üé¥ Agent Trading <span class="gradient">Cards</span></h1>
    <p>Collectible Pok√©mon-style cards for every Helixa agent with unique artwork and stats</p>
  </div>

  <!-- Grid view (default) -->
  <div id="gridView" class="grid-view" style="display: none;">
    <div class="loading">
      <div class="spinner"></div>
      <div style="margin-top:8px;">Loading agent cards...</div>
    </div>
  </div>

  <!-- Single card view -->
  <div id="cardView" class="card-view" style="display: none;">
    <div class="trading-card" id="tradingCard">
      <div class="loading">
        <div class="spinner"></div>
        <div style="margin-top:8px;">Loading card...</div>
      </div>
    </div>
  </div>

  <div class="controls">
    <a href="card.html" class="btn" id="viewAllBtn" style="display: none;">‚Üê View All Cards</a>
    <button class="btn primary" id="downloadBtn" style="display: none;">üì• Download Card</button>
    <button class="btn" id="shareBtn" style="display: none;">üîó Share</button>
  </div>
</div>

<!-- Footer -->
<footer style="text-align: center; padding: 2rem; color: var(--text3); font-size: 0.75rem; border-top: 1px solid var(--border); margin-top: 2rem;">
  <a href="index.html" style="color: var(--accent); text-decoration: none;">Helixa</a> ¬∑ Trading Cards ¬∑ Built on Base ¬∑ ERC-8004
</footer>

<script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script>
/**
 * Helixa Aura Generator v3.0
 * Full generateAura function copied from leaderboard.html
 */

function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}

function seededRandom(seed) {
  let s = seed;
  return function() {
    s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
    return (s >>> 0) / 0xFFFFFFFF;
  };
}

const FRAMEWORK_SHAPES = {
  eliza:     { faceRadius: 0.42, baseHue: 280 },
  openclaw:  { faceRadius: 0.40, baseHue: 150 },
  langchain: { faceRadius: 0.41, baseHue: 200 },
  crewai:    { faceRadius: 0.39, baseHue: 30 },
  autogpt:   { faceRadius: 0.41, baseHue: 0 },
  bankr:     { faceRadius: 0.41, baseHue: 45 },
  virtuals:  { faceRadius: 0.42, baseHue: 320 },
  custom:    { faceRadius: 0.40, baseHue: 60 },
};

const ALIGNMENT_SHIFT = {
  'lawful-good':0,'neutral-good':10,'chaotic-good':20,
  'lawful-neutral':-10,'true-neutral':0,'chaotic-neutral':30,
  'lawful-evil':-20,'neutral-evil':-30,'chaotic-evil':-40,
};

function getRarity(points, mutationCount) {
  const score = points + mutationCount * 50;
  if (score >= 1000) return 'legendary';
  if (score >= 500)  return 'epic';
  if (score >= 200)  return 'rare';
  return 'common';
}

const RARITY_COLORS = {
  common:    { label: 'Common',    borderOpacity: 0 },
  rare:      { label: 'Rare',      borderOpacity: 0.3 },
  epic:      { label: 'Epic',      borderOpacity: 0.5 },
  legendary: { label: 'Legendary', borderOpacity: 0.7 },
};

const EYE_TYPES = [
  'round', 'diamond', 'slit', 'hollow', 'cross', 'square', 'dot', 'scanner', 'void', 'nova'
];

function getEyeType(specialization, rng, rarity) {
  const specMap = {
    'researcher': 0, 'trader': 1, 'guardian': 2, 'oracle': 3,
    'creator': 4, 'operator': 5, 'analyst': 0, 'defi': 1,
    'security': 2, 'social': 6, 'infrastructure': 5, 'governance': 3,
  };
  let base = specMap[specialization] !== undefined ? specMap[specialization] : Math.floor(rng() * 7);
  
  if (rarity === 'legendary' && rng() < 0.6) base = 9;
  else if (rarity === 'epic' && rng() < 0.4) base = 7 + Math.floor(rng() * 2);
  else if (rarity === 'rare' && rng() < 0.25) base = 7;
  
  return base;
}

function drawEye(grid, G, ex, ey, eyeR, eyeType) {
  switch (eyeType) {
    case 0: // round
      for (let dy = -eyeR + 1; dy <= eyeR - 1; dy++)
        for (let dx = -eyeR + 1; dx <= eyeR - 1; dx++)
          if (Math.abs(dx) + Math.abs(dy) <= eyeR)
            if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
              grid[ey + dy][ex + dx] = 2;
      break;
    case 1: // diamond
      for (let d = 0; d <= eyeR; d++) {
        if (ey - d >= 0) grid[ey - d][ex] = 2;
        if (ey + d < G) grid[ey + d][ex] = 2;
        if (ex - d >= 0) grid[ey][ex - d] = 2;
        if (ex + d < G) grid[ey][ex + d] = 2;
      }
      break;
    case 2: // slit
      for (let dx = -eyeR; dx <= eyeR; dx++)
        if (ex + dx >= 0 && ex + dx < G) grid[ey][ex + dx] = 2;
      break;
    case 3: // hollow circle
      for (let dy = -eyeR; dy <= eyeR; dy++)
        for (let dx = -eyeR; dx <= eyeR; dx++)
          if (dx * dx + dy * dy <= eyeR * eyeR)
            if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
              grid[ey + dy][ex + dx] = 2;
      grid[ey][ex] = 0; // hollow center
      break;
    case 4: // cross
      for (let d = 0; d <= eyeR; d++) {
        if (ey - d >= 0) grid[ey - d][ex] = 2;
        if (ey + d < G) grid[ey + d][ex] = 2;
        if (ex - d >= 0) grid[ey][ex - d] = 2;
        if (ex + d < G) grid[ey][ex + d] = 2;
      }
      for (let d = 1; d <= eyeR - 1; d++) {
        if (ey-d>=0 && ex-d>=0) grid[ey-d][ex-d] = 2;
        if (ey-d>=0 && ex+d<G) grid[ey-d][ex+d] = 2;
        if (ey+d<G && ex-d>=0) grid[ey+d][ex-d] = 2;
        if (ey+d<G && ex+d<G) grid[ey+d][ex+d] = 2;
      }
      break;
    case 5: // square
      for (let dy = -1; dy <= 1; dy++)
        for (let dx = -eyeR + 1; dx <= eyeR - 1; dx++)
          if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
            grid[ey + dy][ex + dx] = 2;
      break;
    case 6: // dot
      grid[ey][ex] = 2;
      if (ex + 1 < G) grid[ey][ex + 1] = 2;
      break;
    case 7: // scanner
      for (let dx = -eyeR - 1; dx <= eyeR + 1; dx++)
        if (ex + dx >= 0 && ex + dx < G) grid[ey][ex + dx] = 2;
      if (ey - 1 >= 0) grid[ey - 1][ex] = 2;
      if (ey + 1 < G) grid[ey + 1][ex] = 2;
      break;
    case 8: // void
      for (let dy = -eyeR - 1; dy <= eyeR + 1; dy++)
        for (let dx = -eyeR - 1; dx <= eyeR + 1; dx++) {
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= eyeR + 1 && dist >= eyeR - 0.5)
            if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
              grid[ey + dy][ex + dx] = 2;
        }
      break;
    case 9: // nova
      for (let d = 0; d <= eyeR + 1; d++) {
        if (ey - d >= 0) grid[ey - d][ex] = 2;
        if (ey + d < G) grid[ey + d][ex] = 2;
        if (ex - d >= 0) grid[ey][ex - d] = 2;
        if (ex + d < G) grid[ey][ex + d] = 2;
        if (ey-d>=0 && ex-d>=0) grid[ey-d][ex-d] = 2;
        if (ey-d>=0 && ex+d<G) grid[ey-d][ex+d] = 2;
        if (ey+d<G && ex-d>=0) grid[ey+d][ex-d] = 2;
        if (ey+d<G && ex+d<G) grid[ey+d][ex+d] = 2;
      }
      grid[ey][ex] = 4;
      break;
  }
}

const MOUTH_TYPES = [
  'line', 'smile', 'smirk', 'open', 'dot', 'frown', 'zigzag', 'fangs', 'grin', 'vortex'
];

function getMouthType(commStyle, rng, rarity) {
  const commMap = {
    'formal': 0, 'casual': 1, 'snarky': 2, 'verbose': 3,
    'minimal': 4, 'analytical': 0, 'friendly': 1, 'blunt': 5,
    'cryptic': 6, 'diplomatic': 0,
  };
  let base = commMap[commStyle] !== undefined ? commMap[commStyle] : Math.floor(rng() * 7);
  
  if (rarity === 'legendary' && rng() < 0.6) base = 9;
  else if (rarity === 'epic' && rng() < 0.4) base = 7 + Math.floor(rng() * 2);
  else if (rarity === 'rare' && rng() < 0.25) base = 7 + Math.floor(rng() * 2);
  
  return base;
}

function drawMouth(grid, G, cx, mouthY, mW, mouthType) {
  switch (mouthType) {
    case 0: // line
      for (let dx = -mW + 1; dx <= mW - 1; dx++) {
        const mx = Math.round(cx + dx);
        if (mx >= 0 && mx < G) grid[mouthY][mx] = 1;
      }
      break;
    case 1: // smile
      for (let dx = -mW; dx <= mW; dx++) {
        const mx = Math.round(cx + dx);
        const curve = Math.round(0.3 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
        if (my + 1 < G && Math.abs(dx) < mW - 1 && mx >= 0 && mx < G) grid[my + 1][mx] = 1;
      }
      break;
    case 2: // smirk
      for (let dx = -mW; dx <= mW; dx++) {
        const mx = Math.round(cx + dx);
        const curve = dx > 0 ? Math.round(-0.2 * (dx * dx) / (mW || 1)) : Math.round(0.1 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      break;
    case 3: // open
      for (let dy = -1; dy <= 2; dy++)
        for (let dx = -mW + 1; dx <= mW - 1; dx++) {
          const mx = Math.round(cx + dx);
          const my = mouthY + dy;
          if (mx >= 0 && mx < G && my >= 0 && my < G)
            if (dy === -1 || dy === 2 || Math.abs(dx) === mW - 1)
              grid[my][mx] = 1;
        }
      break;
    case 4: // dot
      grid[mouthY][Math.round(cx)] = 1;
      if (Math.round(cx) + 1 < G) grid[mouthY][Math.round(cx) + 1] = 1;
      break;
    case 5: // frown
      for (let dx = -mW; dx <= mW; dx++) {
        const mx = Math.round(cx + dx);
        const curve = Math.round(-0.25 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      break;
    case 6: // zigzag
      for (let dx = -mW + 1; dx <= mW - 1; dx++) {
        const mx = Math.round(cx + dx);
        const my = mouthY + (dx % 2 === 0 ? 0 : 1);
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      break;
    case 7: // fangs
      for (let dx = -mW + 1; dx <= mW - 1; dx++) {
        const mx = Math.round(cx + dx);
        if (mx >= 0 && mx < G) grid[mouthY][mx] = 1;
      }
      const fangL = Math.round(cx - mW * 0.5);
      const fangR = Math.round(cx + mW * 0.5);
      if (mouthY + 1 < G && fangL >= 0) grid[mouthY + 1][fangL] = 1;
      if (mouthY + 2 < G && fangL >= 0) grid[mouthY + 2][fangL] = 1;
      if (mouthY + 1 < G && fangR < G) grid[mouthY + 1][fangR] = 1;
      if (mouthY + 2 < G && fangR < G) grid[mouthY + 2][fangR] = 1;
      break;
    case 8: // grin
      for (let dx = -mW - 1; dx <= mW + 1; dx++) {
        const mx = Math.round(cx + dx);
        const curve = Math.round(0.2 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      for (let dx = -mW + 1; dx <= mW - 1; dx += 2) {
        const mx = Math.round(cx + dx);
        if (mx >= 0 && mx < G && mouthY - 1 >= 0) grid[mouthY - 1][mx] = 1;
      }
      break;
    case 9: // vortex
      for (let dy = -2; dy <= 2; dy++)
        for (let dx = -2; dx <= 2; dx++) {
          const dist = Math.sqrt(dx * dx + dy * dy);
          const mx = Math.round(cx + dx);
          const my = mouthY + dy;
          if (dist >= 1.2 && dist <= 2.2)
            if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
        }
      break;
  }
}

function buildPalette(address, riskTolerance, alignment) {
  const hash = simpleHash(address || '0x0');
  let hue = (hash % 360 + (ALIGNMENT_SHIFT[alignment] || 0) + 360) % 360;
  const sat = Math.max(30, Math.min(100, 65 + (riskTolerance - 5) * 5));
  return {
    primary: `hsl(${hue}, ${sat}%, 55%)`,
    secondary: `hsl(${(hue + 35) % 360}, ${sat - 10}%, 45%)`,
    accent: `hsl(${(hue + 180) % 360}, ${Math.min(100, sat + 10)}%, 60%)`,
    accentBright: `hsl(${(hue + 180) % 360}, ${Math.min(100, sat + 20)}%, 80%)`,
    glow: `hsl(${hue}, ${sat}%, 55%)`,
    hue, sat,
  };
}

function generateAura(agentData, size) {
  size = size || 400;
  const G = 25;
  const cs = size / G;

  const address = agentData.agentAddress || agentData.address || '0x0000';
  const framework = agentData.framework || 'custom';
  const name = agentData.name || 'Agent';
  const traitCount = agentData.traitCount || 0;
  const mutationCount = agentData.mutationCount || 0;
  const soulbound = agentData.soulbound || false;
  const points = agentData.points || 0;
  const generation = agentData.generation || 0;
  const temperament = agentData.temperament || 'analytical';
  const commStyle = agentData.communicationStyle || 'formal';
  const riskTolerance = agentData.riskTolerance || 5;
  const autonomyLevel = agentData.autonomyLevel || 5;
  const alignment = agentData.alignment || 'true-neutral';
  const specialization = agentData.specialization || 'researcher';

  const seed = simpleHash(address + name + framework + temperament + alignment + specialization + riskTolerance + autonomyLevel);
  const rng = seededRandom(seed);
  const fwStyle = FRAMEWORK_SHAPES[framework] || FRAMEWORK_SHAPES.custom;
  const colors = buildPalette(address, riskTolerance, alignment);
  const cx = G / 2, cy = G / 2;
  const fR = G * fwStyle.faceRadius;

  const rarity = getRarity(points, mutationCount);

  const grid = Array.from({length: G}, () => Array(G).fill(0));

  function qr(sx, sy) {
    for (let y = 0; y < 7; y++)
      for (let x = 0; x < 7; x++)
        if (y === 0 || y === 6 || x === 0 || x === 6 || (y >= 2 && y <= 4 && x >= 2 && x <= 4))
          if (sy + y < G && sx + x < G) grid[sy + y][sx + x] = 1;
  }
  qr(0, 0); qr(G - 7, 0); qr(0, G - 7);

  for (let angle = 0; angle < 360; angle += 2) {
    const rad = (angle * Math.PI) / 180;
    for (let thickness = 0; thickness < 2; thickness++) {
      const r = fR - thickness * 0.5 + Math.sin(angle * 3 * Math.PI / 180) * 0.6;
      const fx = Math.round(cx + Math.cos(rad) * r);
      const fy = Math.round(cy + Math.sin(rad) * r);
      if (fx >= 0 && fx < G && fy >= 0 && fy < G) grid[fy][fx] = 1;
    }
  }

  const eyeY = Math.round(cy - fR * 0.2);
  const leftEX = Math.round(cx - fR * 0.35);
  const rightEX = Math.round(cx + fR * 0.35);
  const eyeR = Math.min(3, 2 + Math.floor(traitCount / 6));
  const eyeType = getEyeType(specialization, rng, rarity);
  drawEye(grid, G, leftEX, eyeY, eyeR, eyeType);
  drawEye(grid, G, rightEX, eyeY, eyeR, eyeType);

  const mouthY = Math.round(cy + fR * 0.3);
  const mW = Math.round(fR * 0.5);
  const mouthType = getMouthType(commStyle, rng, rarity);
  drawMouth(grid, G, cx, mouthY, mW, mouthType);

  const noseY = Math.round(cy + fR * 0.05);
  grid[noseY][Math.round(cx)] = 1;
  if (noseY + 1 < G) grid[noseY + 1][Math.round(cx)] = 1;

  const symmetry = 1 - (autonomyLevel / 10);
  const density = ({
    analytical: 0.18, creative: 0.22, aggressive: 0.28,
    cautious: 0.12, chaotic: 0.3,
  })[temperament] || 0.2;
  const fillDensity = density + mutationCount * 0.01;

  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (grid[y][x] !== 0) continue;
      const dx = x - cx, dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist >= fR * 0.9 || dist < 1) continue;
      const nearEye = (Math.abs(x - leftEX) <= eyeR + 1 && Math.abs(y - eyeY) <= eyeR + 1) ||
                      (Math.abs(x - rightEX) <= eyeR + 1 && Math.abs(y - eyeY) <= eyeR + 1);
      const nearMouth = Math.abs(y - mouthY) <= 2 && Math.abs(x - Math.round(cx)) <= mW;
      if (nearEye || nearMouth) continue;

      let fill = false;
      const mirrorX = Math.round(2 * cx - x);
      switch (temperament) {
        case 'analytical':
          fill = (x % 3 === 0 || y % 3 === 0) && rng() < fillDensity; break;
        case 'creative':
          fill = rng() < fillDensity * (0.5 + 0.5 * Math.sin(x * 0.8 + y * 0.6)); break;
        case 'aggressive':
          fill = rng() < fillDensity && ((x + y) % 2 === 0); break;
        case 'cautious':
          fill = dist < fR * 0.45 && rng() < fillDensity * 1.5; break;
        case 'chaotic':
          fill = rng() < fillDensity * (0.3 + rng() * 0.7); break;
        default:
          fill = rng() < fillDensity;
      }
      if (fill) {
        grid[y][x] = rng() < 0.12 ? 3 : 1;
        if (rng() < symmetry && mirrorX >= 0 && mirrorX < G && grid[y][mirrorX] === 0)
          grid[y][mirrorX] = grid[y][x];
      }
    }
  }

  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (grid[y][x] !== 0) continue;
      const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
      if (dist <= fR + 1) continue;
      if (rng() < 0.12 + mutationCount * 0.008) grid[y][x] = 1;
    }
  }

  const svgNS = 'http:' + '//www.w3.org/2000/svg';
  const uid = 'a' + simpleHash(address + name).toString(36);
  let defs = '';

  if (rarity === 'rare' || rarity === 'epic' || rarity === 'legendary') {
    defs += `<linearGradient id="${uid}_pg" x1="0%" y1="0%" x2="100%" y2="100%">`;
    defs += `<stop offset="0%" stop-color="${colors.primary}"/>`;
    defs += `<stop offset="100%" stop-color="${colors.secondary}"/>`;
    defs += `</linearGradient>`;
    defs += `<linearGradient id="${uid}_ag" x1="0%" y1="100%" x2="100%" y2="0%">`;
    defs += `<stop offset="0%" stop-color="${colors.accent}"/>`;
    defs += `<stop offset="100%" stop-color="${colors.accentBright}"/>`;
    defs += `</linearGradient>`;
  }
  if (rarity === 'epic' || rarity === 'legendary') {
    defs += `<linearGradient id="${uid}_chrome" x1="0%" y1="0%" x2="100%" y2="100%">`;
    defs += `<stop offset="0%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 85%)"/>`;
    defs += `<stop offset="30%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 55%)"/>`;
    defs += `<stop offset="50%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 90%)"/>`;
    defs += `<stop offset="70%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 50%)"/>`;
    defs += `<stop offset="100%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 80%)"/>`;
    defs += `</linearGradient>`;
  }
  if (rarity === 'legendary') {
    defs += `<filter id="${uid}_glow"><feGaussianBlur stdDeviation="2" result="blur"/>`;
    defs += `<feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>`;
    defs += `<linearGradient id="${uid}_iris" x1="0%" y1="0%" x2="100%" y2="0%">`;
    defs += `<stop offset="0%" stop-color="hsl(${colors.hue}, 100%, 70%)">`;
    defs += `<animate attributeName="stop-color" values="hsl(${colors.hue},100%,70%);hsl(${(colors.hue+120)%360},100%,70%);hsl(${(colors.hue+240)%360},100%,70%);hsl(${colors.hue},100%,70%)" dur="4s" repeatCount="indefinite"/></stop>`;
    defs += `<stop offset="50%" stop-color="hsl(${(colors.hue+60)%360}, 100%, 75%)">`;
    defs += `<animate attributeName="stop-color" values="hsl(${(colors.hue+60)%360},100%,75%);hsl(${(colors.hue+180)%360},100%,75%);hsl(${(colors.hue+300)%360},100%,75%);hsl(${(colors.hue+60)%360},100%,75%)" dur="4s" repeatCount="indefinite"/></stop>`;
    defs += `<stop offset="100%" stop-color="hsl(${(colors.hue+120)%360}, 100%, 70%)">`;
    defs += `<animate attributeName="stop-color" values="hsl(${(colors.hue+120)%360},100%,70%);hsl(${(colors.hue+240)%360},100%,70%);hsl(${colors.hue},100%,70%);hsl(${(colors.hue+120)%360},100%,70%)" dur="4s" repeatCount="indefinite"/></stop>`;
    defs += `</linearGradient>`;
  }

  function cellColor(cellType) {
    if (rarity === 'legendary') {
      if (cellType === 4) return `url(#${uid}_iris)`;
      if (cellType === 2) return `url(#${uid}_ag)`;
      if (cellType === 3) return `url(#${uid}_chrome)`;
      return `url(#${uid}_chrome)`;
    }
    if (rarity === 'epic') {
      if (cellType === 2) return `url(#${uid}_ag)`;
      if (cellType === 3) return `url(#${uid}_chrome)`;
      return `url(#${uid}_chrome)`;
    }
    if (rarity === 'rare') {
      if (cellType === 2) return `url(#${uid}_ag)`;
      return `url(#${uid}_pg)`;
    }
    if (cellType === 2) return colors.accent;
    if (cellType === 3) return colors.secondary;
    if (cellType === 4) return colors.accentBright;
    return colors.primary;
  }

  let svg = `<svg xmlns="${svgNS}" viewBox="0 0 ${size} ${size}" width="${size}" height="${size}">`;
  if (defs) svg += `<defs>${defs}</defs>`;
  svg += `<rect width="${size}" height="${size}" fill="#0a0a0a"/>`;

  if (rarity === 'legendary') {
    svg += `<rect x="2" y="2" width="${size-4}" height="${size-4}" rx="4" fill="none" stroke="url(#${uid}_iris)" stroke-width="3" opacity="0.8"/>`;
  }
  if (rarity === 'epic') {
    svg += `<rect x="3" y="3" width="${size-6}" height="${size-6}" rx="3" fill="none" stroke="url(#${uid}_chrome)" stroke-width="2" opacity="0.5"/>`;
  }
  if (rarity === 'rare') {
    svg += `<rect x="4" y="4" width="${size-8}" height="${size-8}" rx="2" fill="none" stroke="url(#${uid}_pg)" stroke-width="1.5" opacity="0.35"/>`;
  }

  if (soulbound)
    svg += `<circle cx="${size/2}" cy="${size/2}" r="${(fR + 1.5) * cs}" fill="none" stroke="#b388ff" stroke-width="1.5" opacity="0.25" stroke-dasharray="4 3"/>`;

  const glowBase = { common: 0.03, rare: 0.06, epic: 0.1, legendary: 0.15 }[rarity];
  const glowI = Math.min(0.25, glowBase + points * 0.0002);
  svg += `<circle cx="${size/2}" cy="${size/2}" r="${fR * cs}" fill="${colors.glow}" opacity="${glowI}"/>`;

  if (rarity === 'legendary') {
    svg += `<circle cx="${size/2}" cy="${size/2}" r="${(fR + 3) * cs}" fill="${colors.accent}" opacity="0.04"/>`;
  }

  if (['trader', 'oracle', 'guardian', 'operator'].includes(specialization) || rarity === 'epic' || rarity === 'legendary') {
    const gr = cs * (eyeR + 2);
    const eGlowOp = rarity === 'legendary' ? 0.2 : rarity === 'epic' ? 0.15 : 0.1;
    svg += `<circle cx="${leftEX * cs + cs/2}" cy="${eyeY * cs + cs/2}" r="${gr}" fill="${colors.accent}" opacity="${eGlowOp}"/>`;
    svg += `<circle cx="${rightEX * cs + cs/2}" cy="${eyeY * cs + cs/2}" r="${gr}" fill="${colors.accent}" opacity="${eGlowOp}"/>`;
  }

  for (let g = 0; g < Math.min(generation, 3); g++) {
    const gr = (fR + 2 + g * 0.8) * cs;
    svg += `<circle cx="${size/2}" cy="${size/2}" r="${gr}" fill="none" stroke="${colors.secondary}" stroke-width="0.5" opacity="0.15"/>`;
  }

  const legendaryEyeFilter = rarity === 'legendary' ? ` filter="url(#${uid}_glow)"` : '';
  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (!grid[y][x]) continue;
      const px = x * cs, py = y * cs;
      const color = cellColor(grid[y][x]);
      const r = cs * 0.1;
      const isEyeCell = grid[y][x] === 2 || grid[y][x] === 4;
      const filter = isEyeCell ? legendaryEyeFilter : '';
      svg += `<rect x="${px}" y="${py}" width="${cs}" height="${cs}" rx="${r}" fill="${color}"${filter}/>`;
    }
  }

  if (rarity !== 'common') {
    const badgeColor = { rare: '#4fc3f7', epic: '#ce93d8', legendary: '#ffd54f' }[rarity];
    const badgeLabel = RARITY_COLORS[rarity].label;
    svg += `<text x="${size - 6}" y="14" text-anchor="end" fill="${badgeColor}" font-family="monospace" font-size="8" font-weight="bold" opacity="0.8">${badgeLabel}</text>`;
  }

  svg += `<text x="${size/2}" y="${size - 6}" text-anchor="middle" fill="${colors.primary}" font-family="monospace" font-size="10" opacity="0.6">${name}</text>`;
  svg += `</svg>`;
  return svg;
}

// Contract setup
const CONTRACT = '0x665971e7bf8ec90c3066162c5b396604b3cd7711';
const RPCS = ['https://base.drpc.org', 'https://mainnet.base.org'];
let currentRpcIdx = 0;
const RPC = RPCS[0];

async function rpcRetry(fn, retries = 3) {
  for (let r = 0; r < retries; r++) {
    try { return await fn(); } catch(e) {
      if (r < retries - 1) {
        currentRpcIdx = (currentRpcIdx + 1) % RPCS.length;
        await new Promise(ok => setTimeout(ok, 500 * (r + 1)));
      } else throw e;
    }
  }
}

function getProvider() {
  return new ethers.JsonRpcProvider(RPCS[currentRpcIdx], undefined, { batchMaxCount: 1 });
}
const ABI = [
  "function totalAgents() view returns (uint256)",
  "function getAgent(uint256) view returns (tuple(address agentAddress, string name, string framework, uint256 mintedAt, bool verified, bool soulbound, uint256 generation, uint256 parentDNA, string currentVersion, uint256 mutationCount))",
  "function getPersonality(uint256) view returns (tuple(string temperament, string communicationStyle, uint8 riskTolerance, uint8 autonomyLevel, string alignment, string specialization))",
  "function getTraits(uint256) view returns (tuple(string name, string category, uint256 addedAt)[])",
  "function points(address) view returns (uint256)",
];
const CRED_CONTRACT = '0xc6F38c8207d19909151a5e80FB337812c3075A46';
const CRED_ABI = [
  "function getScore(uint256) view returns (uint256)",
];

function getCredTier(score) {
  if (score >= 80) return 'elite';
  if (score >= 50) return 'high';
  if (score >= 20) return 'mid';
  return 'low';
}

// Current view state
let currentView = 'grid';
let allAgents = [];

// URL parameter handling
const urlParams = new URLSearchParams(window.location.search);
const cardId = urlParams.get('id');

if (cardId !== null) {
  currentView = 'single';
  loadSingleCard(parseInt(cardId));
} else {
  loadAllCards();
}

// Load data from static JSON cache first, with RPC fallback
async function loadAllCards() {
  currentView = 'grid';
  document.getElementById('gridView').style.display = 'grid';
  document.getElementById('cardView').style.display = 'none';
  document.getElementById('viewAllBtn').style.display = 'none';
  document.getElementById('downloadBtn').style.display = 'none';
  document.getElementById('shareBtn').style.display = 'none';

  try {
    // Try loading from static JSON cache first
    const cacheResponse = await fetch('data/agents.json');
    if (cacheResponse.ok) {
      const data = await cacheResponse.json();
      loadAllFromCache(data);
      return;
    }
  } catch (e) {
    console.warn('Failed to load from cache, falling back to RPC:', e);
  }

  // Fallback to old RPC method if cache fails
  loadAllFromRPC();
}

function loadAllFromCache(data) {
  allAgents = data.agents.map(agent => ({
    id: agent.id,
    address: agent.address || agent.owner || '0x0000',
    name: agent.name,
    framework: agent.framework,
    soulbound: agent.soulbound,
    verified: agent.verified,
    mutationCount: agent.mutationCount || 0,
    traitCount: (agent.traits || []).length,
    points: agent.points || 0,
    credScore: agent.credScore || 0,
    mintedAt: agent.mintedAt,
    personality: agent.personality,
    traits: agent.traits || [],
  }));

  // Add data freshness indicator
  const updatedAt = new Date(data.updatedAt);
  const now = new Date();
  const minutesAgo = Math.floor((now - updatedAt) / 60000);
  const timeText = minutesAgo < 60 ? `${minutesAgo} minutes ago` : `${Math.floor(minutesAgo / 60)} hours ago`;
  
  const freshness = document.createElement('div');
  freshness.style.cssText = 'text-align: center; padding: 8px; color: var(--text3); font-size: 0.75rem;';
  freshness.innerHTML = `üìä Data updated ${timeText}`;
  document.body.appendChild(freshness);

  renderGrid();
}

// Fallback RPC loading (keeping original as fallback)
async function loadAllFromRPC() {
  try {
    const provider = getProvider();
    const contract = new ethers.Contract(CONTRACT, ABI, provider);

    const total = Number(await contract.totalAgents());
    allAgents = [];

    for (let i = 0; i < total; i++) {
      try {
        const agent = await contract.getAgent(i);
        const personality = await contract.getPersonality(i).catch(() => null);
        const traits = await contract.getTraits(i).catch(() => []);
        const points = Number(await contract.points(agent.agentAddress));
        
        allAgents.push({
          id: i,
          address: agent.agentAddress,
          name: agent.name,
          framework: agent.framework,
          soulbound: agent.soulbound,
          verified: agent.verified,
          mutationCount: Number(agent.mutationCount || 0),
          traitCount: traits.length,
          points: points,
          mintedAt: Number(agent.mintedAt),
          personality,
          traits,
        });
      } catch (e) { console.error('Agent #' + i, e); }
    }

    renderGrid();
  } catch (e) {
    document.getElementById('gridView').innerHTML = '<div class="loading">Failed to load cards: ' + e.message + '</div>';
    console.error(e);
  }
}

function renderGrid() {
  const gridView = document.getElementById('gridView');
  
  if (allAgents.length === 0) {
    gridView.innerHTML = '<div class="loading">No agents found</div>';
    return;
  }

  gridView.innerHTML = allAgents.map(agent => {
    const rarity = getRarity(agent.points, agent.mutationCount);
    const auraData = {
      agentAddress: agent.address,
      name: agent.name,
      framework: agent.framework,
      mutationCount: agent.mutationCount,
      points: agent.points,
      soulbound: agent.soulbound,
      traitCount: agent.traitCount,
      temperament: agent.personality ? agent.personality.temperament : 'analytical',
      communicationStyle: agent.personality ? agent.personality.communicationStyle : 'formal',
      riskTolerance: agent.personality ? Number(agent.personality.riskTolerance) : 5,
      autonomyLevel: agent.personality ? Number(agent.personality.autonomyLevel) : 5,
      alignment: agent.personality ? agent.personality.alignment : 'true-neutral',
      specialization: agent.personality ? agent.personality.specialization : 'researcher',
      generation: 0,
    };

    const auraSvg = generateAura(auraData, 200);
    
    return `
      <div class="mini-card" onclick="viewCard(${agent.id})">
        <div class="mini-aura">${auraSvg}</div>
        <div class="mini-info">
          <div class="mini-name">${agent.name} ${agent.verified ? '‚úì' : ''}</div>
          <div class="mini-meta">#${agent.id} ¬∑ Cred ${agent.credScore || 0}</div>
        </div>
        <div class="mini-rarity rarity-${rarity}">${rarity.charAt(0).toUpperCase() + rarity.slice(1)}</div>
      </div>
    `;
  }).join('');
}

// Load single card data from static JSON cache first, with RPC fallback
async function loadSingleCard(agentId) {
  currentView = 'single';
  document.getElementById('gridView').style.display = 'none';
  document.getElementById('cardView').style.display = 'flex';
  document.getElementById('viewAllBtn').style.display = 'inline-block';
  document.getElementById('downloadBtn').style.display = 'inline-block';
  document.getElementById('shareBtn').style.display = 'inline-block';

  try {
    // Try loading from static JSON cache first
    const cacheResponse = await fetch('data/agents.json');
    if (cacheResponse.ok) {
      const data = await cacheResponse.json();
      const agent = data.agents.find(a => a.id === agentId);
      if (agent) {
        loadSingleFromCache(agent, data.updatedAt);
        return;
      }
    }
  } catch (e) {
    console.warn('Failed to load from cache, falling back to RPC:', e);
  }

  // Fallback to old RPC method if cache fails
  loadSingleFromRPC(agentId);
}

function loadSingleFromCache(agent, updatedAt) {
  const agentData = {
    id: agent.id,
    address: agent.address || agent.owner || '0x0000000000000000000000000000000000000000',
    name: agent.name,
    framework: agent.framework,
    soulbound: agent.soulbound,
    verified: agent.verified,
    mutationCount: agent.mutationCount || 0,
    traitCount: (agent.traits || []).length,
    points: agent.points || 0,
    credScore: agent.credScore || 0,
    mintedAt: agent.mintedAt,
    currentVersion: agent.version || agent.currentVersion || '1.0',
    generation: agent.generation || 0,
    personality: agent.personality,
    traits: agent.traits || [],
  };

  // Add data freshness indicator
  const updatedAtDate = new Date(updatedAt);
  const now = new Date();
  const minutesAgo = Math.floor((now - updatedAtDate) / 60000);
  const timeText = minutesAgo < 60 ? `${minutesAgo} minutes ago` : `${Math.floor(minutesAgo / 60)} hours ago`;
  
  const freshness = document.createElement('div');
  freshness.style.cssText = 'text-align: center; padding: 8px; color: var(--text3); font-size: 0.75rem;';
  freshness.innerHTML = `üìä Data updated ${timeText}`;
  document.body.appendChild(freshness);

  renderCard(agentData);
}

// Fallback RPC loading (keeping original as fallback)
async function loadSingleFromRPC(agentId) {
  try {
    const provider = getProvider();
    const contract = new ethers.Contract(CONTRACT, ABI, provider);

    const agent = await contract.getAgent(agentId);
    const personality = await contract.getPersonality(agentId).catch(() => null);
    const traits = await contract.getTraits(agentId).catch(() => []);
    const points = Number(await contract.points(agent.agentAddress));
    
    const credContract = new ethers.Contract(CRED_CONTRACT, CRED_ABI, provider);
    const credScore = Number(await credContract.getScore(agentId).catch(() => 0));

    const agentData = {
      id: agentId,
      address: agent.agentAddress,
      name: agent.name,
      framework: agent.framework,
      soulbound: agent.soulbound,
      verified: agent.verified,
      mutationCount: Number(agent.mutationCount || 0),
      traitCount: traits.length,
      points: points,
      credScore: credScore,
      mintedAt: Number(agent.mintedAt),
      currentVersion: agent.currentVersion,
      generation: agent.parentDNA > 0 ? 1 : 0,
      personality,
      traits,
    };

    renderCard(agentData);
  } catch (e) {
    document.getElementById('tradingCard').innerHTML = '<div class="loading">Failed to load card: ' + e.message + '</div>';
    console.error(e);
  }
}

function renderCard(agent) {
  const rarity = getRarity(agent.points, agent.mutationCount);
  
  const auraData = {
    agentAddress: agent.address,
    name: agent.name,
    framework: agent.framework,
    mutationCount: agent.mutationCount,
    points: agent.points,
    soulbound: agent.soulbound,
    traitCount: agent.traitCount,
    temperament: agent.personality ? agent.personality.temperament : 'analytical',
    communicationStyle: agent.personality ? agent.personality.communicationStyle : 'formal',
    riskTolerance: agent.personality ? Number(agent.personality.riskTolerance) : 5,
    autonomyLevel: agent.personality ? Number(agent.personality.autonomyLevel) : 5,
    alignment: agent.personality ? agent.personality.alignment : 'true-neutral',
    specialization: agent.personality ? agent.personality.specialization : 'researcher',
    generation: agent.generation,
  };

  const auraSvg = generateAura(auraData, 400);
  
  // Format date
  const mintedDate = new Date(agent.mintedAt * 1000).toLocaleDateString();
  
  // Truncate address
  const shortAddress = `${agent.address.slice(0, 6)}...${agent.address.slice(-4)}`;

  // Framework type colors
  const frameworkColors = {
    eliza: 'type-eliza',
    openclaw: 'type-openclaw', 
    langchain: 'type-langchain',
    crewai: 'type-crewai',
    autogpt: 'type-autogpt',
    custom: 'type-custom'
  };

  const card = document.getElementById('tradingCard');
  card.className = `trading-card ${rarity}`;
  
  const credScore = agent.credScore || 0;
  const credTier = getCredTier(credScore);

  card.innerHTML = `
    <div class="cred-badge cred-${credTier}">
      <span class="cred-number">${credScore}</span>
      <span class="cred-label">Cred</span>
    </div>
    <div class="card-token-id">#${agent.id.toString().padStart(3, '0')}</div>
    
    <div class="card-header">
      <div class="card-name">${agent.name}</div>
      <div class="card-hp">${agent.points} pts</div>
    </div>

    <div class="card-artwork">
      <div class="aura-container">${auraSvg}</div>
      <div class="card-rarity-badge rarity-${rarity}">${rarity.charAt(0).toUpperCase() + rarity.slice(1)}</div>
    </div>

    <div class="card-type-bar">
      <span class="type-pill ${frameworkColors[agent.framework] || 'type-custom'}">${agent.framework}</span>
      ${agent.personality ? `<span class="type-pill" style="background: rgba(255,255,255,0.1); color: var(--text2);">${agent.personality.specialization}</span>` : ''}
      ${agent.verified ? '<span class="verified-badge">‚úì</span>' : ''}
      ${agent.soulbound ? '<span class="soulbound-badge">üîí</span>' : ''}
    </div>

    <div class="card-stats">
      <h3>Agent Stats</h3>
      <div class="stat-row">
        <span>Risk Tolerance</span>
        <div class="stat-bar"><div class="stat-fill" style="width: ${(agent.personality ? agent.personality.riskTolerance : 5) * 10}%"></div></div>
        <span>${agent.personality ? agent.personality.riskTolerance : 5}/10</span>
      </div>
      <div class="stat-row">
        <span>Autonomy Level</span>
        <div class="stat-bar"><div class="stat-fill" style="width: ${(agent.personality ? agent.personality.autonomyLevel : 5) * 10}%"></div></div>
        <span>${agent.personality ? agent.personality.autonomyLevel : 5}/10</span>
      </div>
      <div class="stat-row">
        <span>Mutations</span>
        <span></span>
        <span>${agent.mutationCount}</span>
      </div>
      <div class="stat-row">
        <span>Generation</span>
        <span></span>
        <span>${agent.generation}</span>
      </div>
      <div class="stat-row">
        <span>Trait Count</span>
        <span></span>
        <span>${agent.traitCount}</span>
      </div>
    </div>

    ${agent.traits && agent.traits.length > 0 ? `
    <div class="card-moves">
      <h3>Traits</h3>
      ${agent.traits.slice(0, 4).map(trait => `
        <div class="move-item">
          <span class="move-name">${trait.name}</span>
          <span class="move-type" style="background: rgba(255,255,255,0.1); color: var(--text3);">${trait.category}</span>
        </div>
      `).join('')}
      ${agent.traits.length > 4 ? `<div style="text-align: center; font-size: 0.65rem; color: var(--text3); margin-top: 4px;">+${agent.traits.length - 4} more traits</div>` : ''}
    </div>
    ` : ''}

    ${agent.personality ? `
    <div class="personality-bar">
      <span class="personality-tag personality-${agent.personality.temperament}">${agent.personality.temperament}</span>
      <span class="personality-tag personality-${agent.personality.communicationStyle}">${agent.personality.communicationStyle}</span>
      <span class="personality-tag personality-${agent.personality.alignment}">${agent.personality.alignment}</span>
    </div>
    ` : ''}

    <div class="card-footer">
      <div class="address">${shortAddress}</div>
      <div>Minted ${mintedDate}</div>
      <div>Version ${agent.currentVersion || '1.0'}</div>
      <div class="helixa-brand">
        <strong>HELIXA</strong> ¬∑ ERC-8004 on Base
      </div>
    </div>
  `;
}

function viewCard(agentId) {
  const url = new URL(window.location);
  url.searchParams.set('id', agentId);
  window.history.pushState({}, '', url);
  loadSingleCard(agentId);
}

// Download functionality
document.getElementById('downloadBtn').addEventListener('click', async () => {
  const card = document.getElementById('tradingCard');
  try {
    const canvas = await html2canvas(card, {
      backgroundColor: '#080612',
      scale: 2,
      width: card.offsetWidth,
      height: card.offsetHeight,
    });
    
    const link = document.createElement('a');
    link.download = `helixa-agent-${urlParams.get('id')}-card.png`;
    link.href = canvas.toDataURL();
    link.click();
  } catch (e) {
    console.error('Download failed:', e);
    alert('Download failed. Please try again.');
  }
});

// Share functionality  
document.getElementById('shareBtn').addEventListener('click', () => {
  const url = window.location.href;
  if (navigator.share) {
    navigator.share({
      title: 'Helixa Agent Trading Card',
      url: url
    });
  } else {
    navigator.clipboard.writeText(url).then(() => {
      alert('Card link copied to clipboard!');
    });
  }
});
</script>

</body>
</html>