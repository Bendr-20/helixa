import{aR as Y,j as e}from"./vendor-wallet-iWeBopzN.js";import{F as z}from"./CheckCircleIcon-DANTQeuo.js";import{r}from"./vendor-react-NLnOsXgy.js";import{c as J,n as X,s as Z}from"./Layouts-BlFm53ED-DLKEyb6e.js";import{u as U}from"./ModalHeader-D8-mhjp4-B2mPQY48.js";import{o as ee}from"./ScreenHeader-CHmc4-Lu-BZhpbO35.js";import{t as b}from"./FundWalletMethodHeader-Cfci4-83-Cula454a.js";import{t as ne}from"./index-Dq_xe9dz-DCDZnyX3.js";import{r as j,I as te,a as ae,as as re,_ as s,at as se,au as R,O as oe,av as W,aw as I,E as m,f as ie}from"./index-CPsDcot4.js";import{t as de}from"./analytics-mkkvFRju-DOXuftJB.js";import{u as le,o as ce,f as ue,n as me,s as fe,r as pe}from"./reservoir-0wfhnc0j-Coa99o8p.js";import{I as ge}from"./TransferOrBridgeLoadingScreen-DcCdHB-g-CI6yKJhd.js";import"./InjectedWalletIcon-DLcYOGDj-5VUxgLWA.js";import"./WalletIcon-BrbXK2eY.js";import"./Value-tcJV9e0L-BTeto94e.js";import"./LoadingSkeleton-U6-3yFwI-Cep8vPp-.js";import"./Address-BjZb-TIL-OzuyVM_I.js";import"./check-B9ysh8c4.js";import"./createLucideIcon-4wkIQryq.js";import"./copy-BmDK-JXv.js";import"./GlobeAltIcon-kW1lCngP.js";const Pe={component:function(){let D=j(),{closePrivyModal:B,createAnalyticsEvent:P,connectors:C}=te(),{navigate:_,setModalData:k,data:o}=ae(),x=j(),y=r.useRef(!1),E=re(),[$,h]=r.useState(!1),[w,L]=r.useState(!1),[v,d]=r.useState(null),[M,O]=r.useState(),[q,F]=r.useState();if(!o?.funding||o.funding.chainType!=="ethereum")throw Error("Invalid funding data");let{amount:f,connectedWallet:p,chain:l,solanaChain:H,isUSDC:g}=o.funding,S=o.funding.address,G=o.funding.erc20Address,A=o.funding.isUSDC?"USDC":l.nativeCurrency.symbol,t=r.useMemo((()=>p?.type==="solana"?p.provider:(function({connectors:n,connectedWalletAddress:i}){let c=n.find((a=>a.chainType==="solana"&&a.wallets.some((T=>T.address===i)))),u=c?.wallet.accounts.find((a=>a.address===i));if(!c||!u)throw new s("Unable to find source wallet connector");return new se({wallet:c.wallet,account:u})})({connectors:C,connectedWalletAddress:p?.address||""})),[p,C]),N=r.useMemo((()=>{let n=E(R);if(!n)throw new s("Unable to load solana plugin");let i=D.solanaRpcs["solana:mainnet"];if(!i)throw new s("Unable to load mainnet RPC");return n.getSolanaRpcClient({rpc:i.rpc,rpcSubscriptions:i.rpcSubscriptions,chain:"solana:mainnet",blockExplorerUrl:i.blockExplorerUrl??"https://explorer.solana.com"})}),[]),K=oe(W(t?.standardWallet.name||"unknown")),Q=K?.name||"wallet";return r.useEffect((()=>{(async function(){if(!t||!l||y.current)return;let n=E(R);if(!n)return void d(new s("Unable to solana plugin"));y.current=!0,l?.testnet&&console.warn("Solana testnets are not supported for bridging");let i=g?1e6*parseFloat(f):Y(f),c=await le({isTestnet:!!l.testnet,input:ce({appId:x.id,amount:i.toString(),user:t.address,recipient:S,destinationChainId:l.id,originChainId:pe,originCurrency:g?me:fe,destinationCurrency:g?G:void 0})}).catch(console.error);if(!c)return void d(new s(`Unable to fetch quotes for bridging. Wallet ${I(t.address)} does not have enough funds.`,void 0,m.INSUFFICIENT_BALANCE));let u=await n.createTransactionFromRelayQuote({quote:c,source:t.address,solanaClient:N});if(u)try{h(!0);let a=await n.simulateTransaction({solanaClient:N,tx:u});if(a.hasError)return a.hasFunds?(console.error("Transaction failed:",a.error),void d(new s("Something went wrong",void 0,m.TRANSACTION_FAILURE))):void d(new s(`Wallet ${I(t?.address)} does not have enough funds. ${c.details.currencyIn.amountFormatted} ${A} are needed to complete the transaction.`,void 0,m.INSUFFICIENT_BALANCE));let{signature:T}=await t.signAndSendTransaction({chain:"solana:mainnet",transaction:u}),V=n.getAddressFromBuffer(T);O(V),F("pending")}catch(a){if(console.error(a),/user rejected the request/gi.test(a.message||""))return void d(new s("Transaction was rejected by the user",void 0,m.TRANSACTION_FAILURE));d(new s("Something went wrong",void 0,m.TRANSACTION_FAILURE))}else d(new s(`Unable to select bridge option from quotes. Wallet ${I(t.address)} does not have enough funds.`,void 0,m.INSUFFICIENT_BALANCE))})().catch(console.error)}),[]),ue({transactionHash:M,isTestnet:!1,bridgingStatus:q,setBridgingStatus:F,onSuccess({transactionHash:n}){h(!1),L(!0),P({eventName:de,payload:{provider:"external",status:"success",txHash:n,address:t.address,chainType:"solana",clusterName:H,token:"SOL",destinationAddress:S,destinationChainId:l.id,destinationChainType:"ethereum",destinationValue:f,destinationToken:g?"USDC":"ETH"}})},onFailure({error:n}){h(!1),d(n)}}),r.useEffect((()=>{if(!w)return;let n=setTimeout(B,ie);return()=>clearTimeout(n)}),[w]),r.useEffect((()=>{v&&(k({funding:o?.funding,solanaFundingData:o?.solanaFundingData,sendTransaction:o?.sendTransaction,errorModalData:{error:v,previousScreen:"TransferFromWalletScreen"}}),_("ErrorScreen",!1))}),[v]),w?e.jsxs(e.Fragment,{children:[e.jsx(b,{}),e.jsx(J,{}),e.jsxs(X,{children:[e.jsx(z,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),e.jsx(ee,{title:"Success!",description:`Youâ€™ve successfully added ${f} ${A} to your ${x.name} wallet. It may take a minute before the funds are available to use.`})]}),e.jsx(Z,{}),e.jsx(U,{})]}):$&&t?e.jsx(ge,{walletClientType:W(t?.standardWallet.name||"unknown"),displayName:Q,addressToFund:S,isBridging:$,isErc20Flow:!1,chainId:l.id,chainName:l.name,totalPriceInUsd:void 0,totalPriceInNativeCurrency:void 0,gasPriceInUsd:void 0,gasPriceInNativeCurrency:void 0}):e.jsxs(e.Fragment,{children:[e.jsx(b,{}),e.jsx(ne,{}),e.jsx("div",{style:{marginTop:"1rem"}}),e.jsx(U,{})]})}};export{Pe as AwaitingSolToEvmBridgingScreen,Pe as default};
