import{E as at,j as h}from"./vendor-wallet-iWeBopzN.js";import{F as st}from"./CheckCircleIcon-DANTQeuo.js";import{r as y}from"./vendor-react-NLnOsXgy.js";import{u as ye,m as it}from"./ModalHeader-D8-mhjp4-CBGEEg4H.js";import{c as rt,n as ot,s as ct,t as lt}from"./Layouts-BlFm53ED-CF08vAtW.js";import{o as Me}from"./ScreenHeader-CHmc4-Lu-CUCn2jPi.js";import{t as ve}from"./FundWalletMethodHeader-Cfci4-83-CcCtuSGF.js";import{i as dt}from"./InjectedWalletIcon-DLcYOGDj-5VUxgLWA.js";import{t as ut}from"./index-Dq_xe9dz-B0OAFBnJ.js";import{t as gt,s as pt,e as ft,n as ht}from"./Value-tcJV9e0L-BNQ3Sj-b.js";import{I as K,at as mt,bD as wt,n as At,H as me,r as Ye,a as we,bE as xe,_ as P,E as $,bF as Ce,bB as Fe,bG as yt,bH as vt,bI as bt,bJ as He,bK as Ke,bL as be,bM as St,bN as Tt,bO as Oe,bP as It,bQ as Et,bR as Ot,bS as jt,bT as Ue,bU as Wt,bV as xt,av as Pe,bW as $e,bX as De,bY as Ct,bZ as Ne,f as Ft,b_ as Le,b$ as Se,c0 as Be,c1 as Re,c2 as _t}from"./index-fmvwrtqe.js";import{d as Je,f as he,c as Mt,u as Ut,p as Pt,l as fe}from"./useSolanaRpcClient-BUWOblv_-DvZsmdrX.js";import{c as $t}from"./useGetTokenPrice-BPBpM07F-C6FwOPxp.js";import{t as Dt}from"./analytics-mkkvFRju-DOXuftJB.js";import{C as pe,e as ke,s as Nt}from"./getFormattedUsdFromLamports-B6EqSEho-C-HCdwKa.js";import{r as Lt}from"./getUsdcMintAddress-DFI1hv05-jlhpBW9a.js";import{e as Bt}from"./getChainName-DjpPdUSc-c2urPd0g.js";import{n as Te}from"./formatters-DwTIoOJg.js";import"./WalletIcon-BrbXK2eY.js";import"./LoadingSkeleton-U6-3yFwI-Bn1zWcgJ.js";import"./useGetSolPrice-DwwjjGbd-DvFS2uiC.js";const ze=()=>{let{walletProxy:e,client:n}=K();return y.useMemo((()=>({signWithUserSigner:async({message:a,targetAppId:c})=>{if(!e)throw Error("Wallet proxy not initialized");let d=await n.getAccessToken();if(!d)throw Error("User must be authenticated");let{signature:o}=await e.signWithUserSigner({accessToken:d,message:a,targetAppId:c});return{signature:o}}})),[e,n])},Ze=["solana:mainnet","solana:devnet","solana:testnet"];function Rt(e){return wt().decode(e)}function z(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var kt=0,D="__private_"+kt+++"__implementation";function U(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var Vt=0;function J(e){return"__private_"+Vt+++"_"+e}var Z=J("_address"),q=J("_publicKey"),X=J("_chains"),ee=J("_features"),te=J("_label"),ne=J("_icon");class _e{get address(){return U(this,Z)[Z]}get publicKey(){return U(this,q)[q].slice()}get chains(){return U(this,X)[X].slice()}get features(){return U(this,ee)[ee].slice()}get label(){return U(this,te)[te]}get icon(){return U(this,ne)[ne]}constructor({address:n,publicKey:a,label:c,icon:d}){Object.defineProperty(this,Z,{writable:!0,value:void 0}),Object.defineProperty(this,q,{writable:!0,value:void 0}),Object.defineProperty(this,X,{writable:!0,value:void 0}),Object.defineProperty(this,ee,{writable:!0,value:void 0}),Object.defineProperty(this,te,{writable:!0,value:void 0}),Object.defineProperty(this,ne,{writable:!0,value:void 0}),U(this,Z)[Z]=n,U(this,q)[q]=a,U(this,X)[X]=Ze,U(this,te)[te]=c,U(this,ne)[ne]=d,U(this,ee)[ee]=["solana:signAndSendTransaction","solana:signTransaction","solana:signMessage"],new.target===_e&&Object.freeze(this)}}function s(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var Gt=0;function S(e){return"__private_"+Gt+++"_"+e}var F=S("_listeners"),ae=S("_version"),se=S("_name"),ie=S("_icon"),E=S("_injection"),re=S("_isPrivyWallet"),Q=S("_accounts"),oe=S("_on"),Y=S("_emit"),Ie=S("_off"),H=S("_connected"),ce=S("_connect"),le=S("_disconnect"),de=S("_signMessage"),ue=S("_signAndSendTransaction"),ge=S("_signTransaction");function Qt(e,...n){s(this,F)[F][e]?.forEach((a=>a.apply(null,n)))}function Yt(e,n){s(this,F)[F][e]=s(this,F)[F][e]?.filter((a=>n!==a))}function Ht(e,n,a){let c=structuredClone(St().decode(e)),d=Tt(n);return d in c.signatures&&(c.signatures[d]=a),new Uint8Array(Oe().encode(c))}function qe(){let{isHeadlessSigning:e,walletProxy:n,initializeWalletProxy:a,recoverEmbeddedWallet:c,openModal:d,privy:o,client:i}=K(),{user:t}=me(),{setModalData:r}=we(),{signWithUserSigner:u}=ze();return{signMessage:({message:l,address:w,options:T})=>new Promise((async(N,O)=>{let f=xe(t,w);if(f?.walletClientType!=="privy")return void O(new P("Wallet is not a Privy wallet",void 0,$.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:A,entropyIdVerifier:b}=Fe(t,f),I=Ce(f),m=he(l).toString("base64");if(m.length<1)return void O(new P("Message must be a non-empty string",void 0,$.INVALID_MESSAGE));let x=async()=>{let p;if(!t)throw Error("User must be authenticated before signing with a Privy wallet");let _=await i.getAccessToken();if(!_)throw Error("User must be authenticated to use their embedded wallet.");let C=n??await a(15e3);if(!C)throw Error("Failed to initialize embedded wallet proxy.");if(!await c({address:f.address}))throw Error("Unable to connect to wallet");if(I){let M=await He(o,u,{chain_type:"solana",method:"signMessage",params:{message:m,encoding:"base64"},wallet_id:f.id});if(!M.data||!("signature"in M.data))throw Error("Failed to sign message");p=M.data.signature}else{let{response:M}=await C.rpc({accessToken:_,entropyId:A,entropyIdVerifier:b,chainType:"solana",hdWalletIndex:f.walletIndex??0,requesterAppId:T?.uiOptions?.requesterAppId,request:{method:"signMessage",params:{message:m}}});p=M.data.signature}return p};if(e({showWalletUIs:T?.uiOptions?.showWalletUIs}))try{let p=await x(),_=new Uint8Array(he(p,"base64"));N({signature:_})}catch(p){O(p)}else r({signMessage:{method:"solana_signMessage",data:m,confirmAndSign:x,onSuccess:p=>{N({signature:new Uint8Array(he(p,"base64"))})},onFailure:p=>{O(p)},uiOptions:T?.uiOptions??{}},connectWallet:{recoveryMethod:f.recoveryMethod,connectingWalletAddress:f.address,entropyId:A,entropyIdVerifier:b,isUnifiedWallet:I,onCompleteNavigateTo:"SignRequestScreen",onFailure:p=>{O(new P("Failed to connect to wallet",p,$.UNKNOWN_CONNECT_WALLET_ERROR))}}}),d("EmbeddedWalletConnectingScreen")}))}}function Ve(){let{isHeadlessSigning:e,openModal:n}=K(),{setModalData:a}=we(),{signMessage:c}=qe(),{user:d}=me();return{signTransaction:async({transaction:o,options:i,chain:t="solana:mainnet",address:r})=>{async function u(l){let{signature:w}=await c({message:Mt(l),address:r,options:{...i,uiOptions:{...i?.uiOptions,showWalletUIs:!1}}});return{signedTransaction:Ht(l,r,w)}}return e({showWalletUIs:i?.uiOptions?.showWalletUIs})?u(o):new Promise((async(l,w)=>{let T=xe(d,r);if(T?.walletClientType!=="privy")return void w(new P("Wallet is not a Privy wallet",void 0,$.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:N,entropyIdVerifier:O}=Fe(d,T),f=Ce(T);function A(I){return m=>{w(m instanceof P?m:new P("Failed to connect to wallet",m,I))}}let b={account:T,transaction:o,chain:t,signOnly:!0,uiOptions:i?.uiOptions||{},onConfirm:u,onSuccess:l,onFailure:A($.TRANSACTION_FAILURE)};a({connectWallet:{recoveryMethod:T.recoveryMethod,connectingWalletAddress:T.address,entropyId:N,entropyIdVerifier:O,isUnifiedWallet:f,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:A($.UNKNOWN_CONNECT_WALLET_ERROR)},standardSignAndSendTransaction:b}),n("EmbeddedWalletConnectingScreen")}))}}}let je=new class extends at{setImplementation(e){z(this,D)[D]=e}async signMessage(e){return z(this,D)[D].signMessage(e)}async signAndSendTransaction(e){return z(this,D)[D].signAndSendTransaction(e)}async signTransaction(e){return z(this,D)[D].signTransaction(e)}constructor(e){super(),Object.defineProperty(this,D,{writable:!0,value:void 0}),z(this,D)[D]=e}}({signTransaction:be("signTransaction was not injected"),signAndSendTransaction:be("signAndSendTransaction was not injected"),signMessage:be("signMessage was not injected")}),Ge=new class{get version(){return s(this,ae)[ae]}get name(){return s(this,se)[se]}get icon(){return s(this,ie)[ie]}get chains(){return Ze.slice()}get features(){return{"standard:connect":{version:"1.0.0",connect:s(this,ce)[ce]},"standard:disconnect":{version:"1.0.0",disconnect:s(this,le)[le]},"standard:events":{version:"1.0.0",on:s(this,oe)[oe]},"solana:signAndSendTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signAndSendTransaction:s(this,ue)[ue]},"solana:signTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signTransaction:s(this,ge)[ge]},"solana:signMessage":{version:"1.0.0",signMessage:s(this,de)[de]},"privy:":{privy:{signMessage:s(this,E)[E].signMessage,signTransaction:s(this,E)[E].signTransaction,signAndSendTransaction:s(this,E)[E].signAndSendTransaction}}}}get accounts(){return s(this,Q)[Q].slice()}get isPrivyWallet(){return s(this,re)[re]}constructor({name:e,icon:n,version:a,injection:c,wallets:d}){Object.defineProperty(this,Y,{value:Qt}),Object.defineProperty(this,Ie,{value:Yt}),Object.defineProperty(this,F,{writable:!0,value:void 0}),Object.defineProperty(this,ae,{writable:!0,value:void 0}),Object.defineProperty(this,se,{writable:!0,value:void 0}),Object.defineProperty(this,ie,{writable:!0,value:void 0}),Object.defineProperty(this,E,{writable:!0,value:void 0}),Object.defineProperty(this,re,{writable:!0,value:void 0}),Object.defineProperty(this,Q,{writable:!0,value:void 0}),Object.defineProperty(this,oe,{writable:!0,value:void 0}),Object.defineProperty(this,H,{writable:!0,value:void 0}),Object.defineProperty(this,ce,{writable:!0,value:void 0}),Object.defineProperty(this,le,{writable:!0,value:void 0}),Object.defineProperty(this,de,{writable:!0,value:void 0}),Object.defineProperty(this,ue,{writable:!0,value:void 0}),Object.defineProperty(this,ge,{writable:!0,value:void 0}),s(this,F)[F]={},s(this,oe)[oe]=(o,i)=>(s(this,F)[F][o]?.push(i)||(s(this,F)[F][o]=[i]),()=>s(this,Ie)[Ie](o,i)),s(this,H)[H]=o=>{o!=null&&(s(this,Q)[Q]=o.map((({address:i})=>new _e({address:i,publicKey:Ke.decode(i)})))),s(this,Y)[Y]("change",{accounts:this.accounts})},s(this,ce)[ce]=async()=>(s(this,Y)[Y]("change",{accounts:this.accounts}),{accounts:this.accounts}),s(this,le)[le]=async()=>{s(this,Y)[Y]("change",{accounts:this.accounts})},s(this,de)[de]=async(...o)=>{let i=[];for(let{account:t,...r}of o){let{signature:u}=await s(this,E)[E].signMessage({...r,address:t.address});i.push({signedMessage:r.message,signature:u})}return i},s(this,ue)[ue]=async(...o)=>{let i=[];for(let t of o){let{signature:r}=await s(this,E)[E].signAndSendTransaction({...t,transaction:t.transaction,address:t.account.address,chain:t.chain||"solana:mainnet",options:t.options});i.push({signature:r})}return i},s(this,ge)[ge]=async(...o)=>{let i=[];for(let{transaction:t,account:r,options:u,chain:l}of o){let{signedTransaction:w}=await s(this,E)[E].signTransaction({transaction:t,address:r.address,chain:l||"solana:mainnet",options:u});i.push({signedTransaction:w})}return i},s(this,se)[se]=e,s(this,ie)[ie]=n,s(this,ae)[ae]=a,s(this,E)[E]=c,s(this,Q)[Q]=[],s(this,re)[re]=!0,c.on("accountChanged",s(this,H)[H],this),s(this,H)[H](d)}}({name:"Privy",version:"1.0.0",icon:"data:image/png;base64,AAABAAEAFBQAAAAAIABlAQAAFgAAAIlQTkcNChoKAAAADUlIRFIAAAAUAAAAFAgGAAAAjYkdDQAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAQVJREFUeJxiYMANZIC4E4ivAPFPIP4FxDeAuB+IlfDowwBMQFwJxF+B+D8O/AOI66Bq8QJGIF6ExyB0vAqImfEZmEeCYTDcgMswPiB+T4aB34FYApuBsWQYBsP52AycToGBK7EZuJECAw9jM3AVBQbuwWZgIwUGTsZmoDkFBnpiMxAEjpJh2FV8iVsbiD+TYBgoDVrgMgwGnID4HRGGgTKBGyHDYEAaiBdCSxh0g/5AU4Q8sYYhAzEgjoGmABBOgFo2eACowFABYn0oVgViAVINkQTiZUD8DIj/ATF6GILEXgLxCiCWIsZAbiAuBeKtQHwHiEHJ6C8UfwHie0C8E4jLoWpRAAAAAP//rcbhsQAAAAZJREFUAwBYFs3VKJ0cuQAAAABJRU5ErkJggg==",wallets:[],injection:je});function Kt(){let{ready:e}=At(),{user:n}=me(),{signMessage:a}=qe(),{signTransaction:c}=Ve(),{signAndSendTransaction:d}=(function(){let t=Ye(),{isHeadlessSigning:r,openModal:u,privy:l}=K(),{setModalData:w}=we(),{signTransaction:T}=Ve(),N=Je(),{user:O}=me(),{signWithUserSigner:f}=ze();return{signAndSendTransaction:async({transaction:A,address:b,chain:I="solana:mainnet",options:m})=>{let x=xe(O,b);if(x?.walletClientType!=="privy")throw new P("Wallet is not a Privy wallet",void 0,$.EMBEDDED_WALLET_NOT_FOUND);let p=Ce(x);async function _(C){if(m?.sponsor)return await(async v=>{if(!p)throw new P("Sponsoring transactions is only supported for wallets on the TEE stack",$.INVALID_DATA);let j=await He(l,f,{chain_type:"solana",method:"signAndSendTransaction",sponsor:!0,params:{transaction:he(v).toString("base64"),encoding:"base64"},caip2:`solana:${(await N(I).rpc.getGenesisHash().send()).substring(0,32)}`,wallet_id:x.id});if(j.data&&"hash"in j.data)return{signature:Ke.decode(j.data.hash)};throw Error("Failed to sign and send transaction")})(C);let{signedTransaction:M}=await T({transaction:C,address:b,chain:I,options:{...m,uiOptions:{...m?.uiOptions,showWalletUIs:!1}}}),{signature:g}=await N(I).sendAndConfirmTransaction(M);return{signature:g}}return r({showWalletUIs:m?.uiOptions?.showWalletUIs})?_(A):new Promise((async(C,M)=>{let g,v,{entropyId:j,entropyIdVerifier:R}=Fe(O,x);function k(G){return W=>{M(W instanceof P?W:new P("Failed to connect to wallet",W,G))}}let L={account:x,transaction:A,chain:I,signOnly:!1,uiOptions:m?.uiOptions||{},onConfirm:_,onSuccess:C,onFailure:k($.TRANSACTION_FAILURE),isSponsored:!!m?.sponsor},V={recoveryMethod:x.recoveryMethod,connectingWalletAddress:x.address,entropyId:j,entropyIdVerifier:R,isUnifiedWallet:p,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:k($.UNKNOWN_CONNECT_WALLET_ERROR)};t.fundingConfig&&(g=yt({address:b,appConfig:t,methodScreen:"FundingMethodSelectionScreen",fundWalletConfig:{...m,asset:"native-currency",chain:I},externalSolanaFundingScreen:"FundSolWalletWithExternalSolanaWallet"}),v={amount:t.fundingConfig.defaultRecommendedAmount,asset:"SOL",chain:I,destinationAddress:b,afterSuccessScreen:"StandardSignAndSendTransactionScreen",sourceWalletData:void 0}),w({connectWallet:V,standardSignAndSendTransaction:L,funding:g,solanaFundingData:v}),u("EmbeddedWalletConnectingScreen")}))}}})(),o=y.useMemo((()=>{let t=[...vt(n).sort(((u,l)=>(u.walletIndex??0)-(l.walletIndex??0)))],r=bt(n);return r.length?[...t,...r]:t}),[n]),i=y.useMemo((()=>({signMessage:async({message:t,address:r,options:u})=>await a({message:t,address:r,options:u}),signTransaction:async({transaction:t,address:r,chain:u,options:l})=>await c({transaction:t,address:r,chain:u,options:l}),async signAndSendTransaction({transaction:t,address:r,chain:u,options:l}){let{signature:w}=await d({transaction:t,address:r,chain:u,options:l});return{signature:w}}})),[a,c,d]);return y.useEffect((()=>{je?.setImplementation(i)}),[i]),y.useEffect((()=>{var t;!e||(t=Ge.accounts).length===o.length&&t.every(((r,u)=>r.address===o[u]?.address))||je?.emit("accountChanged",o)}),[e,o]),{ready:e,wallet:Ge}}function Jt(){let{client:e}=K(),{ready:n,wallet:a}=Kt(),[c,d]=y.useState([]),[o,i]=y.useState([]);return y.useEffect((()=>{let t=[a,...c.filter((l=>l.chainType==="solana"&&!!l.wallet.features)).map((l=>l.wallet))];i(t);let r=c.flatMap((l=>{let w=()=>i([...t]);return l.on("walletsUpdated",w),{connector:l,off:w}})),u=t.map((l=>l.features["standard:events"]?.on("change",(()=>{i([...t])}))));return()=>{u.forEach((l=>l?.())),r.forEach((({connector:l,off:w})=>l.off("walletsUpdated",w)))}}),[c]),y.useEffect((()=>{d(e.connectors?.walletConnectors.filter((r=>r.chainType==="solana"))??[]);let t=()=>{d(e.connectors?.walletConnectors.filter((r=>r.chainType==="solana"))??[])};return e.connectors?.on("connectorInitialized",t),()=>{e.connectors?.off("connectorInitialized",t)}}),[n,e.connectors]),{ready:n,wallets:o}}function zt(){let{ready:e,wallets:n}=Jt();return{ready:e,wallets:y.useMemo((()=>n.flatMap((a=>a.accounts.map((c=>new mt({wallet:a,account:c})))))),[n])}}var Zt="11111111111111111111111111111111";function qt(e){if(!e)throw new Error("Expected a Address.");return typeof e=="object"&&"address"in e?e.address:Array.isArray(e)?e[0]:e}function Xt(e,n){return a=>{if(!a.value)return;const c=a.isWritable?Ue.WRITABLE:Ue.READONLY;return Object.freeze({address:qt(a.value),role:Qe(a.value)?Wt(c):c,...Qe(a.value)?{signer:a.value}:{}})}}function Qe(e){return!!e&&typeof e=="object"&&"address"in e&&xt(e)}var en=2;function tn(){return It(Et([["discriminator",Ot()],["amount",jt()]]),e=>({...e,discriminator:en}))}function nn(e,n){const a=Zt,d={source:{value:e.source??null,isWritable:!0},destination:{value:e.destination??null,isWritable:!0}},o={...e},i=Xt();return Object.freeze({accounts:[i(d.source),i(d.destination)],data:tn().encode(o),programAddress:a})}function an({rows:e}){return h.jsx(gt,{children:e.filter((n=>!!n)).map(((n,a)=>n.value!=null||n.isLoading?h.jsxs(pt,{children:[h.jsx(ft,{children:n.label}),h.jsx(ht,{$isLoading:n.isLoading,children:n.value})]},a):null))})}function We(e){return BigInt(Math.floor(1e9*parseFloat(e)))}function Ee(e){return+sn.format(parseFloat(e.toString())/1e9)}let sn=Intl.NumberFormat(void 0,{maximumFractionDigits:8});async function rn({tx:e,solanaClient:n,amount:a,asset:c,tokenPrice:d}){if(!e)return null;if(c==="SOL"&&d){let o=We(a),i=pe(o,d),t=await fe({solanaClient:n,tx:e});return{amountInUsd:i,feeInUsd:d?pe(t,d):void 0,totalInUsd:pe(o+t,d)}}if(c==="USDC"&&d){let o="$"+a,i=await fe({solanaClient:n,tx:e}),t=(function(r,u){let l=parseFloat(r.toString())/Nt*u;return l<.01?0:l})(i,d);return{amountInUsd:o,feeInUsd:pe(i,d),totalInUsd:"$"+(parseFloat(a)+t).toFixed(2)}}if(c==="SOL"){let o=We(a),i=await fe({solanaClient:n,tx:e});return{amountInSol:a+" SOL",feeInSol:Ee(i)+" SOL",totalInSol:Ee(o+i)+" SOL"}}return{amountInUsdc:a+" USDC",feeInSol:Ee(await fe({solanaClient:n,tx:e}))+" SOL"}}const Wn={component:function(){let e=Ye(),{closePrivyModal:n,createAnalyticsEvent:a}=K(),{data:c,setModalData:d,navigate:o}=we(),{wallets:i}=zt(),[t,r]=y.useState("preparing"),[u,l]=y.useState(),[w,T]=y.useState(),[N,O]=y.useState();if(!c?.solanaFundingData)throw Error("Funding config is missing");if(!c.solanaFundingData.sourceWalletData)throw Error("Funding config is missing source wallet data");let{amount:f,asset:A,chain:b,sourceWalletData:I,destinationAddress:m,afterSuccessScreen:x}=c.solanaFundingData,p=i.find((g=>g.address===I.address&&Pe(I.walletClientType)===Pe(g.standardWallet.name))),_=Je()(b),{tokenPrice:C,isTokenPriceLoading:M}=$t("solana");return y.useEffect((()=>{if(t!=="preparing"||M||!p)return;let g=A==="SOL"?We(f):(function(v){return BigInt(Math.floor(1e6*parseFloat(v)))})(f);T({amount:(A==="SOL"&&C?pe(g,C):f)??f}),(A==="SOL"?(async function({solanaClient:v,source:j,destination:R,amountInLamports:k}){let{value:L}=await v.rpc.getLatestBlockhash().send(),V={address:j},G=$e(Ne({version:0}),(W=>Re(V,W)),(W=>Be(L,W)),(W=>Se(nn({amount:k,source:V,destination:R}),W)),(W=>Le(W)));return new Uint8Array(Oe().encode(G))})({solanaClient:_,source:p.address,destination:m,amountInLamports:g}):(async function({solanaClient:v,source:j,destination:R,amountInBaseUnits:k}){let L=Lt(v.chain),{value:V}=await v.rpc.getLatestBlockhash().send(),G={address:j},[W]=await De({mint:L,owner:j,tokenProgram:ke}),[Ae]=await De({mint:L,owner:R,tokenProgram:ke}),[Xe,et]=await Promise.all([v.rpc.getAccountInfo(W,{commitment:"confirmed",encoding:"jsonParsed"}).send().catch((()=>null)),v.rpc.getAccountInfo(Ae,{commitment:"confirmed",encoding:"jsonParsed"}).send().catch((()=>null))]);if(!Xe?.value)throw Error(`Source token account does not exist for address: ${j}`);let tt=Ct({payer:G,ata:Ae,owner:R,mint:L}),nt=$e(Ne({version:0}),(B=>Re(G,B)),(B=>Be(V,B)),(B=>et?.value?B:Se(tt,B)),(B=>Se(_t({source:W,destination:Ae,authority:G,amount:k}),B)),(B=>Le(B)));return new Uint8Array(Oe().encode(nt))})({solanaClient:_,source:p.address,destination:m,amountInBaseUnits:g})).then(l).catch((v=>{r("error"),O(v)}))}),[t,f,A,b,p,m,M,C]),y.useEffect((()=>{t==="preparing"&&u&&rn({tx:u,solanaClient:_,amount:f,asset:A,tokenPrice:C}).then((g=>{r("loaded"),T({amount:g?.amountInUsd??g?.amountInUsdc??g?.amountInSol??f,fee:g?.feeInUsd??g?.feeInSol,total:g?.totalInUsd??g?.totalInSol})})).catch((g=>{r("error"),O(g)}))}),[u,f,A,t,C]),y.useEffect((()=>{t==="error"&&N&&(d({errorModalData:{error:N,previousScreen:"FundSolWalletWithExternalSolanaWallet"},solanaFundingData:c.solanaFundingData}),o("ErrorScreen",!1))}),[t,o]),y.useEffect((()=>{if(t!=="success")return;let g=setTimeout(x?()=>o(x):n,Ft);return()=>clearTimeout(g)}),[t]),h.jsxs(h.Fragment,t==="success"?{children:[h.jsx(ve,{}),h.jsx(rt,{}),h.jsxs(ot,{children:[h.jsx(st,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),h.jsx(Me,{title:"Success!",description:`Youâ€™ve successfully added ${f} ${A} to your ${e.name} wallet. It may take a minute before the funds are available to use.`})]}),h.jsx(ct,{}),h.jsx(ye,{})]}:t==="preparing"||t==="loaded"||t==="sending"?{children:[h.jsx(ve,{}),h.jsx(lt,{style:{marginTop:"16px"},children:h.jsx(dt,{icon:p?.standardWallet.icon,name:p?.standardWallet.name})}),h.jsx(Me,{style:{marginTop:"8px",marginBottom:"12px"},title:t==="sending"&&p?`Confirming with ${p.standardWallet.name}`:"Confirm transaction"}),h.jsx(an,{rows:[{label:"Source",value:Te(I.address)},{label:"Destination",value:Te(m)},{label:"Network",value:Bt(b)},{label:"Amount",value:w?.amount,isLoading:t==="preparing"},{label:"Estimated fee",value:w?.fee,isLoading:t==="preparing"},{label:"Total",value:w?.total,isLoading:t==="preparing"}]}),h.jsx(it,{style:{marginTop:"1rem"},loading:t==="preparing"||t==="sending",onClick:function(){t==="loaded"&&u&&p&&(r("sending"),(async function({transaction:g,chain:v,sourceWallet:j,solanaClient:R}){let{hasFunds:k}=await Ut({solanaClient:R,tx:g});if(!k)throw new P(`Wallet ${Te(j.address)} does not have enough funds.`,void 0,$.INSUFFICIENT_BALANCE);let L=Rt((await j.signAndSendTransaction({transaction:g,chain:v}).catch((V=>{throw new P("Transaction was rejected by the user",V,$.TRANSACTION_FAILURE)}))).signature);return await Pt({rpcSubscriptions:R.rpcSubscriptions,signature:L,timeout:2e4}),L})({solanaClient:_,transaction:u,chain:b,sourceWallet:p}).then((g=>{r("success"),a({eventName:Dt,payload:{provider:"external",status:"success",txHash:g,address:p.address,value:f,chainType:"solana",clusterName:b,token:A,destinationAddress:m,destinationValue:f,destinationChainType:"solana",destinationClusterName:b,destinationToken:A}})})).catch((g=>{r("error"),O(g)})))},children:"Confirm"}),h.jsx(ye,{})]}:{children:[h.jsx(ve,{}),h.jsx(ut,{}),h.jsx("div",{style:{marginTop:"1rem"}}),h.jsx(ye,{})]})}};export{Wn as FundSolWalletWithExternalSolanaWallet,Wn as default};
