import{j as a}from"./vendor-wallet-iWeBopzN.js";import{r as f}from"./vendor-react-NLnOsXgy.js";import{T as ne,m as B,u as se}from"./ModalHeader-D8-mhjp4-CWM4G6o2.js";import{o as H}from"./ScreenHeader-CHmc4-Lu-BA4BjjVT.js";import{b as K,a as Y,I as G,u as de,bw as ue,_ as c,E,bz as X,bB as he,aR as pe,ao as ve,cp as we,cr as ye,cs as me,ct as fe,cu as Ee,cv as _e,cw as ee,cx as Ae}from"./index-DksErA8h.js";import{d as ge,e as Ce,o as Z}from"./styles-BsotlekN-CpjF829i.js";async function q({url:h,popup:i,provider:p}){return i.location=h,new Promise(((l,n)=>{function s(){i?.close(),window.removeEventListener("message",d)}function d(o){o.data&&(o.data.type==="PRIVY_OAUTH_RESPONSE"&&o.data.stateCode&&o.data.authorizationCode&&(l(o.data),s()),o.origin==="https://cdn.apple-cloudkit.com"&&o.data.ckSession&&(l({type:"PRIVY_OAUTH_RESPONSE",ckWebAuthToken:o.data.ckSession}),s()),o.data.type==="PRIVY_OAUTH_ERROR"&&(n(o.data.error),s()))}window.addEventListener("message",d)}))}async function Re({api:h,provider:i,stateCode:p,codeVerifier:l,authorizationCode:n}){if(!n||!p)throw new c("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");if(n==="undefined")throw new c("User denied confirmation during OAuth flow");try{return(await h.post(Ae,{authorization_code:n,state_code:p,code_verifier:l,provider:i})).access_token}catch(s){let d=ee(s);throw d.privyErrorCode?new c(d.message||"Invalid code during OAuth flow.",void 0,d.privyErrorCode):d.message==="User denied confirmation during OAuth flow"?new c("Invalid code during oauth flow.",void 0,E.OAUTH_USER_DENIED):new c("Invalid code during OAuth flow.",void 0,E.UNKNOWN_AUTH_ERROR)}}async function J({api:h,provider:i}){let p=ye(),l=me(),n=await fe(p);try{return i==="icloud"?{url:(await h.post(Ee,{client_type:"web"})).url}:{url:(await h.post(_e,{redirect_to:window.location.href,code_challenge:n,state_code:l})).url,codeVerifier:p,stateCode:l,provider:i}}catch(s){throw ee(s)}}let Q={"google-drive":{name:"Google Drive",component:Ce},icloud:{name:"iCloud",component:ge}};const Ne={component:()=>{let{logout:h}=K(),{navigate:i,setModalData:p,data:l}=Y(),{closePrivyModal:n,createAnalyticsEvent:s}=G(),{execute:d}=(()=>{let{client:t,walletProxy:w,refreshSessionAndUser:N}=G(),{data:A}=Y(),{user:g}=K(),C=de(),{create:T}=ue();return{execute:async({provider:r,action:le,popup:P,shouldCreateEth:V,shouldCreateSol:L})=>{let R,y;if(!t)throw new c("Missing client");function z(e){if(!e&&t)throw t.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:"Unable to open recovery OAuth popup",provider:r}}),new c("Recovery OAuth failed")}switch(r){case"google-drive":{let e,u,{url:x,codeVerifier:O,stateCode:F}=await J({api:t.api,provider:r});z(x);try{let k=await q({url:x,popup:P,provider:r});if(e=k.stateCode,u=k.authorizationCode,e!==F)throw t.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:r,storedStateCode:F??"",returnedStateCode:e??""}}),new c("Unexpected auth flow. This may be a phishing attempt.",void 0,E.OAUTH_UNEXPECTED)}catch(k){throw t.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:k.toString(),provider:r}}),new c("Recovery OAuth failed")}[R,y]=await Promise.all([t.getAccessToken(),Re({api:t.api,provider:r,codeVerifier:O,stateCode:e,authorizationCode:u})]);break}case"icloud":{let{url:e}=await J({api:t.api,provider:r});z(e);let{ckWebAuthToken:u}=await q({url:e,popup:P,provider:r});y=u,R=await t.getAccessToken()}}if(!w)throw new c("Cannot connect to wallet proxy");if(!R)throw new c("Unable to authorize user");switch(le){case"recover":{let e=A?.recoverWallet?.entropyId,u=A?.recoverWallet?.entropyIdVerifier;if(!e||!u)throw new c("Recovery OAuth failed");t.createAnalyticsEvent({eventName:"embedded_wallet_recovery_started",payload:{walletAddress:e,recoveryMethod:r}}),await w.recover({accessToken:R,entropyId:e,entropyIdVerifier:u,recoveryAccessToken:y}),t.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:e,recoveryMethod:r}});break}case"create-wallet":{let e;if(t.createAnalyticsEvent({eventName:"embedded_wallet_creation_started"}),V&&L)e=await T({recoveryMethod:r,recoveryAccessToken:y,chainType:"ethereum",walletIndex:0,latestUser:g}),e=await T({chainType:"solana",walletIndex:0,latestUser:e.user});else if(L)e=await T({recoveryMethod:r,recoveryAccessToken:y,chainType:"solana",walletIndex:0,latestUser:g});else{if(!V)throw Error("Invalid args to create wallet");e=await T({recoveryMethod:r,recoveryAccessToken:y,chainType:"ethereum",walletIndex:0,latestUser:g})}if(!e)throw C("createWallet","onError",E.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");t.createAnalyticsEvent({eventName:"embedded_wallet_creation_completed",payload:{walletAddress:e.account.address}}),C("createWallet","onSuccess",{wallet:e.account});break}case"set-recovery":{let e=X(g);if(!e)throw C("setWalletRecovery","onError",E.EMBEDDED_WALLET_NOT_FOUND),Error("Embedded wallet not found");t.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_started",payload:{walletAddress:e.address,existingRecoveryMethod:e.recoveryMethod,targetRecoveryMethod:r}});let{entropyId:u,entropyIdVerifier:x}=he(g);await w.setRecovery({accessToken:R,entropyId:u,entropyIdVerifier:x,recoveryMethod:r,recoveryAccessToken:y});let O=X(await N());if(!O)throw C("createWallet","onError",E.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to set recovery on wallet");t.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_completed",payload:{walletAddress:e.address,existingRecoveryMethod:e.recoveryMethod,targetRecoveryMethod:r}}),C("setWalletRecovery","onSuccess",{method:r,wallet:O});break}default:throw new c("Unsupported recovery action")}}}})(),[o,I]=f.useState(!1),{provider:_,action:m,isInAccountCreateFlow:U,shouldCreateEth:te,shouldCreateSol:re}=l?.recoveryOAuthStatus,[v,M]=f.useState(void 0),[oe,ae]=f.useState(m==="create-wallet");if(_==="user-passcode")throw Error("RecoveryOAuthScreen should never be called with a wallet that specifies recoveryMethod: `user-passcode`");let W=Q[_].name,$=Q[_].component,D=l?.recoverWallet?.onCompleteNavigateTo,S=new pe((async(t="create-wallet")=>(ae(!0),new Promise(((w,N)=>{setTimeout((async()=>{try{let A=window.open();await d({provider:_,action:t,popup:A,shouldCreateEth:te,shouldCreateSol:re}),I(!0),w()}catch{M({message:`${t==="recover"?"Recovery":"Back up"} with ${W} unsuccessful`,detail:m==="recover"?`Please verify that you are selecting the ${W} account associated with your backup.`:"",retryable:!0}),N()}}),0)})))));f.useEffect((()=>{m!=="recover"&&S.execute(U?"create-wallet":"set-recovery")}),[]),f.useEffect((()=>{if(!o)return;let t=setTimeout((()=>{U?(p({createWallet:{onSuccess:()=>{},onFailure:w=>{s({eventName:"embedded_wallet_creation_failure_logout",payload:{error:w,screen:"RecoveryOAuthScreen"}}),h()},callAuthOnSuccessOnClose:!0,shouldCreateEth:!1,shouldCreateSol:!1}}),i("EmbeddedWalletCreatedScreen")):n({shouldCallAuthOnSuccess:!1})}),ve);return()=>clearTimeout(t)}),[o]);let j=f.useCallback((async()=>{await S.execute("recover"),D?i(D):I(!0)}),[]),b=_==="google-drive"?"Google Drive":"Apple iCloud",ce=o&&`Successfully ${m==="recover"?"recovered":"backed up"} with ${b}.`||v&&v.message||`${m==="recover"?"Recovering":"Backing up"} with ${b}...`,ie=v?v.detail:"";return a.jsxs(a.Fragment,{children:[a.jsx(ne,{}),oe?a.jsx(a.Fragment,{children:a.jsxs(Z,{children:[a.jsx(H,{title:ce,icon:a.jsx($,{style:{width:"38px",height:"38px"}}),description:ie}),v&&v?.retryable?a.jsx(B,{onClick:()=>{we(),M(void 0),m==="create-wallet"?S.execute("create-wallet"):j()},disabled:!o&&!v?.retryable,children:"Try again"}):null]})}):a.jsxs(Z,{children:[a.jsx(H,{title:"Confirm it's really you",icon:a.jsx($,{style:{height:42,width:48}}),description:`To confirm your identity, please log in to ${b} where your account is backed up.`}),a.jsxs(B,{onClick:j,children:["Confirm with ",b]})]}),a.jsx(se,{})]})}};export{Ne as RecoveryOAuthScreen,Ne as default};
