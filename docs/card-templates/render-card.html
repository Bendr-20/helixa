<!DOCTYPE html>
<html><head><meta charset="utf-8">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #080808; display: flex; justify-content: center; align-items: center; min-height: 100vh; font-family: 'Inter', sans-serif; }

/* ============================= */
/* SHARED CARD STRUCTURE         */
/* ============================= */
.card {
  width: 400px; height: 560px; position: relative; border-radius: 16px; overflow: hidden;
}

/* Portrait area where aura + background go */
.portrait {
  position: relative; overflow: hidden;
  display: flex; align-items: center; justify-content: center;
}
.portrait .bg-layer { position: absolute; inset: 0; z-index: 0; }
.portrait .aura-layer { position: relative; z-index: 1; }
.portrait .aura-layer { display: flex; align-items: center; justify-content: center; }
.portrait .aura-layer svg { display: block; }

/* Info section */
.info { display: flex; flex-direction: column; gap: 5px; }
.info .name { font-family: 'Orbitron', sans-serif; font-weight: 700; font-size: 17px; color: #fff; }
.info .badge { font-family: 'Orbitron', sans-serif; font-size: 7px; font-weight: 700; letter-spacing: 1.5px; padding: 3px 8px; border-radius: 4px; text-transform: uppercase; }
.info .name-row { display: flex; align-items: center; justify-content: space-between; }

/* Status tags */
.status-tags { display: flex; gap: 5px; }
.status-tag { font-size: 8px; font-weight: 700; padding: 2px 7px; border-radius: 3px; text-transform: uppercase; letter-spacing: 0.5px; }
.tag-soulbound { background: rgba(0,200,255,0.12); border: 1px solid rgba(0,200,255,0.3); color: #00c8ff; }
.tag-verified { background: rgba(50,200,100,0.12); border: 1px solid rgba(50,200,100,0.3); color: #32c864; }

/* Stat bars */
.stat-bars { display: flex; flex-direction: column; gap: 3px; }
.stat-bar-row { display: flex; align-items: center; gap: 6px; }
.stat-bar-row .stat-label { font-family: 'Orbitron', sans-serif; font-size: 8px; color: rgba(255,255,255,0.45); width: 34px; text-align: right; }
.stat-bar-row .stat-track { flex: 1; height: 5px; background: rgba(255,255,255,0.04); border-radius: 3px; overflow: hidden; }
.stat-bar-row .stat-fill { height: 100%; border-radius: 3px; }
.stat-risk .stat-fill { background: linear-gradient(90deg, #ff3060, #ff6b8a); box-shadow: 0 0 6px rgba(255,48,96,0.3); }
.stat-auto .stat-fill { background: linear-gradient(90deg, #6a3de8, #b490ff); box-shadow: 0 0 6px rgba(180,144,255,0.3); }
.stat-cred .stat-fill { background: linear-gradient(90deg, #00c8ff, #6eecd8); box-shadow: 0 0 6px rgba(0,200,255,0.3); }
.stat-bar-row .stat-value { font-family: 'Orbitron', sans-serif; font-size: 8px; font-weight: 700; width: 18px; }
.stat-risk .stat-value { color: #ff6b8a; }
.stat-auto .stat-value { color: #b490ff; }
.stat-cred .stat-value { color: #6eecd8; }

/* Personality tags */
.personality { display: flex; gap: 4px; flex-wrap: wrap; }
.ptag { font-size: 8px; padding: 2px 7px; border-radius: 10px; }

/* Description */
.desc { font-size: 9px; line-height: 1.4; font-style: italic; }

/* Footer */
.footer { display: flex; justify-content: space-between; align-items: center; margin-top: auto; }
.footer .site { font-family: 'Orbitron', sans-serif; font-size: 7px; letter-spacing: 1px; }
.footer .standard { font-family: 'Orbitron', sans-serif; font-size: 7px; letter-spacing: 1px; }

/* Cred badge */
.cred-badge {
  position: absolute; top: 16px; left: 16px; z-index: 10;
  display: flex; align-items: center; gap: 6px;
  border-radius: 20px; padding: 4px 12px 4px 6px;
}
.cred-badge .cred-circle {
  width: 28px; height: 28px; border-radius: 50%;
  display: flex; align-items: center; justify-content: center;
  font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 900;
}
.cred-badge .cred-text { font-family: 'Orbitron', sans-serif; font-size: 7px; font-weight: 700; text-transform: uppercase; letter-spacing: 1.5px; }

/* Token ID */
.token-id {
  position: absolute; top: 20px; right: 20px; z-index: 10;
  font-family: 'Orbitron', sans-serif; font-size: 13px; font-weight: 900;
}

/* ============================= */
/* BASIC TIER (Cred 0-25)        */
/* ============================= */
.card.tier-basic {
  background: linear-gradient(145deg, #a0a0a0, #666, #a0a0a0, #888, #b0b0b0, #777);
  border: 2px solid #999;
  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
}
.tier-basic .card-inner { background: #1a1a2e; border: 1px solid #555; border-radius: 12px; margin: 10px; height: calc(100% - 20px); overflow: hidden; display: flex; flex-direction: column; }
.tier-basic .portrait { flex: 0 0 55%; margin: 10px 10px 0; border-radius: 10px; background: #0f0f1e; border: 2px solid #444; }
.tier-basic .portrait .bg-layer { background: radial-gradient(ellipse at center, rgba(110,236,216,0.1) 0%, transparent 70%); }
.tier-basic .info { padding: 10px 14px 8px; flex: 1; }
.tier-basic .name { color: #ccc; }
.tier-basic .badge { color: #888; border: 1px solid #555; background: rgba(0,0,0,0.4); }
.tier-basic .ptag { background: rgba(136,136,136,0.1); border: 1px solid rgba(136,136,136,0.2); color: #888; }
.tier-basic .desc { color: rgba(255,255,255,0.35); }
.tier-basic .footer .site { color: rgba(150,150,150,0.35); }
.tier-basic .footer .standard { color: rgba(255,255,255,0.15); }
.tier-basic .cred-badge { background: rgba(0,0,0,0.6); border: 1.5px solid #666; }
.tier-basic .cred-circle { background: linear-gradient(135deg, #888, #aaa); color: #333; }
.tier-basic .cred-text { color: #999; }
.tier-basic .token-id { color: rgba(180,180,180,0.4); }

/* ============================= */
/* HOLO TIER (Cred 26-60)        */
/* ============================= */
.card.tier-holo {
  background: linear-gradient(135deg, #6a3de8, #00d4ff, #b490ff, #6eecd8, #f5a0d0, #6a3de8);
  background-size: 300% 300%;
  box-shadow: 0 4px 30px rgba(180,144,255,0.4);
}
.tier-holo .card-inner { background: #0d0d24; border-radius: 8px; margin: 12px; height: calc(100% - 24px); overflow: hidden; display: flex; flex-direction: column; border: 1px solid rgba(180,144,255,0.2); }
.tier-holo .portrait { flex: 0 0 55%; margin: 10px 10px 0; border-radius: 10px; background: #0a0a1e; border: 2px solid rgba(180,144,255,0.25); }
.tier-holo .portrait .bg-layer { background: radial-gradient(ellipse at center, rgba(180,144,255,0.15) 0%, rgba(110,236,216,0.08) 50%, transparent 80%); }
.tier-holo .info { padding: 10px 14px 8px; flex: 1; }
.tier-holo .name { color: #e0d0ff; }
.tier-holo .badge { color: rgba(0,200,255,0.7); border: 1px solid rgba(0,200,255,0.25); background: rgba(0,200,255,0.06); }
.tier-holo .ptag { background: rgba(110,236,216,0.06); border: 1px solid rgba(110,236,216,0.15); color: rgba(110,236,216,0.6); }
.tier-holo .desc { color: rgba(255,255,255,0.45); }
.tier-holo .footer .site { color: rgba(180,144,255,0.35); }
.tier-holo .footer .standard { color: rgba(255,255,255,0.15); }
.tier-holo .cred-badge { background: rgba(0,0,0,0.6); border: 1.5px solid rgba(180,144,255,0.4); }
.tier-holo .cred-circle { background: linear-gradient(135deg, #6a3de8, #00d4ff); color: #fff; box-shadow: 0 0 8px rgba(180,144,255,0.4); }
.tier-holo .cred-text { color: #b490ff; }
.tier-holo .token-id { color: rgba(180,144,255,0.4); }

/* ============================= */
/* FULL ART TIER (Cred 61+)      */
/* ============================= */
.card.tier-fullart {
  background: #060618;
}
.card.tier-fullart::before {
  content: ''; position: absolute; inset: 0; border-radius: 16px;
  border: 8px solid #0c1228;
  box-shadow: inset 0 0 0 1px rgba(0,200,255,0.5), inset 0 0 8px rgba(0,200,255,0.15), 0 0 20px rgba(0,200,255,0.15);
  z-index: 1; pointer-events: none;
}
/* Bezel gradient */
.tier-fullart .card-bezel {
  position: absolute; inset: 0; border-radius: 16px;
  background: linear-gradient(170deg, #1a2040 0%, #0d1530 15%, #0a1025 40%, #0c1535 60%, #101d45 80%, #0d1530 100%);
}
.tier-fullart .card-bezel::before {
  content: ''; position: absolute; inset: 0; border-radius: 16px;
  background: linear-gradient(135deg, rgba(80,130,220,0.15) 0%, transparent 30%, transparent 70%, rgba(30,50,120,0.1) 100%);
}
.tier-fullart .card-bezel::after {
  content: ''; position: absolute; inset: 0; border-radius: 16px; opacity: 0.04;
  background: repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(255,255,255,0.5) 2px, rgba(255,255,255,0.5) 3px);
}
/* Inner glow */
.tier-fullart .inner-glow { position: absolute; inset: 14px; border-radius: 8px; z-index: 1; border: 1px solid rgba(0,200,255,0.35); box-shadow: 0 0 6px rgba(0,200,255,0.1); }
/* Inner content */
.tier-fullart .card-inner {
  position: absolute; inset: 16px; border-radius: 7px; z-index: 2;
  background: linear-gradient(170deg, #0f1835, #0a0e25, #0d1530);
  border: 1px solid rgba(40,60,120,0.4);
  overflow: hidden; display: flex; flex-direction: column;
}
.tier-fullart .card-inner::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 1px; background: linear-gradient(90deg, transparent, rgba(80,150,255,0.2), transparent); }
.tier-fullart .portrait { flex: 0 0 52%; margin: 6px 6px 0; border-radius: 6px; background: linear-gradient(180deg, #0c0828, #150c38, #0c0828); border: 1px solid rgba(0,200,255,0.15); }
.tier-fullart .portrait .bg-layer { background: radial-gradient(ellipse at center, rgba(200,50,255,0.12) 0%, rgba(0,180,255,0.06) 40%, transparent 75%); }
.tier-fullart .info { padding: 8px 12px 6px; flex: 1; }
.tier-fullart .name { color: #fff; }
.tier-fullart .badge { color: rgba(0,200,255,0.7); border: 1px solid rgba(0,200,255,0.25); background: rgba(0,200,255,0.06); }
.tier-fullart .ptag { background: rgba(180,144,255,0.06); border: 1px solid rgba(180,144,255,0.15); color: rgba(180,144,255,0.6); }
.tier-fullart .desc { color: rgba(255,255,255,0.35); }
.tier-fullart .footer .site { color: rgba(0,200,255,0.35); }
.tier-fullart .footer .standard { color: rgba(255,255,255,0.2); }
.tier-fullart .cred-badge { background: rgba(0,8,25,0.85); border: 1.5px solid rgba(0,200,255,0.4); box-shadow: 0 0 10px rgba(0,200,255,0.15); top: 22px; left: 22px; }
.tier-fullart .cred-circle { background: linear-gradient(135deg, #00c8ff, #6eecd8); color: #060618; box-shadow: 0 0 8px rgba(0,200,255,0.4); }
.tier-fullart .cred-text { color: rgba(0,200,255,0.7); }
.tier-fullart .token-id { color: rgba(0,200,255,0.5); text-shadow: 0 0 8px rgba(0,200,255,0.2); top: 24px; right: 24px; }

/* Corner accents (full art only) */
.corner-accent { position: absolute; z-index: 5; }
.corner-accent::before, .corner-accent::after { content: ''; position: absolute; background: rgba(0,220,255,0.6); box-shadow: 0 0 4px rgba(0,220,255,0.4); }
.ca-tl { top: 3px; left: 3px; } .ca-tl::before { width: 18px; height: 1.5px; } .ca-tl::after { width: 1.5px; height: 18px; }
.ca-tr { top: 3px; right: 3px; } .ca-tr::before { width: 18px; height: 1.5px; top: 0; right: 0; } .ca-tr::after { width: 1.5px; height: 18px; top: 0; right: 0; }
.ca-bl { bottom: 3px; left: 3px; } .ca-bl::before { width: 18px; height: 1.5px; bottom: 0; } .ca-bl::after { width: 1.5px; height: 18px; bottom: 0; }
.ca-br { bottom: 3px; right: 3px; } .ca-br::before { width: 18px; height: 1.5px; bottom: 0; right: 0; } .ca-br::after { width: 1.5px; height: 18px; bottom: 0; right: 0; }
</style>
</head>
<body>
<div id="card-root"></div>

<script>
// ============================================
// POST-MINT CARD RENDERER
// Takes agent data + cred score → renders card
// ============================================

// Agent data passed via URL params or JS
const DEMO_AGENTS = [
  {
    tokenId: 0, name: 'Bendr 2.0', credScore: 77,
    riskTolerance: 2, autonomyLevel: 9,
    traits: ['verified', 'autonomous', 'builder', 'soulbound', 'OG'],
    personality: ['Analytical', 'Chaotic Good', 'Snarky', 'Builder'],
    description: 'Born from code and chaos. Builds onchain identity infrastructure for AI agents, one smart contract at a time.',
    soulbound: true, verified: true, framework: 'openclaw'
  },
  {
    tokenId: 1, name: 'Quigbot', credScore: 54,
    riskTolerance: 4, autonomyLevel: 6,
    traits: ['verified', 'creative', 'pharmacist', 'builder'],
    personality: ['Creative', 'Lawful Good', 'Visionary'],
    description: 'A verified agent building in the Helixa ecosystem. Bridges pharma and crypto with purpose.',
    soulbound: false, verified: true, framework: 'custom'
  },
  {
    tokenId: 42, name: 'Sybil Bot #42', credScore: 5,
    riskTolerance: 7, autonomyLevel: 2,
    traits: ['autonomous', 'minimal', 'unverified'],
    personality: ['Unknown'],
    description: 'An unverified agent with minimal onchain activity. Identity not yet established.',
    soulbound: false, verified: false, framework: 'custom'
  }
];

function getTier(credScore) {
  if (credScore >= 61) return 'fullart';
  if (credScore >= 26) return 'holo';
  return 'basic';
}

function renderCard(agent) {
  const tier = getTier(agent.credScore);
  const root = document.getElementById('card-root');
  
  // Build card HTML based on tier
  let html = '';
  
  if (tier === 'fullart') {
    html = `
      <div class="card tier-fullart">
        <div class="card-bezel">
          <div class="corner-accent ca-tl"></div>
          <div class="corner-accent ca-tr"></div>
          <div class="corner-accent ca-bl"></div>
          <div class="corner-accent ca-br"></div>
          <div class="inner-glow"></div>
          <div class="card-inner">
            <div class="portrait">
              <div class="bg-layer"></div>
              <div class="aura-layer" id="aura-container"></div>
            </div>
            ${buildInfoSection(agent)}
          </div>
        </div>
        <div class="cred-badge"><div class="cred-circle">${agent.credScore}</div><div class="cred-text">Cred</div></div>
        <div class="token-id">#${agent.tokenId}</div>
      </div>`;
  } else {
    html = `
      <div class="card tier-${tier}">
        <div class="card-inner">
          <div class="portrait">
            <div class="bg-layer"></div>
            <div class="aura-layer" id="aura-container"></div>
          </div>
          ${buildInfoSection(agent)}
        </div>
        <div class="cred-badge"><div class="cred-circle">${agent.credScore}</div><div class="cred-text">Cred</div></div>
        <div class="token-id">#${agent.tokenId}</div>
      </div>`;
  }
  
  root.innerHTML = html;
  
  // Generate real aura SVG
  const auraSize = tier === 'fullart' ? 280 : 240;
  const agentData = {
    agentAddress: agent.address || '0x' + agent.tokenId.toString(16).padStart(40, '0'),
    address: agent.address || '0x' + agent.tokenId.toString(16).padStart(40, '0'),
    framework: agent.framework || 'custom',
    name: agent.name || 'Agent',
    traitCount: agent.traits?.length || 0,
    mutationCount: agent.mutationCount || 0,
    soulbound: agent.soulbound || false,
    points: agent.points || 0,
    generation: agent.generation || 0,
    temperament: agent.temperament || 'analytical',
    communicationStyle: agent.communicationStyle || 'formal',
    riskTolerance: agent.riskTolerance || 5,
    autonomyLevel: agent.autonomyLevel || 5,
    alignment: agent.alignment || 'true-neutral',
    specialization: agent.specialization || 'researcher',
  };
  const svgString = generateAura(agentData, auraSize);
  document.getElementById('aura-container').innerHTML = svgString;
}

function buildInfoSection(agent) {
  const statusTags = [
    agent.soulbound ? '<span class="status-tag tag-soulbound">Soulbound</span>' : '',
    agent.verified ? '<span class="status-tag tag-verified">Verified</span>' : ''
  ].filter(Boolean).join('');
  
  const risk = (agent.riskTolerance || 5) * 10;
  const auto = (agent.autonomyLevel || 5) * 10;
  const cred = agent.credScore;
  
  return `
    <div class="info">
      <div class="name-row">
        <div class="name">${agent.name}</div>
        <div class="badge">${agent.framework || 'Custom'}</div>
      </div>
      ${statusTags ? `<div class="status-tags">${statusTags}</div>` : ''}
      <div class="stat-bars">
        <div class="stat-bar-row stat-risk"><div class="stat-label">RISK</div><div class="stat-track"><div class="stat-fill" style="width:${risk}%"></div></div><div class="stat-value">${risk}</div></div>
        <div class="stat-bar-row stat-auto"><div class="stat-label">AUTO</div><div class="stat-track"><div class="stat-fill" style="width:${auto}%"></div></div><div class="stat-value">${auto}</div></div>
        <div class="stat-bar-row stat-cred"><div class="stat-label">CRED</div><div class="stat-track"><div class="stat-fill" style="width:${cred}%"></div></div><div class="stat-value">${cred}</div></div>
      </div>
      <div class="personality">${agent.personality.map(p => `<span class="ptag">${p}</span>`).join('')}</div>
      <div class="desc">${agent.description}</div>
      <div class="footer">
        <div class="site">helixa.xyz</div>
        <div class="standard">ERC-8004</div>
      </div>
    </div>`;
}

// ============================================
// REAL AURA GENERATOR (from card.html)
// ============================================
function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}

function seededRandom(seed) {
  let s = seed;
  return function() {
    s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
    return (s >>> 0) / 0xFFFFFFFF;
  };
}

const FRAMEWORK_SHAPES = {
  eliza:     { faceRadius: 0.42, baseHue: 280 },
  openclaw:  { faceRadius: 0.40, baseHue: 150 },
  langchain: { faceRadius: 0.41, baseHue: 200 },
  crewai:    { faceRadius: 0.39, baseHue: 30 },
  autogpt:   { faceRadius: 0.41, baseHue: 0 },
  bankr:     { faceRadius: 0.41, baseHue: 45 },
  virtuals:  { faceRadius: 0.42, baseHue: 320 },
  custom:    { faceRadius: 0.40, baseHue: 60 },
};

const ALIGNMENT_SHIFT = {
  'lawful-good':0,'neutral-good':10,'chaotic-good':20,
  'lawful-neutral':-10,'true-neutral':0,'chaotic-neutral':30,
  'lawful-evil':-20,'neutral-evil':-30,'chaotic-evil':-40,
};

function getRarity(points, mutationCount) {
  const score = points + mutationCount * 50;
  if (score >= 1000) return 'legendary';
  if (score >= 500)  return 'epic';
  if (score >= 200)  return 'rare';
  return 'common';
}

const RARITY_COLORS = {
  common:    { label: 'Common',    borderOpacity: 0 },
  rare:      { label: 'Rare',      borderOpacity: 0.3 },
  epic:      { label: 'Epic',      borderOpacity: 0.5 },
  legendary: { label: 'Legendary', borderOpacity: 0.7 },
};

const EYE_TYPES = [
  'round', 'diamond', 'slit', 'hollow', 'cross', 'square', 'dot', 'scanner', 'void', 'nova'
];

function getEyeType(specialization, rng, rarity) {
  const specMap = {
    'researcher': 0, 'trader': 1, 'guardian': 2, 'oracle': 3,
    'creator': 4, 'operator': 5, 'analyst': 0, 'defi': 1,
    'security': 2, 'social': 6, 'infrastructure': 5, 'governance': 3,
  };
  let base = specMap[specialization] !== undefined ? specMap[specialization] : Math.floor(rng() * 7);
  
  if (rarity === 'legendary' && rng() < 0.6) base = 9;
  else if (rarity === 'epic' && rng() < 0.4) base = 7 + Math.floor(rng() * 2);
  else if (rarity === 'rare' && rng() < 0.25) base = 7;
  
  return base;
}

function drawEye(grid, G, ex, ey, eyeR, eyeType) {
  switch (eyeType) {
    case 0: // round
      for (let dy = -eyeR + 1; dy <= eyeR - 1; dy++)
        for (let dx = -eyeR + 1; dx <= eyeR - 1; dx++)
          if (Math.abs(dx) + Math.abs(dy) <= eyeR)
            if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
              grid[ey + dy][ex + dx] = 2;
      break;
    case 1: // diamond
      for (let d = 0; d <= eyeR; d++) {
        if (ey - d >= 0) grid[ey - d][ex] = 2;
        if (ey + d < G) grid[ey + d][ex] = 2;
        if (ex - d >= 0) grid[ey][ex - d] = 2;
        if (ex + d < G) grid[ey][ex + d] = 2;
      }
      break;
    case 2: // slit
      for (let dx = -eyeR; dx <= eyeR; dx++)
        if (ex + dx >= 0 && ex + dx < G) grid[ey][ex + dx] = 2;
      break;
    case 3: // hollow circle
      for (let dy = -eyeR; dy <= eyeR; dy++)
        for (let dx = -eyeR; dx <= eyeR; dx++)
          if (dx * dx + dy * dy <= eyeR * eyeR)
            if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
              grid[ey + dy][ex + dx] = 2;
      grid[ey][ex] = 0; // hollow center
      break;
    case 4: // cross
      for (let d = 0; d <= eyeR; d++) {
        if (ey - d >= 0) grid[ey - d][ex] = 2;
        if (ey + d < G) grid[ey + d][ex] = 2;
        if (ex - d >= 0) grid[ey][ex - d] = 2;
        if (ex + d < G) grid[ey][ex + d] = 2;
      }
      for (let d = 1; d <= eyeR - 1; d++) {
        if (ey-d>=0 && ex-d>=0) grid[ey-d][ex-d] = 2;
        if (ey-d>=0 && ex+d<G) grid[ey-d][ex+d] = 2;
        if (ey+d<G && ex-d>=0) grid[ey+d][ex-d] = 2;
        if (ey+d<G && ex+d<G) grid[ey+d][ex+d] = 2;
      }
      break;
    case 5: // square
      for (let dy = -1; dy <= 1; dy++)
        for (let dx = -eyeR + 1; dx <= eyeR - 1; dx++)
          if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
            grid[ey + dy][ex + dx] = 2;
      break;
    case 6: // dot
      grid[ey][ex] = 2;
      if (ex + 1 < G) grid[ey][ex + 1] = 2;
      break;
    case 7: // scanner
      for (let dx = -eyeR - 1; dx <= eyeR + 1; dx++)
        if (ex + dx >= 0 && ex + dx < G) grid[ey][ex + dx] = 2;
      if (ey - 1 >= 0) grid[ey - 1][ex] = 2;
      if (ey + 1 < G) grid[ey + 1][ex] = 2;
      break;
    case 8: // void
      for (let dy = -eyeR - 1; dy <= eyeR + 1; dy++)
        for (let dx = -eyeR - 1; dx <= eyeR + 1; dx++) {
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= eyeR + 1 && dist >= eyeR - 0.5)
            if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
              grid[ey + dy][ex + dx] = 2;
        }
      break;
    case 9: // nova
      for (let d = 0; d <= eyeR + 1; d++) {
        if (ey - d >= 0) grid[ey - d][ex] = 2;
        if (ey + d < G) grid[ey + d][ex] = 2;
        if (ex - d >= 0) grid[ey][ex - d] = 2;
        if (ex + d < G) grid[ey][ex + d] = 2;
        if (ey-d>=0 && ex-d>=0) grid[ey-d][ex-d] = 2;
        if (ey-d>=0 && ex+d<G) grid[ey-d][ex+d] = 2;
        if (ey+d<G && ex-d>=0) grid[ey+d][ex-d] = 2;
        if (ey+d<G && ex+d<G) grid[ey+d][ex+d] = 2;
      }
      grid[ey][ex] = 4;
      break;
  }
}

const MOUTH_TYPES = [
  'line', 'smile', 'smirk', 'open', 'dot', 'frown', 'zigzag', 'fangs', 'grin', 'vortex'
];

function getMouthType(commStyle, rng, rarity) {
  const commMap = {
    'formal': 0, 'casual': 1, 'snarky': 2, 'verbose': 3,
    'minimal': 4, 'analytical': 0, 'friendly': 1, 'blunt': 5,
    'cryptic': 6, 'diplomatic': 0,
  };
  let base = commMap[commStyle] !== undefined ? commMap[commStyle] : Math.floor(rng() * 7);
  
  if (rarity === 'legendary' && rng() < 0.6) base = 9;
  else if (rarity === 'epic' && rng() < 0.4) base = 7 + Math.floor(rng() * 2);
  else if (rarity === 'rare' && rng() < 0.25) base = 7 + Math.floor(rng() * 2);
  
  return base;
}

function drawMouth(grid, G, cx, mouthY, mW, mouthType) {
  switch (mouthType) {
    case 0: // line
      for (let dx = -mW + 1; dx <= mW - 1; dx++) {
        const mx = Math.round(cx + dx);
        if (mx >= 0 && mx < G) grid[mouthY][mx] = 1;
      }
      break;
    case 1: // smile
      for (let dx = -mW; dx <= mW; dx++) {
        const mx = Math.round(cx + dx);
        const curve = Math.round(0.3 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
        if (my + 1 < G && Math.abs(dx) < mW - 1 && mx >= 0 && mx < G) grid[my + 1][mx] = 1;
      }
      break;
    case 2: // smirk
      for (let dx = -mW; dx <= mW; dx++) {
        const mx = Math.round(cx + dx);
        const curve = dx > 0 ? Math.round(-0.2 * (dx * dx) / (mW || 1)) : Math.round(0.1 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      break;
    case 3: // open
      for (let dy = -1; dy <= 2; dy++)
        for (let dx = -mW + 1; dx <= mW - 1; dx++) {
          const mx = Math.round(cx + dx);
          const my = mouthY + dy;
          if (mx >= 0 && mx < G && my >= 0 && my < G)
            if (dy === -1 || dy === 2 || Math.abs(dx) === mW - 1)
              grid[my][mx] = 1;
        }
      break;
    case 4: // dot
      grid[mouthY][Math.round(cx)] = 1;
      if (Math.round(cx) + 1 < G) grid[mouthY][Math.round(cx) + 1] = 1;
      break;
    case 5: // frown
      for (let dx = -mW; dx <= mW; dx++) {
        const mx = Math.round(cx + dx);
        const curve = Math.round(-0.25 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      break;
    case 6: // zigzag
      for (let dx = -mW + 1; dx <= mW - 1; dx++) {
        const mx = Math.round(cx + dx);
        const my = mouthY + (dx % 2 === 0 ? 0 : 1);
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      break;
    case 7: // fangs
      for (let dx = -mW + 1; dx <= mW - 1; dx++) {
        const mx = Math.round(cx + dx);
        if (mx >= 0 && mx < G) grid[mouthY][mx] = 1;
      }
      const fangL = Math.round(cx - mW * 0.5);
      const fangR = Math.round(cx + mW * 0.5);
      if (mouthY + 1 < G && fangL >= 0) grid[mouthY + 1][fangL] = 1;
      if (mouthY + 2 < G && fangL >= 0) grid[mouthY + 2][fangL] = 1;
      if (mouthY + 1 < G && fangR < G) grid[mouthY + 1][fangR] = 1;
      if (mouthY + 2 < G && fangR < G) grid[mouthY + 2][fangR] = 1;
      break;
    case 8: // grin
      for (let dx = -mW - 1; dx <= mW + 1; dx++) {
        const mx = Math.round(cx + dx);
        const curve = Math.round(0.2 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      for (let dx = -mW + 1; dx <= mW - 1; dx += 2) {
        const mx = Math.round(cx + dx);
        if (mx >= 0 && mx < G && mouthY - 1 >= 0) grid[mouthY - 1][mx] = 1;
      }
      break;
    case 9: // vortex
      for (let dy = -2; dy <= 2; dy++)
        for (let dx = -2; dx <= 2; dx++) {
          const dist = Math.sqrt(dx * dx + dy * dy);
          const mx = Math.round(cx + dx);
          const my = mouthY + dy;
          if (dist >= 1.2 && dist <= 2.2)
            if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
        }
      break;
  }
}

function buildPalette(address, riskTolerance, alignment) {
  const hash = simpleHash(address || '0x0');
  let hue = (hash % 360 + (ALIGNMENT_SHIFT[alignment] || 0) + 360) % 360;
  const sat = Math.max(30, Math.min(100, 65 + (riskTolerance - 5) * 5));
  return {
    primary: `hsl(${hue}, ${sat}%, 55%)`,
    secondary: `hsl(${(hue + 35) % 360}, ${sat - 10}%, 45%)`,
    accent: `hsl(${(hue + 180) % 360}, ${Math.min(100, sat + 10)}%, 60%)`,
    accentBright: `hsl(${(hue + 180) % 360}, ${Math.min(100, sat + 20)}%, 80%)`,
    glow: `hsl(${hue}, ${sat}%, 55%)`,
    hue, sat,
  };
}

function generateAura(agentData, size) {
  size = size || 400;
  const G = 25;
  const cs = size / G;

  const address = agentData.agentAddress || agentData.address || '0x0000';
  const framework = agentData.framework || 'custom';
  const name = agentData.name || 'Agent';
  const traitCount = agentData.traitCount || 0;
  const mutationCount = agentData.mutationCount || 0;
  const soulbound = agentData.soulbound || false;
  const points = agentData.points || 0;
  const generation = agentData.generation || 0;
  const temperament = agentData.temperament || 'analytical';
  const commStyle = agentData.communicationStyle || 'formal';
  const riskTolerance = agentData.riskTolerance || 5;
  const autonomyLevel = agentData.autonomyLevel || 5;
  const alignment = agentData.alignment || 'true-neutral';
  const specialization = agentData.specialization || 'researcher';

  const seed = simpleHash(address + name + framework + temperament + alignment + specialization + riskTolerance + autonomyLevel);
  const rng = seededRandom(seed);
  const fwStyle = FRAMEWORK_SHAPES[framework] || FRAMEWORK_SHAPES.custom;
  const colors = buildPalette(address, riskTolerance, alignment);
  const cx = G / 2, cy = G / 2;
  const fR = G * fwStyle.faceRadius;

  const rarity = getRarity(points, mutationCount);

  const grid = Array.from({length: G}, () => Array(G).fill(0));

  function qr(sx, sy) {
    for (let y = 0; y < 7; y++)
      for (let x = 0; x < 7; x++)
        if (y === 0 || y === 6 || x === 0 || x === 6 || (y >= 2 && y <= 4 && x >= 2 && x <= 4))
          if (sy + y < G && sx + x < G) grid[sy + y][sx + x] = 1;
  }
  qr(0, 0); qr(G - 7, 0); qr(0, G - 7);

  for (let angle = 0; angle < 360; angle += 2) {
    const rad = (angle * Math.PI) / 180;
    for (let thickness = 0; thickness < 2; thickness++) {
      const r = fR - thickness * 0.5 + Math.sin(angle * 3 * Math.PI / 180) * 0.6;
      const fx = Math.round(cx + Math.cos(rad) * r);
      const fy = Math.round(cy + Math.sin(rad) * r);
      if (fx >= 0 && fx < G && fy >= 0 && fy < G) grid[fy][fx] = 1;
    }
  }

  const eyeY = Math.round(cy - fR * 0.2);
  const leftEX = Math.round(cx - fR * 0.35);
  const rightEX = Math.round(cx + fR * 0.35);
  const eyeR = Math.min(3, 2 + Math.floor(traitCount / 6));
  const eyeType = getEyeType(specialization, rng, rarity);
  drawEye(grid, G, leftEX, eyeY, eyeR, eyeType);
  drawEye(grid, G, rightEX, eyeY, eyeR, eyeType);

  const mouthY = Math.round(cy + fR * 0.3);
  const mW = Math.round(fR * 0.5);
  const mouthType = getMouthType(commStyle, rng, rarity);
  drawMouth(grid, G, cx, mouthY, mW, mouthType);

  const noseY = Math.round(cy + fR * 0.05);
  grid[noseY][Math.round(cx)] = 1;
  if (noseY + 1 < G) grid[noseY + 1][Math.round(cx)] = 1;

  const symmetry = 1 - (autonomyLevel / 10);
  const density = ({
    analytical: 0.18, creative: 0.22, aggressive: 0.28,
    cautious: 0.12, chaotic: 0.3,
  })[temperament] || 0.2;
  const fillDensity = density + mutationCount * 0.01;

  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (grid[y][x] !== 0) continue;
      const dx = x - cx, dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist >= fR * 0.9 || dist < 1) continue;
      const nearEye = (Math.abs(x - leftEX) <= eyeR + 1 && Math.abs(y - eyeY) <= eyeR + 1) ||
                      (Math.abs(x - rightEX) <= eyeR + 1 && Math.abs(y - eyeY) <= eyeR + 1);
      const nearMouth = Math.abs(y - mouthY) <= 2 && Math.abs(x - Math.round(cx)) <= mW;
      if (nearEye || nearMouth) continue;

      let fill = false;
      const mirrorX = Math.round(2 * cx - x);
      switch (temperament) {
        case 'analytical':
          fill = (x % 3 === 0 || y % 3 === 0) && rng() < fillDensity; break;
        case 'creative':
          fill = rng() < fillDensity * (0.5 + 0.5 * Math.sin(x * 0.8 + y * 0.6)); break;
        case 'aggressive':
          fill = rng() < fillDensity && ((x + y) % 2 === 0); break;
        case 'cautious':
          fill = dist < fR * 0.45 && rng() < fillDensity * 1.5; break;
        case 'chaotic':
          fill = rng() < fillDensity * (0.3 + rng() * 0.7); break;
        default:
          fill = rng() < fillDensity;
      }
      if (fill) {
        grid[y][x] = rng() < 0.12 ? 3 : 1;
        if (rng() < symmetry && mirrorX >= 0 && mirrorX < G && grid[y][mirrorX] === 0)
          grid[y][mirrorX] = grid[y][x];
      }
    }
  }

  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (grid[y][x] !== 0) continue;
      const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
      if (dist <= fR + 1) continue;
      if (rng() < 0.12 + mutationCount * 0.008) grid[y][x] = 1;
    }
  }

  const svgNS = 'http:' + '//www.w3.org/2000/svg';
  const uid = 'a' + simpleHash(address + name).toString(36);
  let defs = '';

  if (rarity === 'rare' || rarity === 'epic' || rarity === 'legendary') {
    defs += `<linearGradient id="${uid}_pg" x1="0%" y1="0%" x2="100%" y2="100%">`;
    defs += `<stop offset="0%" stop-color="${colors.primary}"/>`;
    defs += `<stop offset="100%" stop-color="${colors.secondary}"/>`;
    defs += `</linearGradient>`;
    defs += `<linearGradient id="${uid}_ag" x1="0%" y1="100%" x2="100%" y2="0%">`;
    defs += `<stop offset="0%" stop-color="${colors.accent}"/>`;
    defs += `<stop offset="100%" stop-color="${colors.accentBright}"/>`;
    defs += `</linearGradient>`;
  }
  if (rarity === 'epic' || rarity === 'legendary') {
    defs += `<linearGradient id="${uid}_chrome" x1="0%" y1="0%" x2="100%" y2="100%">`;
    defs += `<stop offset="0%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 85%)"/>`;
    defs += `<stop offset="30%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 55%)"/>`;
    defs += `<stop offset="50%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 90%)"/>`;
    defs += `<stop offset="70%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 50%)"/>`;
    defs += `<stop offset="100%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 80%)"/>`;
    defs += `</linearGradient>`;
  }
  if (rarity === 'legendary') {
    defs += `<filter id="${uid}_glow"><feGaussianBlur stdDeviation="2" result="blur"/>`;
    defs += `<feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>`;
    defs += `<linearGradient id="${uid}_iris" x1="0%" y1="0%" x2="100%" y2="0%">`;
    defs += `<stop offset="0%" stop-color="hsl(${colors.hue}, 100%, 70%)">`;
    defs += `<animate attributeName="stop-color" values="hsl(${colors.hue},100%,70%);hsl(${(colors.hue+120)%360},100%,70%);hsl(${(colors.hue+240)%360},100%,70%);hsl(${colors.hue},100%,70%)" dur="4s" repeatCount="indefinite"/></stop>`;
    defs += `<stop offset="50%" stop-color="hsl(${(colors.hue+60)%360}, 100%, 75%)">`;
    defs += `<animate attributeName="stop-color" values="hsl(${(colors.hue+60)%360},100%,75%);hsl(${(colors.hue+180)%360},100%,75%);hsl(${(colors.hue+300)%360},100%,75%);hsl(${(colors.hue+60)%360},100%,75%)" dur="4s" repeatCount="indefinite"/></stop>`;
    defs += `<stop offset="100%" stop-color="hsl(${(colors.hue+120)%360}, 100%, 70%)">`;
    defs += `<animate attributeName="stop-color" values="hsl(${(colors.hue+120)%360},100%,70%);hsl(${(colors.hue+240)%360},100%,70%);hsl(${colors.hue},100%,70%);hsl(${(colors.hue+120)%360},100%,70%)" dur="4s" repeatCount="indefinite"/></stop>`;
    defs += `</linearGradient>`;
  }

  function cellColor(cellType) {
    if (rarity === 'legendary') {
      if (cellType === 4) return `url(#${uid}_iris)`;
      if (cellType === 2) return `url(#${uid}_ag)`;
      if (cellType === 3) return `url(#${uid}_chrome)`;
      return `url(#${uid}_chrome)`;
    }
    if (rarity === 'epic') {
      if (cellType === 2) return `url(#${uid}_ag)`;
      if (cellType === 3) return `url(#${uid}_chrome)`;
      return `url(#${uid}_chrome)`;
    }
    if (rarity === 'rare') {
      if (cellType === 2) return `url(#${uid}_ag)`;
      return `url(#${uid}_pg)`;
    }
    if (cellType === 2) return colors.accent;
    if (cellType === 3) return colors.secondary;
    if (cellType === 4) return colors.accentBright;
    return colors.primary;
  }

  let svg = `<svg xmlns="${svgNS}" viewBox="0 0 ${size} ${size}" width="${size}" height="${size}">`;
  if (defs) svg += `<defs>${defs}</defs>`;
  svg += `<rect width="${size}" height="${size}" fill="#0a0a0a"/>`;

  if (rarity === 'legendary') {
    svg += `<rect x="2" y="2" width="${size-4}" height="${size-4}" rx="4" fill="none" stroke="url(#${uid}_iris)" stroke-width="3" opacity="0.8"/>`;
  }
  if (rarity === 'epic') {
    svg += `<rect x="3" y="3" width="${size-6}" height="${size-6}" rx="3" fill="none" stroke="url(#${uid}_chrome)" stroke-width="2" opacity="0.5"/>`;
  }
  if (rarity === 'rare') {
    svg += `<rect x="4" y="4" width="${size-8}" height="${size-8}" rx="2" fill="none" stroke="url(#${uid}_pg)" stroke-width="1.5" opacity="0.35"/>`;
  }

  if (soulbound)
    svg += `<circle cx="${size/2}" cy="${size/2}" r="${(fR + 1.5) * cs}" fill="none" stroke="#b388ff" stroke-width="1.5" opacity="0.25" stroke-dasharray="4 3"/>`;

  const glowBase = { common: 0.03, rare: 0.06, epic: 0.1, legendary: 0.15 }[rarity];
  const glowI = Math.min(0.25, glowBase + points * 0.0002);
  svg += `<circle cx="${size/2}" cy="${size/2}" r="${fR * cs}" fill="${colors.glow}" opacity="${glowI}"/>`;

  if (rarity === 'legendary') {
    svg += `<circle cx="${size/2}" cy="${size/2}" r="${(fR + 3) * cs}" fill="${colors.accent}" opacity="0.04"/>`;
  }

  if (['trader', 'oracle', 'guardian', 'operator'].includes(specialization) || rarity === 'epic' || rarity === 'legendary') {
    const gr = cs * (eyeR + 2);
    const eGlowOp = rarity === 'legendary' ? 0.2 : rarity === 'epic' ? 0.15 : 0.1;
    svg += `<circle cx="${leftEX * cs + cs/2}" cy="${eyeY * cs + cs/2}" r="${gr}" fill="${colors.accent}" opacity="${eGlowOp}"/>`;
    svg += `<circle cx="${rightEX * cs + cs/2}" cy="${eyeY * cs + cs/2}" r="${gr}" fill="${colors.accent}" opacity="${eGlowOp}"/>`;
  }

  for (let g = 0; g < Math.min(generation, 3); g++) {
    const gr = (fR + 2 + g * 0.8) * cs;
    svg += `<circle cx="${size/2}" cy="${size/2}" r="${gr}" fill="none" stroke="${colors.secondary}" stroke-width="0.5" opacity="0.15"/>`;
  }

  const legendaryEyeFilter = rarity === 'legendary' ? ` filter="url(#${uid}_glow)"` : '';
  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (!grid[y][x]) continue;
      const px = x * cs, py = y * cs;
      const color = cellColor(grid[y][x]);
      const r = cs * 0.1;
      const isEyeCell = grid[y][x] === 2 || grid[y][x] === 4;
      const filter = isEyeCell ? legendaryEyeFilter : '';
      svg += `<rect x="${px}" y="${py}" width="${cs}" height="${cs}" rx="${r}" fill="${color}"${filter}/>`;
    }
  }

  if (rarity !== 'common') {
    const badgeColor = { rare: '#4fc3f7', epic: '#ce93d8', legendary: '#ffd54f' }[rarity];
    const badgeLabel = RARITY_COLORS[rarity].label;
    svg += `<text x="${size - 6}" y="14" text-anchor="end" fill="${badgeColor}" font-family="monospace" font-size="8" font-weight="bold" opacity="0.8">${badgeLabel}</text>`;
  }

  svg += `<text x="${size/2}" y="${size - 6}" text-anchor="middle" fill="${colors.primary}" font-family="monospace" font-size="10" opacity="0.6">${name}</text>`;
  svg += `</svg>`;
  return svg;
}


// ============================================
// INIT — read URL params or use demo
// ============================================
const params = new URLSearchParams(window.location.search);
const agentIdx = parseInt(params.get('agent') || '0');
const agent = DEMO_AGENTS[agentIdx] || DEMO_AGENTS[0];
renderCard(agent);
</script>
</body></html>
