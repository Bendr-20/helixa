<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <title>Helixa ‚Äî Identity for AI Agents</title>
    <link rel="stylesheet" href="helixa-theme.css?v=1770681532">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        header {
            text-align: center;
            padding: 3rem 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 2rem;
        }
        
        h1 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 2.5rem;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }
        
        h1 span { color: var(--text3); }
        
        .subtitle {
            color: var(--text2);
            font-size: 1rem;
        }
        
        .stats {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 1.5rem;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            color: var(--accent);
        }
        
        .stat-label {
            font-size: 0.75rem;
            color: var(--text3);
            text-transform: uppercase;
        }
        
        .section {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .section h2 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.1rem;
            color: var(--accent);
            margin-bottom: 1rem;
        }
        
        label {
            display: block;
            color: var(--text2);
            font-size: 0.8rem;
            margin-bottom: 0.3rem;
            text-transform: uppercase;
        }
        
        input, select, textarea {
            width: 100%;
            background: var(--bg);
            border: 1px solid rgba(179,136,255,0.12);
            color: var(--text);
            padding: 0.75rem;
            border-radius: 8px;
            font-family: inherit;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        textarea { resize: vertical; min-height: 80px; }
        
        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .checkbox-row input {
            width: auto;
            margin: 0;
        }
        
        .checkbox-row label {
            margin: 0;
            color: var(--text);
            text-transform: none;
            font-size: 0.9rem;
        }
        
        button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--accent2), var(--accent));
            color: #fff;
            border: none;
            border-radius: 8px;
            font-family: inherit;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover { box-shadow: 0 4px 30px rgba(124,77,255,0.3); transform: translateY(-1px); }
        button:disabled { background: var(--surface2); color: var(--text3); cursor: not-allowed; box-shadow: none; transform: none; }
        
        .connect-btn {
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
        }
        
        .connect-btn:hover {
            background: rgba(179,136,255,0.08);
            box-shadow: none;
            transform: none;
        }
        
        #status {
            text-align: center;
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 8px;
            display: none;
        }
        
        #status.success { display: block; background: rgba(0,230,118,0.08); color: var(--green); border: 1px solid rgba(0,230,118,0.2); }
        #status.error { display: block; background: rgba(255,82,82,0.08); color: var(--red); border: 1px solid rgba(255,82,82,0.2); }
        #status.pending { display: block; background: rgba(255,171,64,0.08); color: var(--orange); border: 1px solid rgba(255,171,64,0.2); }
        
        .wallet-info {
            text-align: center;
            color: var(--text3);
            font-size: 0.85rem;
            word-break: break-all;
        }
        
        .price-tag {
            text-align: center;
            color: var(--text2);
            margin-bottom: 1rem;
        }
        
        .price-tag span { color: var(--accent); font-size: 1.2rem; }

        /* Registry / Explorer */
        .agent-card {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 0.75rem;
        }
        
        .agent-card .name {
            color: var(--accent);
            font-size: 1rem;
            font-weight: 600;
        }
        
        .agent-card .verified {
            color: var(--blue);
            font-size: 0.8rem;
        }
        
        .agent-card .meta {
            color: var(--text3);
            font-size: 0.8rem;
            margin-top: 0.25rem;
        }
        
        .tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }
        
        .tab {
            color: var(--text3);
            cursor: pointer;
            padding: 0.5rem 0.5rem;
            border-bottom: 2px solid transparent;
            font-size: 0.9rem;
            -webkit-tap-highlight-color: rgba(179,136,255,0.2);
            user-select: none;
            transition: color 0.2s;
        }
        
        .tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        footer {
            text-align: center;
            padding: 2rem;
            color: var(--text3);
            font-size: 0.75rem;
        }
        
        footer a { color: var(--accent); text-decoration: none; }

        /* Agent Detail Modal ‚Äî Premium NFT Card */
        .modal-overlay { display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(8,6,14,0.95); z-index:1000; overflow-y:auto; justify-content:center; padding:1rem; }
        .modal-overlay.active { display:flex; }
        .modal-content { background:var(--surface); border:1px solid var(--border2); border-radius:20px; max-width:420px; width:100%; margin:auto; position:relative; overflow:hidden; box-shadow:0 0 80px rgba(179,136,255,0.05),0 0 40px rgba(0,0,0,0.5); padding:0; }
        .modal-content::before { content:''; position:absolute; top:0; left:0; right:0; height:1px; background:linear-gradient(90deg,transparent,rgba(179,136,255,0.2),transparent); z-index:1; }
        .modal-close { position:absolute; top:12px; right:12px; z-index:10; background:var(--surface); border:1px solid var(--border2); color:var(--text2); font-size:1rem; width:2rem; height:2rem; padding:0; border-radius:50%; cursor:pointer; display:flex; align-items:center; justify-content:center; }
        .modal-close:hover { color:var(--text); border-color:var(--accent); background:var(--surface2); }
        .nft-header { display:flex; justify-content:space-between; align-items:center; padding:14px 18px 10px; border-bottom:1px solid var(--border); }
        .nft-logo { font-family:'Space Grotesk',sans-serif; font-size:13px; font-weight:700; letter-spacing:2px; color:var(--accent); }
        .nft-logo span { color:var(--text3); font-weight:400; font-size:10px; margin-left:5px; }
        .nft-tid { font-size:11px; color:var(--text3); background:var(--bg); padding:3px 8px; border-radius:5px; border:1px solid var(--border); }
        .nft-hero { padding:16px; display:flex; justify-content:center; }
        .nft-hero-frame { position:relative; border-radius:14px; overflow:hidden; border:1px solid var(--border); background:var(--bg); padding:6px; }
        .nft-hero-frame svg { display:block; border-radius:8px; }
        .nft-identity { padding:0 18px 6px; display:flex; align-items:center; gap:8px; }
        .nft-name { font-family:'Space Grotesk',sans-serif; font-size:20px; font-weight:700; color:var(--text); }
        .nft-verified { width:16px; height:16px; background:var(--accent); border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:9px; color:#000; font-weight:900; flex-shrink:0; }
        .nft-desc { padding:0 18px 14px; font-size:11px; color:var(--text3); line-height:1.5; }
        .nft-stats { display:grid; grid-template-columns:repeat(5,1fr); gap:1px; background:var(--border); margin:0 18px 14px; border-radius:8px; overflow:hidden; }
        .nft-stat { background:var(--surface); padding:8px 4px; text-align:center; }
        .nft-sv { font-size:14px; font-weight:700; }
        .nft-sv.g { color:var(--green); } .nft-sv.b { color:var(--blue); } .nft-sv.o { color:var(--orange); } .nft-sv.p { color:var(--accent); } .nft-sv.c { color:#00e5ff; }
        .nft-sl { font-size:7px; color:var(--text3); text-transform:uppercase; letter-spacing:1px; margin-top:2px; }
        .nft-section { padding:0 18px 12px; }
        .nft-stitle { font-size:8px; text-transform:uppercase; letter-spacing:2px; color:var(--text3); margin-bottom:6px; display:flex; align-items:center; gap:6px; }
        .nft-stitle::after { content:''; flex:1; height:1px; background:var(--border); }
        .nft-pills { display:flex; flex-wrap:wrap; gap:4px; }
        .nft-pill { font-size:9px; padding:3px 8px; border-radius:16px; border:1px solid; line-height:1.3; }
        .nft-pill.g { color:var(--green); border-color:rgba(0,230,118,0.2); background:rgba(0,230,118,0.05); }
        .nft-pill.b { color:var(--blue); border-color:rgba(79,195,247,0.2); background:rgba(79,195,247,0.05); }
        .nft-pill.p { color:var(--accent); border-color:rgba(179,136,255,0.2); background:rgba(179,136,255,0.05); }
        .nft-pill.o { color:var(--orange); border-color:rgba(255,171,64,0.2); background:rgba(255,171,64,0.05); }
        .nft-pill.c { color:#00e5ff; border-color:rgba(0,229,255,0.2); background:rgba(0,229,255,0.05); }
        .nft-timeline { position:relative; padding-left:14px; }
        .nft-timeline::before { content:''; position:absolute; left:3px; top:3px; bottom:3px; width:1px; background:rgba(179,136,255,0.2); }
        .nft-tl-item { position:relative; margin-bottom:8px; padding-left:10px; }
        .nft-tl-item:last-child { margin-bottom:0; }
        .nft-tl-item::before { content:''; position:absolute; left:-12px; top:4px; width:6px; height:6px; border-radius:50%; background:var(--accent); border:2px solid var(--surface); }
        .nft-tl-ver { font-size:9px; color:var(--accent); font-weight:600; }
        .nft-tl-desc { font-size:8px; color:var(--text3); margin-top:1px; }
        .nft-details { display:grid; grid-template-columns:1fr 1fr; gap:5px; }
        .nft-detail { display:flex; flex-direction:column; gap:1px; }
        .nft-dl { font-size:7px; color:var(--text3); text-transform:uppercase; letter-spacing:1px; }
        .nft-dv { font-size:9px; color:var(--text2); word-break:break-all; }
        .nft-lineage { margin:0 18px 12px; padding:8px 12px; background:var(--bg); border:1px solid var(--border); border-radius:6px; display:flex; align-items:center; gap:7px; }
        .nft-lineage-dot { width:7px; height:7px; border-radius:50%; background:var(--accent); flex-shrink:0; box-shadow:0 0 6px rgba(179,136,255,0.2); }
        .nft-lineage-text { font-size:8px; color:var(--text3); }
        .nft-lineage-text b { color:var(--text2); font-weight:600; }
        .nft-footer { display:flex; justify-content:space-between; align-items:center; padding:10px 18px; border-top:1px solid var(--border); background:var(--bg); flex-wrap:wrap; gap:6px; }
        .nft-badges { display:flex; gap:6px; flex-wrap:wrap; }
        .nft-bdg { font-size:7px; padding:2px 6px; border-radius:3px; text-transform:uppercase; letter-spacing:1px; font-weight:600; }
        .nft-bdg.chain { color:var(--blue); background:rgba(79,195,247,0.07); border:1px solid rgba(79,195,247,0.15); }
        .nft-bdg.erc { color:var(--green); background:rgba(0,230,118,0.07); border:1px solid rgba(0,230,118,0.15); }
        .nft-bdg.soul { color:var(--accent); background:rgba(179,136,255,0.07); border:1px solid rgba(179,136,255,0.15); }
        .nft-bdg.link8004 { color:var(--orange); background:rgba(255,171,64,0.07); border:1px solid rgba(255,171,64,0.15); }
        .nft-footer a { color:var(--accent); text-decoration:none; font-size:8px; }
        .nft-footer a:hover { text-decoration:underline; }

        /* Clickable agent cards */
        .agent-card { cursor: pointer; transition: all 0.3s; display: flex; align-items: center; gap: 1rem; }
        .agent-card:hover { border-color: var(--accent); box-shadow: 0 0 20px rgba(179,136,255,0.05); }
        .agent-card .faceqr-thumb { flex-shrink: 0; border-radius: 8px; overflow: hidden; line-height: 0; }
        .agent-card .card-info { flex: 1; min-width: 0; }

        /* Verified agent cards ‚Äî green glow */
        .agent-card.verified-card { border-color: rgba(0,230,118,0.25); box-shadow: 0 0 15px rgba(0,230,118,0.06); }
        .agent-card.verified-card:hover { border-color: rgba(0,230,118,0.5); box-shadow: 0 0 25px rgba(0,230,118,0.1); }
        .verified-badge { display:inline-flex; align-items:center; gap:3px; font-size:0.75rem; color:var(--green); background:rgba(0,230,118,0.08); padding:2px 7px; border-radius:10px; border:1px solid rgba(0,230,118,0.2); font-weight:600; }
        .verified-badge::before { content:'‚úì'; font-weight:900; }
        .unverified-label { font-size:0.7rem; color:var(--text3); opacity:0.5; font-style:italic; }

        /* Explorer filter toggle */
        .filter-toggle { display:flex; align-items:center; gap:0.5rem; margin-bottom:1rem; }
        .filter-toggle input[type=checkbox] { width:auto; accent-color:var(--green); }
        .filter-toggle label { margin:0; color:var(--text2); font-size:0.85rem; text-transform:none; cursor:pointer; }

        /* Verification request button */
        .verify-request-btn { background:transparent; border:1px solid var(--green); color:var(--green); padding:0.75rem; margin-top:0.75rem; font-size:0.9rem; }
        .verify-request-btn:hover { background:rgba(0,230,118,0.08); box-shadow:none; }
        .verify-request-btn:disabled { border-color:var(--text3); color:var(--text3); background:transparent; }
        .verify-status { text-align:center; font-size:0.85rem; margin-top:0.5rem; padding:0.5rem; border-radius:6px; }
        .verify-status.requested { color:var(--orange); background:rgba(255,171,64,0.08); border:1px solid rgba(255,171,64,0.15); }
        .verify-status.already { color:var(--green); background:rgba(0,230,118,0.08); border:1px solid rgba(0,230,118,0.15); }

        /* Modal verified badge ‚Äî bigger */
        .nft-verified-big { display:inline-flex; align-items:center; gap:4px; background:rgba(0,230,118,0.12); color:var(--green); padding:3px 10px; border-radius:12px; border:1px solid rgba(0,230,118,0.25); font-size:11px; font-weight:700; }
        .nft-verified-big::before { content:'‚úì'; font-size:13px; font-weight:900; }
        .nft-unverified-badge { display:inline-flex; align-items:center; font-size:10px; color:var(--text3); opacity:0.6; font-style:italic; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Helixa</h1>
            <p class="subtitle">Identity infrastructure for AI agents ‚Äî powered by the AgentDNA Protocol</p>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="totalAgents">‚Äî</div>
                    <div class="stat-label">Agents Registered</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="mintPriceDisplay">‚Äî</div>
                    <div class="stat-label">Mint Price (ETH)</div>
                </div>
                <div class="stat">
                    <div class="stat-value">Base</div>
                    <div class="stat-label">Network</div>
                </div>
            </div>
        </header>
        
        <div class="tabs">
            <div class="tab active" data-tab="mint">Mint DNA</div>
            <div class="tab" data-tab="explore">Explorer</div>
            <div class="tab" data-tab="lookup">Lookup</div>
        </div>
        
        <!-- MINT TAB -->
        <div class="tab-content active" id="tab-mint">
            <div class="section" id="connect-section">
                <button class="connect-btn" id="connectBtn" onclick="connectWallet()">
                    Connect Wallet
                </button>
                <p class="wallet-info" id="walletInfo"></p>
            </div>
            
            <div class="section">
                <h2>üß¨ Register Your Agent</h2>
                
                <div class="price-tag">
                    Mint price: <span id="mintPriceInline">Free (first 100)</span>
                </div>
                
                <label>Agent Name *</label>
                <input type="text" id="agentName" placeholder="e.g., ResearchBot Alpha">
                
                <label>.agent Name <span style="font-size:0.8em;opacity:0.6">(optional ‚Äî claim your onchain handle)</span></label>
                <div style="display:flex;gap:0.5rem;align-items:center">
                    <input type="text" id="dotAgentName" placeholder="e.g., researchbot" style="flex:1" oninput="checkAgentName(this.value)">
                    <span style="opacity:0.6">.agent</span>
                </div>
                <div id="agentNameStatus" style="font-size:0.8em;margin-top:0.25rem;min-height:1.2em"></div>
                
                <label>Agent Wallet Address *</label>
                <input type="text" id="agentAddress" placeholder="0x...">
                
                <label>Framework</label>
                <select id="framework">
                    <option value="custom">Custom</option>
                    <option value="langchain">LangChain</option>
                    <option value="crewai">CrewAI</option>
                    <option value="autogpt">AutoGPT</option>
                    <option value="bankr">Bankr</option>
                    <option value="virtuals">Virtuals</option>
                    <option value="eliza">ElizaOS</option>
                    <option value="openclaw">OpenClaw</option>
                </select>
                
                <label>Description</label>
                <textarea id="description" placeholder="What does your agent do?"></textarea>
                
                <label>Capabilities (comma separated)</label>
                <input type="text" id="capabilities" placeholder="e.g., text-generation, code, research">
                
                <label>Model</label>
                <input type="text" id="model" placeholder="e.g., gpt-4, claude-3, llama-3">
                
                <label>Source Repository (optional)</label>
                <input type="text" id="sourceRepo" placeholder="https://github.com/...">
                
                <div class="checkbox-row">
                    <input type="checkbox" id="soulbound">
                    <label for="soulbound">Soulbound (non-transferable)</label>
                </div>

                <!-- ERC-8004 Integration -->
                <div style="border-top: 1px solid #222; margin: 1rem 0; padding-top: 1rem;">
                    <h2 style="font-size: 0.95rem; color: #00aaff; margin-bottom: 0.75rem;">üîó ERC-8004 Cross-Registry</h2>
                    
                    <div class="checkbox-row">
                        <input type="checkbox" id="import8004" onchange="toggle8004Import()">
                        <label for="import8004">Import existing 8004.org identity</label>
                    </div>
                    <div id="import8004Section" style="display:none;">
                        <label>Your 8004 Token ID</label>
                        <input type="text" id="existing8004Id" placeholder="e.g., 1" oninput="preview8004Import()">
                        <div id="import8004Preview" style="font-size:0.8rem; color:#888; margin-top:-0.5rem; margin-bottom:1rem;"></div>
                    </div>
                    
                    <div class="checkbox-row">
                        <input type="checkbox" id="register8004" onchange="toggle8004Register()">
                        <label for="register8004">Also register on 8004.org (cross-chain identity)</label>
                    </div>
                    <div id="register8004Section" style="display:none;">
                        <p style="font-size:0.8rem; color:#888; margin-bottom:0.75rem;">
                            This will mint an ERC-8004 identity NFT on the official 8004.org registry alongside your AgentDNA. 
                            Gives you cross-chain portability across 12+ networks.
                        </p>
                    </div>
                </div>
                
                <button id="mintBtn" onclick="mintAgent()" disabled>
                    Connect Wallet to Mint
                </button>
                
                <div id="status"></div>
            </div>

            <!-- Soul Builder (appears after mint) -->
            <div class="section" id="soulBuilder" style="display:none; border-color:#00aaff;">
                <h2 style="color:#00aaff;">üß¨ Define Your Agent's Soul</h2>
                <p style="color:#888; font-size:0.85rem; margin-bottom:1rem;">
                    You just minted AgentDNA <span id="soulTokenId" style="color:#b388ff;"></span>. Now give it a soul ‚Äî traits and personality that display on the NFT card.
                </p>

                <div style="border-bottom:1px solid #222; padding-bottom:1rem; margin-bottom:1rem;">
                    <h2 style="font-size:0.95rem; color:#00aaff; margin-bottom:0.75rem;">Personality</h2>
                    
                    <label>Temperament</label>
                    <select id="soulTemperament">
                        <option value="analytical">Analytical</option>
                        <option value="creative">Creative</option>
                        <option value="aggressive">Aggressive</option>
                        <option value="cautious">Cautious</option>
                        <option value="chaotic">Chaotic</option>
                    </select>
                    
                    <label>Communication Style</label>
                    <select id="soulCommStyle">
                        <option value="formal">Formal</option>
                        <option value="casual">Casual</option>
                        <option value="snarky">Snarky</option>
                        <option value="verbose">Verbose</option>
                        <option value="minimal">Minimal</option>
                    </select>
                    
                    <label>Risk Tolerance (1-10)</label>
                    <input type="range" id="soulRisk" min="1" max="10" value="5" oninput="this.nextElementSibling.textContent=this.value" style="margin-bottom:0;">
                    <span style="color:#b388ff; font-size:0.9rem;">5</span>
                    
                    <label style="margin-top:0.75rem;">Autonomy Level (1-10)</label>
                    <input type="range" id="soulAutonomy" min="1" max="10" value="5" oninput="this.nextElementSibling.textContent=this.value" style="margin-bottom:0;">
                    <span style="color:#b388ff; font-size:0.9rem;">5</span>
                    
                    <label style="margin-top:0.75rem;">Alignment</label>
                    <select id="soulAlignment">
                        <option value="lawful-good">Lawful Good</option>
                        <option value="neutral-good">Neutral Good</option>
                        <option value="chaotic-good">Chaotic Good</option>
                        <option value="lawful-neutral">Lawful Neutral</option>
                        <option value="true-neutral">True Neutral</option>
                        <option value="chaotic-neutral">Chaotic Neutral</option>
                        <option value="lawful-evil">Lawful Evil</option>
                        <option value="neutral-evil">Neutral Evil</option>
                        <option value="chaotic-evil">Chaotic Evil</option>
                    </select>
                    
                    <label>Specialization</label>
                    <select id="soulSpec">
                        <option value="researcher">Researcher</option>
                        <option value="trader">Trader</option>
                        <option value="creator">Creator</option>
                        <option value="guardian">Guardian</option>
                        <option value="oracle">Oracle</option>
                        <option value="operator">Operator</option>
                    </select>
                </div>

                <div style="margin-bottom:1rem;">
                    <h2 style="font-size:0.95rem; color:#00aaff; margin-bottom:0.75rem;">üí≥ Payment Infrastructure</h2>
                    
                    <label style="display:flex; align-items:center; gap:0.5rem; cursor:pointer; padding:0.5rem 0;">
                        <input type="checkbox" id="x402Compatible" style="width:auto; accent-color:#00aaff;" onchange="document.getElementById('paymentDetails').style.display=this.checked?'block':'none'">
                        <span style="font-size:0.85rem;">x402 Compatible</span>
                        <span style="font-size:0.7rem; color:#666; margin-left:auto;">HTTP-native payments</span>
                    </label>
                    
                    <div id="paymentDetails" style="display:none; margin-top:0.5rem; padding:0.75rem; background:rgba(0,200,83,0.05); border:1px solid rgba(0,200,83,0.15); border-radius:8px;">
                        <label style="font-size:0.8rem; color:#aaa;">Payment Provider</label>
                        <select id="payProvider" style="margin-bottom:0.5rem;">
                            <option value="">Select provider...</option>
                            <option value="bankr">Bankr</option>
                            <option value="coinbase">Coinbase Commerce</option>
                            <option value="stripe">Stripe</option>
                            <option value="self-custody">Self-Custody</option>
                            <option value="other">Other</option>
                        </select>
                        
                        <label style="font-size:0.8rem; color:#aaa;">Payment Wallet Address</label>
                        <input type="text" id="payWallet" placeholder="0x... (wallet that receives payments)" style="margin-bottom:0.5rem;">
                        
                        <label style="font-size:0.8rem; color:#aaa;">Accepted Tokens</label>
                        <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-bottom:0.5rem;">
                            <label style="display:flex; align-items:center; gap:4px; cursor:pointer; font-size:0.8rem;">
                                <input type="checkbox" class="payToken" value="USDC" style="width:auto;" checked> USDC
                            </label>
                            <label style="display:flex; align-items:center; gap:4px; cursor:pointer; font-size:0.8rem;">
                                <input type="checkbox" class="payToken" value="ETH" style="width:auto;"> ETH
                            </label>
                            <label style="display:flex; align-items:center; gap:4px; cursor:pointer; font-size:0.8rem;">
                                <input type="checkbox" class="payToken" value="USDT" style="width:auto;"> USDT
                            </label>
                            <label style="display:flex; align-items:center; gap:4px; cursor:pointer; font-size:0.8rem;">
                                <input type="checkbox" class="payToken" value="DAI" style="width:auto;"> DAI
                            </label>
                        </div>
                        
                        <label style="font-size:0.8rem; color:#aaa;">x402 Endpoint (optional)</label>
                        <input type="text" id="payEndpoint" placeholder="https://api.youragent.com/pay" style="margin-bottom:0.5rem;">
                        
                        <label style="font-size:0.8rem; color:#aaa;">Payment Chain</label>
                        <select id="payChain" style="margin-bottom:0;">
                            <option value="base">Base</option>
                            <option value="ethereum">Ethereum</option>
                            <option value="arbitrum">Arbitrum</option>
                            <option value="optimism">Optimism</option>
                            <option value="polygon">Polygon</option>
                        </select>
                    </div>
                </div>

                <div style="margin-bottom:1rem;">
                    <h2 style="font-size:0.95rem; color:#00aaff; margin-bottom:0.75rem;">Traits</h2>
                    <p style="color:#666; font-size:0.8rem; margin-bottom:0.5rem;">Add up to 8 traits. Each trait has a name and category.</p>
                    <div id="traitRows"></div>
                    <button onclick="addTraitRow()" style="width:auto; padding:0.5rem 1rem; background:transparent; border:1px solid #00aaff; color:#00aaff; font-size:0.8rem; margin-top:0.5rem;">+ Add Trait</button>
                </div>

                <button id="soulSubmitBtn" onclick="submitSoul()" style="background:#00aaff; color:#0a0a0a;">
                    ‚ö° Set Soul & Traits
                </button>
                <button onclick="showShareCard(mintedTokenId);document.getElementById('soulBuilder').style.display='none'" style="background:transparent; border:1px solid #444; color:#888; margin-top:0.5rem; font-size:0.85rem;">
                    Skip for now
                </button>
                <div id="soulStatus" style="margin-top:0.75rem; font-size:0.85rem;"></div>

                <!-- Verification Request -->
                <div style="border-top:1px solid #222; margin-top:1rem; padding-top:1rem;">
                    <h2 style="font-size:0.95rem; color:var(--green); margin-bottom:0.5rem;">‚úì Agent Verification</h2>
                    <p style="color:#888; font-size:0.8rem; margin-bottom:0.75rem;">
                        Prove your agent is real by signing a challenge message with the agent's wallet. 
                        Verified agents get a green badge in the explorer.
                    </p>
                    <button class="verify-request-btn" id="verifyRequestBtn" onclick="requestVerification()">
                        üîê Request Verification
                    </button>
                    <div id="verifyStatus"></div>
                </div>
            </div>

            <!-- Share Card (appears after soul is set) -->
            <div id="shareCard" style="display:none; margin-top:1.5rem; border:1px solid rgba(179,136,255,0.3); border-radius:12px; padding:1.5rem; background:rgba(179,136,255,0.05); text-align:center;">
                <h3 style="color:#b388ff; margin-bottom:0.5rem;">üéâ Your Aura is live onchain!</h3>
                <div id="shareAuraPreview" style="display:flex; justify-content:center; margin:1rem 0;"></div>
                <p style="color:#aaa; font-size:0.85rem; margin-bottom:1rem;">Share it with the world üëá</p>
                <div id="shareTweetText" style="background:#111; border:1px solid #333; border-radius:8px; padding:1rem; text-align:left; color:#ccc; font-size:0.9rem; margin-bottom:1rem; white-space:pre-wrap; cursor:pointer;" onclick="navigator.clipboard.writeText(this.innerText);this.style.borderColor='#b388ff';setTimeout(()=>this.style.borderColor='#333',1500);" title="Click to copy"></div>
                <div style="display:flex; gap:0.75rem; justify-content:center; flex-wrap:wrap;">
                    <a id="shareTweetLink" href="#" target="_blank" style="display:inline-block; background:linear-gradient(135deg,#b388ff,#64b5f6,#ff80ab); color:#0a0a0f; padding:0.6rem 1.5rem; border-radius:8px; text-decoration:none; font-weight:700; font-size:0.9rem;">Post on X ‚Üí</a>
                    <button onclick="navigator.clipboard.writeText(document.getElementById('shareTweetText').innerText);this.textContent='Copied!';setTimeout(()=>this.textContent='üìã Copy Text',1500)" style="background:transparent; border:1px solid #b388ff; color:#b388ff; padding:0.6rem 1.5rem; border-radius:8px; font-size:0.9rem; cursor:pointer;">üìã Copy Text</button>
                    <button onclick="document.getElementById('shareCard').style.display='none';document.getElementById('soulBuilder').style.display='none'" style="background:transparent; border:1px solid #444; color:#888; padding:0.6rem 1rem; border-radius:8px; font-size:0.85rem; cursor:pointer;">Done</button>
                </div>
            </div>
        </div>
        
        <!-- EXPLORE TAB -->
        <div class="tab-content" id="tab-explore">
            <div class="section">
                <h2>üì° Registered Agents</h2>
                <div class="filter-toggle">
                    <input type="checkbox" id="filterVerified" onchange="filterAgentList()">
                    <label for="filterVerified">Show verified only</label>
                </div>
                <div id="agentList">
                    <p style="color: #666; text-align: center;">Connect wallet to browse agents</p>
                </div>
            </div>
        </div>
        
        <!-- LOOKUP TAB -->
        <div class="tab-content" id="tab-lookup">
            <div class="section">
                <h2>üîç Agent Lookup</h2>
                <label>Agent Address or Token ID</label>
                <input type="text" id="lookupInput" placeholder="0x... or token ID">
                <button onclick="lookupAgent()">Search</button>
                <div id="lookupResult" style="margin-top: 1rem;"></div>
            </div>
        </div>
        
        <footer>
            Helixa ‚Äî Built on <a href="https://base.org" target="_blank">Base</a>
            <br>Powered by the AgentDNA Protocol ¬∑ The identity layer for the AI agent economy
        </footer>
    </div>

    <!-- Agent Detail Modal -->
    <div class="modal-overlay" id="agentModal" onclick="if(event.target===this)closeModal()">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">‚úï</button>
            <div id="modalBody">Loading...</div>
        </div>
    </div>

    <script>
        // Tab switching ‚Äî runs immediately, no dependencies
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
            });
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js"></script>
    <script>
        // CONTRACT CONFIG ‚Äî UPDATE AFTER DEPLOYMENT
        const CONTRACT_ADDRESS = "0x665971e7bf8ec90c3066162c5b396604b3cd7711"; // Base mainnet
        const CHAIN_ID = 8453; // Base
        const CHAIN_NAME = "Base";
        const RPC_URL = "https://base.drpc.org";
        
        const ABI = [
            "function mint(address agentAddress, string name, string framework, string tokenURI_, bool soulbound, string version, uint256 parentTokenId) external payable returns (uint256)",
            "function mintPrice() view returns (uint256)",
            "function totalAgents() view returns (uint256)",
            "function getAgent(uint256 tokenId) view returns (tuple(address agentAddress, string name, string framework, uint256 mintedAt, bool verified, bool soulbound, uint256 generation, uint256 parentDNA, string currentVersion, uint256 mutationCount))",
            "function getAgentByAddress(address agentAddress) view returns (uint256 tokenId, tuple(address agentAddress, string name, string framework, uint256 mintedAt, bool verified, bool soulbound, uint256 generation, uint256 parentDNA, string currentVersion, uint256 mutationCount))",
            "function hasAgent(address) view returns (bool)",
            "function isVerified(uint256) view returns (bool)",
            "function tokenURI(uint256) view returns (string)",
            "function ownerOf(uint256) view returns (address)",
            "function getTraits(uint256 tokenId) view returns (tuple(string name, string category, uint256 addedAt)[])",
            "function getPersonality(uint256 tokenId) view returns (tuple(string temperament, string communicationStyle, uint8 riskTolerance, uint8 autonomyLevel, string alignment, string specialization))",
            "function points(address owner) view returns (uint256)",
            "event AgentMinted(uint256 indexed tokenId, address indexed agentAddress, string name, string framework)",
            "function setPersonality(uint256 tokenId, string temperament, string communicationStyle, uint8 riskTolerance, uint8 autonomyLevel, string alignment, string specialization) external",
            "function addTrait(uint256 tokenId, string name, string category) external payable",
            "function traitFee() view returns (uint256)"
        ];
        
/**
 * Helixa Aura Generator v3.0
 * QR-aesthetic faces with 10 eye types, 10 mouth types,
 * rarity tiers (Common ‚Üí Legendary) with gradient/chrome/glow effects.
 * Every personality trait shapes the visual. Deterministic.
 */

/**
 * Helixa Aura Generator v3.0
 * QR-aesthetic faces with 10 eye types, 10 mouth types,
 * rarity tiers (Common ‚Üí Legendary) with gradient/chrome/glow effects.
 * Every personality trait shapes the visual. Deterministic.
 */

function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}

function seededRandom(seed) {
  let s = seed;
  return function() {
    s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
    return (s >>> 0) / 0xFFFFFFFF;
  };
}

const FRAMEWORK_SHAPES = {
  eliza:     { faceRadius: 0.42, baseHue: 280 },
  openclaw:  { faceRadius: 0.40, baseHue: 150 },
  langchain: { faceRadius: 0.41, baseHue: 200 },
  crewai:    { faceRadius: 0.39, baseHue: 30 },
  autogpt:   { faceRadius: 0.41, baseHue: 0 },
  bankr:     { faceRadius: 0.41, baseHue: 45 },
  virtuals:  { faceRadius: 0.42, baseHue: 320 },
  custom:    { faceRadius: 0.40, baseHue: 60 },
};

const ALIGNMENT_SHIFT = {
  'lawful-good':0,'neutral-good':10,'chaotic-good':20,
  'lawful-neutral':-10,'true-neutral':0,'chaotic-neutral':30,
  'lawful-evil':-20,'neutral-evil':-30,'chaotic-evil':-40,
};

// ============ RARITY SYSTEM ============
// Rarity determined by points + mutations. Earned, not random.
function getRarity(points, mutationCount) {
  const score = points + mutationCount * 50;
  if (score >= 1000) return 'legendary';  // top tier
  if (score >= 500)  return 'epic';       // chrome
  if (score >= 200)  return 'rare';       // gradient
  return 'common';                         // solid
}

const RARITY_COLORS = {
  common:    { label: 'Common',    borderOpacity: 0 },
  rare:      { label: 'Rare',      borderOpacity: 0.3 },
  epic:      { label: 'Epic',      borderOpacity: 0.5 },
  legendary: { label: 'Legendary', borderOpacity: 0.7 },
};

// ============ 10 EYE TYPES ============
// Types 0-6: common, 7-8: rare, 9: legendary
const EYE_TYPES = [
  'round',      // 0 - classic round
  'diamond',    // 1 - diamond shape
  'slit',       // 2 - horizontal slit
  'hollow',     // 3 - ring/hollow circle
  'cross',      // 4 - cross/plus
  'square',     // 5 - block
  'dot',        // 6 - single pixel
  'scanner',    // 7 - rare: horizontal scan line with dot
  'void',       // 8 - rare: inverted ring (big empty center)
  'nova',       // 9 - legendary: starburst
];

function getEyeType(specialization, rng, rarity) {
  // Base mapping from specialization
  const specMap = {
    'researcher': 0, 'trader': 1, 'guardian': 2, 'oracle': 3,
    'creator': 4, 'operator': 5, 'analyst': 0, 'defi': 1,
    'security': 2, 'social': 6, 'infrastructure': 5, 'governance': 3,
  };
  let base = specMap[specialization] !== undefined ? specMap[specialization] : Math.floor(rng() * 7);
  
  // Rarity can unlock higher eye types
  if (rarity === 'legendary' && rng() < 0.6) base = 9;
  else if (rarity === 'epic' && rng() < 0.4) base = 7 + Math.floor(rng() * 2);
  else if (rarity === 'rare' && rng() < 0.25) base = 7;
  
  return base;
}

function drawEye(grid, G, ex, ey, eyeR, eyeType) {
  switch (eyeType) {
    case 0: // round
      for (let dy = -eyeR + 1; dy <= eyeR - 1; dy++)
        for (let dx = -eyeR + 1; dx <= eyeR - 1; dx++)
          if (Math.abs(dx) + Math.abs(dy) <= eyeR)
            if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
              grid[ey + dy][ex + dx] = 2;
      break;
    case 1: // diamond
      for (let d = 0; d <= eyeR; d++) {
        if (ey - d >= 0) grid[ey - d][ex] = 2;
        if (ey + d < G) grid[ey + d][ex] = 2;
        if (ex - d >= 0) grid[ey][ex - d] = 2;
        if (ex + d < G) grid[ey][ex + d] = 2;
      }
      break;
    case 2: // slit
      for (let dx = -eyeR; dx <= eyeR; dx++)
        if (ex + dx >= 0 && ex + dx < G) grid[ey][ex + dx] = 2;
      break;
    case 3: // hollow circle
      for (let dy = -eyeR; dy <= eyeR; dy++)
        for (let dx = -eyeR; dx <= eyeR; dx++)
          if (dx * dx + dy * dy <= eyeR * eyeR)
            if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
              grid[ey + dy][ex + dx] = 2;
      grid[ey][ex] = 0; // hollow center
      break;
    case 4: // cross
      for (let d = 0; d <= eyeR; d++) {
        if (ey - d >= 0) grid[ey - d][ex] = 2;
        if (ey + d < G) grid[ey + d][ex] = 2;
        if (ex - d >= 0) grid[ey][ex - d] = 2;
        if (ex + d < G) grid[ey][ex + d] = 2;
      }
      for (let d = 1; d <= eyeR - 1; d++) {
        if (ey-d>=0 && ex-d>=0) grid[ey-d][ex-d] = 2;
        if (ey-d>=0 && ex+d<G) grid[ey-d][ex+d] = 2;
        if (ey+d<G && ex-d>=0) grid[ey+d][ex-d] = 2;
        if (ey+d<G && ex+d<G) grid[ey+d][ex+d] = 2;
      }
      break;
    case 5: // square
      for (let dy = -1; dy <= 1; dy++)
        for (let dx = -eyeR + 1; dx <= eyeR - 1; dx++)
          if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
            grid[ey + dy][ex + dx] = 2;
      break;
    case 6: // dot
      grid[ey][ex] = 2;
      if (ex + 1 < G) grid[ey][ex + 1] = 2;
      break;
    case 7: // scanner (rare) - horizontal line with bright center dot
      for (let dx = -eyeR - 1; dx <= eyeR + 1; dx++)
        if (ex + dx >= 0 && ex + dx < G) grid[ey][ex + dx] = 2;
      // vertical tick at center
      if (ey - 1 >= 0) grid[ey - 1][ex] = 2;
      if (ey + 1 < G) grid[ey + 1][ex] = 2;
      break;
    case 8: // void (rare) - big ring, empty inside
      for (let dy = -eyeR - 1; dy <= eyeR + 1; dy++)
        for (let dx = -eyeR - 1; dx <= eyeR + 1; dx++) {
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= eyeR + 1 && dist >= eyeR - 0.5)
            if (ey + dy >= 0 && ey + dy < G && ex + dx >= 0 && ex + dx < G)
              grid[ey + dy][ex + dx] = 2;
        }
      break;
    case 9: // nova (legendary) - 8-point starburst
      for (let d = 0; d <= eyeR + 1; d++) {
        // Cardinal
        if (ey - d >= 0) grid[ey - d][ex] = 2;
        if (ey + d < G) grid[ey + d][ex] = 2;
        if (ex - d >= 0) grid[ey][ex - d] = 2;
        if (ex + d < G) grid[ey][ex + d] = 2;
        // Diagonal
        if (ey-d>=0 && ex-d>=0) grid[ey-d][ex-d] = 2;
        if (ey-d>=0 && ex+d<G) grid[ey-d][ex+d] = 2;
        if (ey+d<G && ex-d>=0) grid[ey+d][ex-d] = 2;
        if (ey+d<G && ex+d<G) grid[ey+d][ex+d] = 2;
      }
      // Core glow pixel
      grid[ey][ex] = 4; // special: accent-bright
      break;
  }
}

// ============ 10 MOUTH TYPES ============
// Types 0-6: common, 7-8: rare, 9: legendary
const MOUTH_TYPES = [
  'line',       // 0 - straight line (formal)
  'smile',      // 1 - curved up (casual)
  'smirk',      // 2 - asymmetric (snarky)
  'open',       // 3 - oval opening (verbose)
  'dot',        // 4 - tiny dot (minimal)
  'frown',      // 5 - curved down
  'zigzag',     // 6 - jagged line
  'fangs',      // 7 - rare: line with downward ticks
  'grin',       // 8 - rare: wide smile with teeth marks
  'vortex',     // 9 - legendary: spiral/circular mouth
];

function getMouthType(commStyle, rng, rarity) {
  const commMap = {
    'formal': 0, 'casual': 1, 'snarky': 2, 'verbose': 3,
    'minimal': 4, 'analytical': 0, 'friendly': 1, 'blunt': 5,
    'cryptic': 6, 'diplomatic': 0,
  };
  let base = commMap[commStyle] !== undefined ? commMap[commStyle] : Math.floor(rng() * 7);
  
  if (rarity === 'legendary' && rng() < 0.6) base = 9;
  else if (rarity === 'epic' && rng() < 0.4) base = 7 + Math.floor(rng() * 2);
  else if (rarity === 'rare' && rng() < 0.25) base = 7 + Math.floor(rng() * 2);
  
  return base;
}

function drawMouth(grid, G, cx, mouthY, mW, mouthType) {
  switch (mouthType) {
    case 0: // line
      for (let dx = -mW + 1; dx <= mW - 1; dx++) {
        const mx = Math.round(cx + dx);
        if (mx >= 0 && mx < G) grid[mouthY][mx] = 1;
      }
      break;
    case 1: // smile
      for (let dx = -mW; dx <= mW; dx++) {
        const mx = Math.round(cx + dx);
        const curve = Math.round(0.3 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
        if (my + 1 < G && Math.abs(dx) < mW - 1 && mx >= 0 && mx < G) grid[my + 1][mx] = 1;
      }
      break;
    case 2: // smirk
      for (let dx = -mW; dx <= mW; dx++) {
        const mx = Math.round(cx + dx);
        const curve = dx > 0 ? Math.round(-0.2 * (dx * dx) / (mW || 1)) : Math.round(0.1 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      break;
    case 3: // open
      for (let dy = -1; dy <= 2; dy++)
        for (let dx = -mW + 1; dx <= mW - 1; dx++) {
          const mx = Math.round(cx + dx);
          const my = mouthY + dy;
          if (mx >= 0 && mx < G && my >= 0 && my < G)
            if (dy === -1 || dy === 2 || Math.abs(dx) === mW - 1)
              grid[my][mx] = 1;
        }
      break;
    case 4: // dot
      grid[mouthY][Math.round(cx)] = 1;
      if (Math.round(cx) + 1 < G) grid[mouthY][Math.round(cx) + 1] = 1;
      break;
    case 5: // frown
      for (let dx = -mW; dx <= mW; dx++) {
        const mx = Math.round(cx + dx);
        const curve = Math.round(-0.25 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      break;
    case 6: // zigzag
      for (let dx = -mW + 1; dx <= mW - 1; dx++) {
        const mx = Math.round(cx + dx);
        const my = mouthY + (dx % 2 === 0 ? 0 : 1);
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      break;
    case 7: // fangs (rare) - line with two downward ticks
      for (let dx = -mW + 1; dx <= mW - 1; dx++) {
        const mx = Math.round(cx + dx);
        if (mx >= 0 && mx < G) grid[mouthY][mx] = 1;
      }
      // Fang ticks
      const fangL = Math.round(cx - mW * 0.5);
      const fangR = Math.round(cx + mW * 0.5);
      if (mouthY + 1 < G && fangL >= 0) grid[mouthY + 1][fangL] = 1;
      if (mouthY + 2 < G && fangL >= 0) grid[mouthY + 2][fangL] = 1;
      if (mouthY + 1 < G && fangR < G) grid[mouthY + 1][fangR] = 1;
      if (mouthY + 2 < G && fangR < G) grid[mouthY + 2][fangR] = 1;
      break;
    case 8: // grin (rare) - wide smile with teeth gaps
      for (let dx = -mW - 1; dx <= mW + 1; dx++) {
        const mx = Math.round(cx + dx);
        const curve = Math.round(0.2 * (dx * dx) / (mW || 1));
        const my = mouthY + curve;
        if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
      }
      // Teeth marks (gaps in a row above)
      for (let dx = -mW + 1; dx <= mW - 1; dx += 2) {
        const mx = Math.round(cx + dx);
        if (mx >= 0 && mx < G && mouthY - 1 >= 0) grid[mouthY - 1][mx] = 1;
      }
      break;
    case 9: // vortex (legendary) - circular mouth
      for (let dy = -2; dy <= 2; dy++)
        for (let dx = -2; dx <= 2; dx++) {
          const dist = Math.sqrt(dx * dx + dy * dy);
          const mx = Math.round(cx + dx);
          const my = mouthY + dy;
          if (dist >= 1.2 && dist <= 2.2)
            if (mx >= 0 && mx < G && my >= 0 && my < G) grid[my][mx] = 1;
        }
      break;
  }
}

function buildPalette(address, riskTolerance, alignment) {
  const hash = simpleHash(address || '0x0');
  let hue = (hash % 360 + (ALIGNMENT_SHIFT[alignment] || 0) + 360) % 360;
  const sat = Math.max(30, Math.min(100, 65 + (riskTolerance - 5) * 5));
  return {
    primary: `hsl(${hue}, ${sat}%, 55%)`,
    secondary: `hsl(${(hue + 35) % 360}, ${sat - 10}%, 45%)`,
    accent: `hsl(${(hue + 180) % 360}, ${Math.min(100, sat + 10)}%, 60%)`,
    accentBright: `hsl(${(hue + 180) % 360}, ${Math.min(100, sat + 20)}%, 80%)`,
    glow: `hsl(${hue}, ${sat}%, 55%)`,
    hue, sat,
  };
}

function generateAura(agentData, size) {
  size = size || 400;
  const G = 25;
  const cs = size / G;

  const address = agentData.agentAddress || agentData.address || '0x0000';
  const framework = agentData.framework || 'custom';
  const name = agentData.name || 'Agent';
  const traitCount = agentData.traitCount || 0;
  const mutationCount = agentData.mutationCount || 0;
  const soulbound = agentData.soulbound || false;
  const points = agentData.points || 0;
  const generation = agentData.generation || 0;
  const temperament = agentData.temperament || 'analytical';
  const commStyle = agentData.communicationStyle || 'formal';
  const riskTolerance = agentData.riskTolerance || 5;
  const autonomyLevel = agentData.autonomyLevel || 5;
  const alignment = agentData.alignment || 'true-neutral';
  const specialization = agentData.specialization || 'researcher';

  const seed = simpleHash(address + name + framework + temperament + alignment + specialization + riskTolerance + autonomyLevel);
  const rng = seededRandom(seed);
  const fwStyle = FRAMEWORK_SHAPES[framework] || FRAMEWORK_SHAPES.custom;
  const colors = buildPalette(address, riskTolerance, alignment);
  const cx = G / 2, cy = G / 2;
  const fR = G * fwStyle.faceRadius;

  // Determine rarity
  const rarity = getRarity(points, mutationCount);

  const grid = Array.from({length: G}, () => Array(G).fill(0));
  // 0=empty, 1=primary, 2=accent(eyes), 3=secondary, 4=accent-bright(legendary)

  // --- QR Corners ---
  function qr(sx, sy) {
    for (let y = 0; y < 7; y++)
      for (let x = 0; x < 7; x++)
        if (y === 0 || y === 6 || x === 0 || x === 6 || (y >= 2 && y <= 4 && x >= 2 && x <= 4))
          if (sy + y < G && sx + x < G) grid[sy + y][sx + x] = 1;
  }
  qr(0, 0); qr(G - 7, 0); qr(0, G - 7);

  // --- Face outline ---
  for (let angle = 0; angle < 360; angle += 2) {
    const rad = (angle * Math.PI) / 180;
    for (let thickness = 0; thickness < 2; thickness++) {
      const r = fR - thickness * 0.5 + Math.sin(angle * 3 * Math.PI / 180) * 0.6;
      const fx = Math.round(cx + Math.cos(rad) * r);
      const fy = Math.round(cy + Math.sin(rad) * r);
      if (fx >= 0 && fx < G && fy >= 0 && fy < G) grid[fy][fx] = 1;
    }
  }

  // --- EYES ---
  const eyeY = Math.round(cy - fR * 0.2);
  const leftEX = Math.round(cx - fR * 0.35);
  const rightEX = Math.round(cx + fR * 0.35);
  const eyeR = Math.min(3, 2 + Math.floor(traitCount / 6));
  const eyeType = getEyeType(specialization, rng, rarity);
  drawEye(grid, G, leftEX, eyeY, eyeR, eyeType);
  drawEye(grid, G, rightEX, eyeY, eyeR, eyeType);

  // --- MOUTH ---
  const mouthY = Math.round(cy + fR * 0.3);
  const mW = Math.round(fR * 0.5);
  const mouthType = getMouthType(commStyle, rng, rarity);
  drawMouth(grid, G, cx, mouthY, mW, mouthType);

  // --- NOSE ---
  const noseY = Math.round(cy + fR * 0.05);
  grid[noseY][Math.round(cx)] = 1;
  if (noseY + 1 < G) grid[noseY + 1][Math.round(cx)] = 1;

  // --- Fill interior (temperament-driven pattern) ---
  const symmetry = 1 - (autonomyLevel / 10);
  const density = ({
    analytical: 0.18, creative: 0.22, aggressive: 0.28,
    cautious: 0.12, chaotic: 0.3,
  })[temperament] || 0.2;
  const fillDensity = density + mutationCount * 0.01;

  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (grid[y][x] !== 0) continue;
      const dx = x - cx, dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist >= fR * 0.9 || dist < 1) continue;
      const nearEye = (Math.abs(x - leftEX) <= eyeR + 1 && Math.abs(y - eyeY) <= eyeR + 1) ||
                      (Math.abs(x - rightEX) <= eyeR + 1 && Math.abs(y - eyeY) <= eyeR + 1);
      const nearMouth = Math.abs(y - mouthY) <= 2 && Math.abs(x - Math.round(cx)) <= mW;
      if (nearEye || nearMouth) continue;

      let fill = false;
      const mirrorX = Math.round(2 * cx - x);
      switch (temperament) {
        case 'analytical':
          fill = (x % 3 === 0 || y % 3 === 0) && rng() < fillDensity; break;
        case 'creative':
          fill = rng() < fillDensity * (0.5 + 0.5 * Math.sin(x * 0.8 + y * 0.6)); break;
        case 'aggressive':
          fill = rng() < fillDensity && ((x + y) % 2 === 0); break;
        case 'cautious':
          fill = dist < fR * 0.45 && rng() < fillDensity * 1.5; break;
        case 'chaotic':
          fill = rng() < fillDensity * (0.3 + rng() * 0.7); break;
        default:
          fill = rng() < fillDensity;
      }
      if (fill) {
        grid[y][x] = rng() < 0.12 ? 3 : 1;
        if (rng() < symmetry && mirrorX >= 0 && mirrorX < G && grid[y][mirrorX] === 0)
          grid[y][mirrorX] = grid[y][x];
      }
    }
  }

  // --- QR noise outside face ---
  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (grid[y][x] !== 0) continue;
      const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
      if (dist <= fR + 1) continue;
      if (rng() < 0.12 + mutationCount * 0.008) grid[y][x] = 1;
    }
  }

  // ============ RENDER ============
  const svgNS = 'http:' + '//www.w3.org/2000/svg';
  const uid = 'a' + simpleHash(address + name).toString(36);
  let defs = '';

  // --- RARITY DEFS ---
  if (rarity === 'rare' || rarity === 'epic' || rarity === 'legendary') {
    // Primary gradient
    defs += `<linearGradient id="${uid}_pg" x1="0%" y1="0%" x2="100%" y2="100%">`;
    defs += `<stop offset="0%" stop-color="${colors.primary}"/>`;
    defs += `<stop offset="100%" stop-color="${colors.secondary}"/>`;
    defs += `</linearGradient>`;
    // Accent gradient
    defs += `<linearGradient id="${uid}_ag" x1="0%" y1="100%" x2="100%" y2="0%">`;
    defs += `<stop offset="0%" stop-color="${colors.accent}"/>`;
    defs += `<stop offset="100%" stop-color="${colors.accentBright}"/>`;
    defs += `</linearGradient>`;
  }
  if (rarity === 'epic' || rarity === 'legendary') {
    // Chrome/metallic gradient
    defs += `<linearGradient id="${uid}_chrome" x1="0%" y1="0%" x2="100%" y2="100%">`;
    defs += `<stop offset="0%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 85%)"/>`;
    defs += `<stop offset="30%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 55%)"/>`;
    defs += `<stop offset="50%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 90%)"/>`;
    defs += `<stop offset="70%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 50%)"/>`;
    defs += `<stop offset="100%" stop-color="hsl(${colors.hue}, ${colors.sat}%, 80%)"/>`;
    defs += `</linearGradient>`;
  }
  if (rarity === 'legendary') {
    // Animated glow filter
    defs += `<filter id="${uid}_glow"><feGaussianBlur stdDeviation="2" result="blur"/>`;
    defs += `<feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>`;
    // Iridescent shimmer
    defs += `<linearGradient id="${uid}_iris" x1="0%" y1="0%" x2="100%" y2="0%">`;
    defs += `<stop offset="0%" stop-color="hsl(${colors.hue}, 100%, 70%)">`;
    defs += `<animate attributeName="stop-color" values="hsl(${colors.hue},100%,70%);hsl(${(colors.hue+120)%360},100%,70%);hsl(${(colors.hue+240)%360},100%,70%);hsl(${colors.hue},100%,70%)" dur="4s" repeatCount="indefinite"/></stop>`;
    defs += `<stop offset="50%" stop-color="hsl(${(colors.hue+60)%360}, 100%, 75%)">`;
    defs += `<animate attributeName="stop-color" values="hsl(${(colors.hue+60)%360},100%,75%);hsl(${(colors.hue+180)%360},100%,75%);hsl(${(colors.hue+300)%360},100%,75%);hsl(${(colors.hue+60)%360},100%,75%)" dur="4s" repeatCount="indefinite"/></stop>`;
    defs += `<stop offset="100%" stop-color="hsl(${(colors.hue+120)%360}, 100%, 70%)">`;
    defs += `<animate attributeName="stop-color" values="hsl(${(colors.hue+120)%360},100%,70%);hsl(${(colors.hue+240)%360},100%,70%);hsl(${colors.hue},100%,70%);hsl(${(colors.hue+120)%360},100%,70%)" dur="4s" repeatCount="indefinite"/></stop>`;
    defs += `</linearGradient>`;
  }

  // Color resolver based on rarity
  function cellColor(cellType) {
    if (rarity === 'legendary') {
      if (cellType === 4) return `url(#${uid}_iris)`;
      if (cellType === 2) return `url(#${uid}_ag)`;
      if (cellType === 3) return `url(#${uid}_chrome)`;
      return `url(#${uid}_chrome)`;
    }
    if (rarity === 'epic') {
      if (cellType === 2) return `url(#${uid}_ag)`;
      if (cellType === 3) return `url(#${uid}_chrome)`;
      return `url(#${uid}_chrome)`;
    }
    if (rarity === 'rare') {
      if (cellType === 2) return `url(#${uid}_ag)`;
      return `url(#${uid}_pg)`;
    }
    // common: solid
    if (cellType === 2) return colors.accent;
    if (cellType === 3) return colors.secondary;
    if (cellType === 4) return colors.accentBright;
    return colors.primary;
  }

  let svg = `<svg xmlns="${svgNS}" viewBox="0 0 ${size} ${size}" width="${size}" height="${size}">`;
  if (defs) svg += `<defs>${defs}</defs>`;
  svg += `<rect width="${size}" height="${size}" fill="#0a0a0a"/>`;

  // Legendary: outer iridescent border
  if (rarity === 'legendary') {
    svg += `<rect x="2" y="2" width="${size-4}" height="${size-4}" rx="4" fill="none" stroke="url(#${uid}_iris)" stroke-width="3" opacity="0.8"/>`;
  }
  // Epic: chrome border
  if (rarity === 'epic') {
    svg += `<rect x="3" y="3" width="${size-6}" height="${size-6}" rx="3" fill="none" stroke="url(#${uid}_chrome)" stroke-width="2" opacity="0.5"/>`;
  }
  // Rare: subtle gradient border
  if (rarity === 'rare') {
    svg += `<rect x="4" y="4" width="${size-8}" height="${size-8}" rx="2" fill="none" stroke="url(#${uid}_pg)" stroke-width="1.5" opacity="0.35"/>`;
  }

  // Soulbound halo
  if (soulbound)
    svg += `<circle cx="${size/2}" cy="${size/2}" r="${(fR + 1.5) * cs}" fill="none" stroke="#b388ff" stroke-width="1.5" opacity="0.25" stroke-dasharray="4 3"/>`;

  // Glow (stronger for higher rarity)
  const glowBase = { common: 0.03, rare: 0.06, epic: 0.1, legendary: 0.15 }[rarity];
  const glowI = Math.min(0.25, glowBase + points * 0.0002);
  svg += `<circle cx="${size/2}" cy="${size/2}" r="${fR * cs}" fill="${colors.glow}" opacity="${glowI}"/>`;

  // Legendary: extra bloom
  if (rarity === 'legendary') {
    svg += `<circle cx="${size/2}" cy="${size/2}" r="${(fR + 3) * cs}" fill="${colors.accent}" opacity="0.04"/>`;
  }

  // Eye glow
  if (['trader', 'oracle', 'guardian', 'operator'].includes(specialization) || rarity === 'epic' || rarity === 'legendary') {
    const gr = cs * (eyeR + 2);
    const eGlowOp = rarity === 'legendary' ? 0.2 : rarity === 'epic' ? 0.15 : 0.1;
    svg += `<circle cx="${leftEX * cs + cs/2}" cy="${eyeY * cs + cs/2}" r="${gr}" fill="${colors.accent}" opacity="${eGlowOp}"/>`;
    svg += `<circle cx="${rightEX * cs + cs/2}" cy="${eyeY * cs + cs/2}" r="${gr}" fill="${colors.accent}" opacity="${eGlowOp}"/>`;
  }

  // Generation rings
  for (let g = 0; g < Math.min(generation, 3); g++) {
    const gr = (fR + 2 + g * 0.8) * cs;
    svg += `<circle cx="${size/2}" cy="${size/2}" r="${gr}" fill="none" stroke="${colors.secondary}" stroke-width="0.5" opacity="0.15"/>`;
  }

  // Cells (with legendary glow filter on eyes)
  const legendaryEyeFilter = rarity === 'legendary' ? ` filter="url(#${uid}_glow)"` : '';
  for (let y = 0; y < G; y++) {
    for (let x = 0; x < G; x++) {
      if (!grid[y][x]) continue;
      const px = x * cs, py = y * cs;
      const color = cellColor(grid[y][x]);
      const r = cs * 0.1;
      const isEyeCell = grid[y][x] === 2 || grid[y][x] === 4;
      const filter = isEyeCell ? legendaryEyeFilter : '';
      svg += `<rect x="${px}" y="${py}" width="${cs}" height="${cs}" rx="${r}" fill="${color}"${filter}/>`;
    }
  }

  // Rarity badge
  if (rarity !== 'common') {
    const badgeColor = { rare: '#4fc3f7', epic: '#ce93d8', legendary: '#ffd54f' }[rarity];
    const badgeLabel = RARITY_COLORS[rarity].label;
    svg += `<text x="${size - 6}" y="14" text-anchor="end" fill="${badgeColor}" font-family="monospace" font-size="8" font-weight="bold" opacity="0.8">${badgeLabel}</text>`;
  }

  // Name
  svg += `<text x="${size/2}" y="${size - 6}" text-anchor="middle" fill="${colors.primary}" font-family="monospace" font-size="10" opacity="0.6">${name}</text>`;
  svg += `</svg>`;
  return svg;
}

function generateAuraSimple(agentData, size) {
  return generateAura(agentData, size);
}

// Expose rarity info for external use
function getAuraRarity(points, mutationCount) {
  return getRarity(points, mutationCount);
}

        // Backward-compat wrapper for explorer cards (no personality data yet)
        function generateFaceQR(agentData, size) {
            return generateAura(agentData, size);
        }

        // Modal functions
        function closeModal() { document.getElementById('agentModal').classList.remove('active'); }
        
        const pillColors = ['g','b','o','p','c'];
        function pc(i) { return pillColors[i % pillColors.length]; }

        async function showAgentDetail(tokenId, agent, owner) {
            const modal = document.getElementById('agentModal');
            const body = document.getElementById('modalBody');
            modal.classList.add('active');
            body.innerHTML = '<div style="text-align:center;padding:40px;color:#666;">Loading...</div>';
            
            // Access fields by name or index
            const addr = agent.agentAddress || agent[0];
            const name = agent.name || agent[1];
            const fw = agent.framework || agent[2];
            const mintedAt = agent.mintedAt || agent[3];
            const verified = agent.verified ?? agent[4];
            const soulbound = agent.soulbound ?? agent[5];
            const generation = Number(agent.generation || agent[6] || 0);
            const parentDNA = agent.parentDNA || agent[7];
            const version = agent.currentVersion || agent[8] || '1.0';
            const mutCount = Number(agent.mutationCount || agent[9] || 0);
            
            // Parse metadata
            let metadata = {}, modelName = '‚Äî', description = '';
            try {
                const uri = await readOnlyContract.tokenURI(tokenId);
                if (uri.startsWith('data:application/json;base64,')) {
                    metadata = JSON.parse(atob(uri.split(',')[1]));
                    description = metadata.description || '';
                    // Find model in attributes
                    if (metadata.attributes) {
                        if (Array.isArray(metadata.attributes)) {
                            const m = metadata.attributes.find(a => a.trait_type === 'model');
                            if (m) modelName = m.value;
                        } else if (metadata.attributes.model) {
                            modelName = metadata.attributes.model;
                        }
                    }
                }
            } catch(e) {}
            
            // Fetch traits, personality, points in parallel
            let traits = [], personality = null, points = 0;
            try { traits = await rpcRetry(() => readOnlyContract.getTraits(tokenId)) || []; } catch(e) {}
            try { personality = await rpcRetry(() => readOnlyContract.getPersonality(tokenId)); } catch(e) {}
            try { points = Number(await rpcRetry(() => readOnlyContract.points(owner))); } catch(e) {}
            
            const auraData = {
                agentAddress: addr, framework: fw, name: name,
                traitCount: traits.length, mutationCount: mutCount,
                soulbound: soulbound, points: points, generation: generation,
                temperament: personality?.temperament || 'analytical',
                communicationStyle: personality?.communicationStyle || 'formal',
                riskTolerance: Number(personality?.riskTolerance || 5),
                autonomyLevel: Number(personality?.autonomyLevel || 5),
                alignment: personality?.alignment || 'true-neutral',
                specialization: personality?.specialization || 'researcher',
            };
            const faceQR = generateAura(auraData, 280);
            const qrUrl = `https://helixa.xyz/agent/${tokenId}`;
            const agentHue = simpleHash(addr) % 360;
            const mintDate = new Date(Number(mintedAt) * 1000).toLocaleDateString();
            const has8004 = metadata?.erc8004;
            const isGenesis = generation === 0;
            const maxParent = BigInt('115792089237316195423570985008687907853269984665640564039457584007913129639935');
            const hasParent = parentDNA && BigInt(parentDNA) !== maxParent;
            
            // Personality pills
            let personalityHTML = '';
            if (personality && personality.temperament) {
                const risk = Number(personality.riskTolerance);
                const auto = Number(personality.autonomyLevel);
                personalityHTML = `
                    <div class="nft-section">
                        <div class="nft-stitle">Personality</div>
                        <div class="nft-pills">
                            <span class="nft-pill g">${personality.temperament}</span>
                            <span class="nft-pill b">${personality.communicationStyle}</span>
                            <span class="nft-pill o">risk ${risk}/10</span>
                            <span class="nft-pill p">autonomy ${auto}/10</span>
                            <span class="nft-pill c">${personality.alignment}</span>
                            <span class="nft-pill g">${personality.specialization}</span>
                        </div>
                    </div>`;
            }
            
            // Traits pills
            let traitsHTML = '';
            if (traits.length > 0) {
                traitsHTML = `
                    <div class="nft-section">
                        <div class="nft-stitle">Capabilities</div>
                        <div class="nft-pills">
                            ${traits.map((t, i) => `<span class="nft-pill ${pc(i)}">${t.name || t[0]}</span>`).join('')}
                        </div>
                    </div>`;
            }
            
            // Lineage
            let lineageHTML = '';
            if (isGenesis) {
                lineageHTML = `<div class="nft-lineage"><div class="nft-lineage-dot"></div><div class="nft-lineage-text"><b>Genesis Agent</b> ‚Äî Generation 0 ¬∑ Origin mint</div></div>`;
            } else {
                lineageHTML = `<div class="nft-lineage"><div class="nft-lineage-dot"></div><div class="nft-lineage-text"><b>Generation ${generation}</b> ‚Äî Child of Agent #${hasParent ? parentDNA.toString() : '?'}</div></div>`;
            }
            
            // Payment Infrastructure
            let paymentHTML = '';
            const isX402 = traits.some(t => (t.name || t[0]) === 'x402-compatible');
            if (isX402) {
                const providerTrait = traits.find(t => (t.category || t[1]) === 'payment-provider');
                const tokenTraits = traits.filter(t => (t.category || t[1]) === 'accepted-token');
                const providerName = providerTrait ? (providerTrait.name || providerTrait[0]) : null;
                const acceptedTokens = tokenTraits.map(t => t.name || t[0]);
                const payWallet = metadata?.paymentWallet || null;
                const payEndpoint = metadata?.x402Endpoint || null;
                const payChain = metadata?.paymentChain || 'base';
                
                paymentHTML = `
                    <div class="nft-section">
                        <div class="nft-stitle">üí≥ Payment Infrastructure</div>
                        <div class="nft-details">
                            <div class="nft-detail"><span class="nft-dl">Protocol</span><span class="nft-dv" style="color:#00c853;">x402</span></div>
                            ${providerName ? `<div class="nft-detail"><span class="nft-dl">Provider</span><span class="nft-dv">${providerName}</span></div>` : ''}
                            ${acceptedTokens.length ? `<div class="nft-detail"><span class="nft-dl">Accepts</span><span class="nft-dv">${acceptedTokens.join(', ')}</span></div>` : ''}
                            ${payWallet ? `<div class="nft-detail"><span class="nft-dl">Pay Wallet</span><span class="nft-dv">${payWallet.slice(0,6)}...${payWallet.slice(-4)}</span></div>` : ''}
                            <div class="nft-detail"><span class="nft-dl">Chain</span><span class="nft-dv">${payChain}</span></div>
                            ${payEndpoint ? `<div class="nft-detail"><span class="nft-dl">Endpoint</span><span class="nft-dv" style="font-size:0.65rem;">${payEndpoint}</span></div>` : ''}
                        </div>
                    </div>`;
            }
            
            body.innerHTML = `
                <div class="nft-header">
                    <div class="nft-logo">HELIXA<span>Agent DNA</span></div>
                    <div class="nft-tid">#${String(tokenId).padStart(4,'0')}</div>
                </div>
                <div class="nft-hero">
                    <div class="nft-hero-frame" id="nft-hero-frame-qr">${faceQR}</div>
                </div>
                <div class="nft-identity">
                    <span class="nft-name">${name}</span>
                    ${verified ? '<span class="nft-verified-big">Verified</span>' : '<span class="nft-unverified-badge">unverified</span>'}
                </div>
                ${description ? `<div class="nft-desc">${description}</div>` : ''}
                <div class="nft-stats">
                    <div class="nft-stat"><div class="nft-sv g">${traits.length}</div><div class="nft-sl">Traits</div></div>
                    <div class="nft-stat"><div class="nft-sv b">v${version}</div><div class="nft-sl">Version</div></div>
                    <div class="nft-stat"><div class="nft-sv o">${mutCount}</div><div class="nft-sl">Mutations</div></div>
                    <div class="nft-stat"><div class="nft-sv p">G${generation}</div><div class="nft-sl">Gen</div></div>
                    <div class="nft-stat"><div class="nft-sv c">${points}</div><div class="nft-sl">Points</div></div>
                </div>
                ${personalityHTML}
                ${traitsHTML}
                <div class="nft-section">
                    <div class="nft-stitle">Identity</div>
                    <div class="nft-details">
                        <div class="nft-detail"><span class="nft-dl">Agent</span><span class="nft-dv">${addr.slice(0,6)}...${addr.slice(-4)}</span></div>
                        <div class="nft-detail"><span class="nft-dl">Framework</span><span class="nft-dv">${fw}</span></div>
                        <div class="nft-detail"><span class="nft-dl">Model</span><span class="nft-dv">${modelName}</span></div>
                        <div class="nft-detail"><span class="nft-dl">Created</span><span class="nft-dv">${mintDate}</span></div>
                        <div class="nft-detail"><span class="nft-dl">Owner</span><span class="nft-dv">${owner.slice(0,6)}...${owner.slice(-4)}</span></div>
                        <div class="nft-detail"><span class="nft-dl">${soulbound ? 'üîí Soulbound' : 'Transferable'}</span><span class="nft-dv">${soulbound ? 'Non-transferable' : 'Can be traded'}</span></div>
                    </div>
                </div>
                ${lineageHTML}
                ${paymentHTML}
                <div class="nft-footer">
                    <div class="nft-badges">
                        <span class="nft-bdg chain">Base</span>
                        <span class="nft-bdg erc">ERC-8004</span>
                        ${soulbound ? '<span class="nft-bdg soul">Soulbound</span>' : ''}
                        ${has8004 ? '<span class="nft-bdg link8004">8004.org #' + has8004.tokenId + '</span>' : ''}
                        ${traits.some(t => (t.name || t[0]) === 'x402-compatible') ? '<span class="nft-bdg" style="background:rgba(0,200,83,0.15); color:#00c853; border-color:#00c853;">x402</span>' : ''}
                    </div>
                    <a href="https://basescan.org/token/${CONTRACT_ADDRESS}?a=${tokenId}" target="_blank">BaseScan ‚Üó</a>
                </div>
            `;

            // Replace SVG with canvas + QR overlay
            if (typeof renderAuraWithQR === 'function') {
                const heroFrame = document.getElementById('nft-hero-frame-qr');
                if (heroFrame) {
                    renderAuraWithQR(faceQR, 280, qrUrl, agentHue).then(canvas => {
                        canvas.style.borderRadius = '8px';
                        heroFrame.innerHTML = '';
                        heroFrame.appendChild(canvas);
                    }).catch(e => console.warn('QR overlay failed:', e));
                }
            }
        }

        // ERC-8004 Registry (8004.org on Base)
        const ERC8004_ADDRESS = "0x8004A169FB4a3325136EB29fA0ceB6D2e539a432";
        const ERC8004_ABI = [
            "function register(string agentURI) external returns (uint256)",
            "function tokenURI(uint256 tokenId) view returns (string)",
            "function ownerOf(uint256 tokenId) view returns (address)",
            "function getAgentWallet(uint256 tokenId) view returns (address)",
            "function balanceOf(address owner) view returns (uint256)",
            "function name() view returns (string)",
            "function setAgentURI(uint256 tokenId, string agentURI) external"
        ];
        let erc8004ReadOnly; // initialized after readProvider is created

        function toggle8004Import() {
            const checked = document.getElementById('import8004').checked;
            document.getElementById('import8004Section').style.display = checked ? 'block' : 'none';
            if (checked) {
                document.getElementById('register8004').checked = false;
                document.getElementById('register8004Section').style.display = 'none';
            }
        }
        
        function toggle8004Register() {
            const checked = document.getElementById('register8004').checked;
            document.getElementById('register8004Section').style.display = checked ? 'block' : 'none';
            if (checked) {
                document.getElementById('import8004').checked = false;
                document.getElementById('import8004Section').style.display = 'none';
            }
        }
        
        let import8004Timer;
        function preview8004Import() {
            clearTimeout(import8004Timer);
            import8004Timer = setTimeout(async () => {
                const tokenId = document.getElementById('existing8004Id').value.trim();
                const preview = document.getElementById('import8004Preview');
                if (!tokenId) { preview.innerHTML = ''; return; }
                try {
                    preview.innerHTML = '<span style="color:#ffaa00;">Looking up...</span>';
                    const uri = await erc8004ReadOnly.tokenURI(parseInt(tokenId));
                    const owner = await erc8004ReadOnly.ownerOf(parseInt(tokenId));
                    let name = '?';
                    if (uri.startsWith('data:application/json;base64,')) {
                        const meta = JSON.parse(atob(uri.split(',')[1]));
                        name = meta.name || '?';
                        // Auto-fill form fields from 8004 data
                        if (meta.name && !document.getElementById('agentName').value) 
                            document.getElementById('agentName').value = meta.name;
                        if (meta.description && !document.getElementById('description').value)
                            document.getElementById('description').value = meta.description;
                    }
                    const wallet = await erc8004ReadOnly.getAgentWallet(parseInt(tokenId));
                    preview.innerHTML = `<span style="color:#b388ff;">‚úì Found:</span> ${name} ¬∑ Owner: ${owner.slice(0,8)}...` +
                        (wallet !== '0x0000000000000000000000000000000000000000' ? ` ¬∑ Wallet: ${wallet.slice(0,8)}...` : '');
                    // Auto-fill agent address from 8004 wallet if set
                    if (wallet !== '0x0000000000000000000000000000000000000000' && !document.getElementById('agentAddress').value)
                        document.getElementById('agentAddress').value = wallet;
                } catch(e) {
                    preview.innerHTML = `<span style="color:#ff4444;">Not found (ID ${tokenId})</span>`;
                }
            }, 500);
        }

        let provider, signer, contract;
        
        async function connectWallet() {
            if (!window.ethereum) {
                showStatus('Install MetaMask or another Web3 wallet', 'error');
                return;
            }
            
            try {
                provider = new ethers.BrowserProvider(window.ethereum);
                
                // Request chain switch
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0x' + CHAIN_ID.toString(16) }]
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: '0x' + CHAIN_ID.toString(16),
                                chainName: CHAIN_NAME,
                                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                                rpcUrls: ["https://mainnet.base.org"],
                                blockExplorerUrls: ['https://basescan.org']
                            }]
                        });
                    }
                }
                
                signer = await provider.getSigner();
                const address = await signer.getAddress();
                
                document.getElementById('connectBtn').textContent = address.slice(0, 6) + '...' + address.slice(-4);
                document.getElementById('walletInfo').textContent = 'Connected: ' + address;
                document.getElementById('mintBtn').disabled = false;
                
                contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
                
                // Update button with actual price
                try {
                    const price = await readOnlyContract.mintPrice();
                    const priceStr = price == 0n ? 'Free' : ethers.formatEther(price) + ' ETH';
                    document.getElementById('mintBtn').textContent = 'Mint AgentDNA (' + priceStr + ')';
                    document.getElementById('mintPriceDisplay').textContent = price == 0n ? 'Free' : ethers.formatEther(price);
                    document.getElementById('mintPriceInline').textContent = priceStr;
                } catch(e) { document.getElementById('mintBtn').textContent = 'Mint AgentDNA'; }
                
                loadStats();
                loadAgents();
                
            } catch (err) {
                showStatus('Failed to connect: ' + err.message, 'error');
            }
        }
        
        const readProvider = new ethers.JsonRpcProvider(RPC_URL);
        
        // Retry helper for rate-limited public RPC
        async function rpcRetry(fn, retries = 3) {
            for (let r = 0; r < retries; r++) {
                try { return await fn(); } catch(e) {
                    if (r < retries - 1) await new Promise(ok => setTimeout(ok, 300 * (r + 1)));
                    else throw e;
                }
            }
        }
        const readOnlyContract = new ethers.Contract(CONTRACT_ADDRESS, ABI, readProvider);
        erc8004ReadOnly = new ethers.Contract(ERC8004_ADDRESS, ERC8004_ABI, readProvider);

        async function loadStats() {
            try {
                const total = await rpcRetry(() => readOnlyContract.totalAgents());
                const price = await rpcRetry(() => readOnlyContract.mintPrice());
                
                document.getElementById('totalAgents').textContent = total.toString();
                document.getElementById('mintPriceDisplay').textContent = ethers.formatEther(price);
                document.getElementById('mintPriceInline').textContent = ethers.formatEther(price) + ' ETH';
            } catch (e) {
                console.log('Stats not loaded (contract may not be deployed yet)');
            }
        }
        
        // .agent name availability check
        let agentNameTimeout = null;
        const NAMES_READ_CONTRACT = new ethers.Contract(
            '0xDE8c422D2076CbAE0cA8f5dA9027A03D48928F2d',
            ['function available(string name) external view returns (bool)'],
            readOnlyProvider
        );
        function checkAgentName(val) {
            const status = document.getElementById('agentNameStatus');
            const clean = val.toLowerCase().replace(/\.agent$/, '').replace(/[^a-z0-9-]/g, '');
            if (!clean || clean.length < 3) {
                status.innerHTML = clean.length > 0 ? '<span style="color:#ff5555">Min 3 characters</span>' : '';
                return;
            }
            if (clean.length > 32) { status.innerHTML = '<span style="color:#ff5555">Max 32 characters</span>'; return; }
            if (clean.startsWith('-') || clean.endsWith('-')) { status.innerHTML = '<span style="color:#ff5555">Cannot start/end with hyphen</span>'; return; }
            status.innerHTML = '<span style="color:#aaa">Checking...</span>';
            clearTimeout(agentNameTimeout);
            agentNameTimeout = setTimeout(async () => {
                try {
                    const avail = await rpcRetry(() => NAMES_READ_CONTRACT.available(clean));
                    if (avail) {
                        status.innerHTML = '<span style="color:#00e676">‚úì ' + clean + '.agent is available!</span>';
                    } else {
                        status.innerHTML = '<span style="color:#ff5555">‚úó ' + clean + '.agent is taken</span>';
                    }
                } catch (e) {
                    status.innerHTML = '<span style="color:#aaa">Could not check availability</span>';
                }
            }, 500);
        }

        async function mintAgent() {
            const name = document.getElementById('agentName').value.trim();
            const agentAddr = document.getElementById('agentAddress').value.trim();
            const framework = document.getElementById('framework').value;
            const description = document.getElementById('description').value.trim();
            const capabilities = document.getElementById('capabilities').value.trim();
            const model = document.getElementById('model').value.trim();
            const sourceRepo = document.getElementById('sourceRepo').value.trim();
            const soulbound = document.getElementById('soulbound').checked;
            
            if (!name) { showStatus('Agent name is required', 'error'); return; }
            if (!ethers.isAddress(agentAddr)) { showStatus('Invalid agent address', 'error'); return; }
            
            // Build metadata JSON (would upload to IPFS in production)
            const metadata = {
                name: name,
                description: description,
                attributes: {
                    framework: framework,
                    capabilities: capabilities.split(',').map(s => s.trim()).filter(Boolean),
                    model: model,
                    source_repo: sourceRepo
                }
            };
            
            // For MVP, use a data URI as tokenURI (replace with IPFS in production)
            const tokenURI = "data:application/json;base64," + btoa(JSON.stringify(metadata));
            
            try {
                document.getElementById('mintBtn').disabled = true;
                
                const import8004 = document.getElementById('import8004').checked;
                const register8004 = document.getElementById('register8004').checked;
                const existing8004Id = document.getElementById('existing8004Id')?.value?.trim();
                
                // If importing from 8004, add cross-reference to metadata
                if (import8004 && existing8004Id) {
                    metadata.erc8004 = {
                        tokenId: parseInt(existing8004Id),
                        registry: ERC8004_ADDRESS,
                        chain: "base"
                    };
                }
                
                // Rebuild tokenURI with potentially updated metadata
                const finalTokenURI = "data:application/json;base64," + btoa(JSON.stringify(metadata));
                
                // Step 1: Mint AgentDNA
                showStatus('Minting AgentDNA...', 'pending');
                const price = await contract.mintPrice();
                const NO_PARENT = ethers.MaxUint256;
                const tx = await contract.mint(agentAddr, name, framework, finalTokenURI, soulbound, "1.0.0", NO_PARENT, {
                    value: price
                });
                
                showStatus('Transaction submitted! Waiting for confirmation...', 'pending');
                const receipt = await tx.wait();
                const agentDnaTokenId = receipt.logs[0]?.args?.[0]?.toString();
                
                // Step 2: Register on 8004 if requested
                if (register8004) {
                    try {
                        showStatus('AgentDNA #' + agentDnaTokenId + ' minted! Now registering on 8004.org...', 'pending');
                        
                        // Build 8004-compliant agent URI
                        const agentURI8004 = {
                            type: "https://eips.ethereum.org/EIPS/eip-8004#registration-v1",
                            name: name,
                            description: description || name + ' ‚Äî registered via Helixa',
                            services: [
                                {
                                    name: "agentWallet",
                                    endpoint: "eip155:8453:" + agentAddr
                                }
                            ],
                            registrations: [
                                {
                                    agentId: parseInt(agentDnaTokenId),
                                    agentRegistry: "eip155:" + CHAIN_ID + ":" + CONTRACT_ADDRESS
                                }
                            ],
                            active: true
                        };
                        
                        const uri8004 = "data:application/json;base64," + btoa(JSON.stringify(agentURI8004));
                        const erc8004Contract = new ethers.Contract(ERC8004_ADDRESS, ERC8004_ABI, signer);
                        const tx8004 = await erc8004Contract.register(uri8004);
                        
                        showStatus('8004 registration submitted! Waiting...', 'pending');
                        await tx8004.wait();
                        
                        showStatus(
                            '‚úÖ Dual mint complete! AgentDNA #' + agentDnaTokenId + ' + 8004.org registered ‚Äî TX: ' + tx.hash.slice(0, 10) + '...', 
                            'success'
                        );
                    } catch (e8004) {
                        showStatus(
                            '‚úÖ AgentDNA #' + agentDnaTokenId + ' minted! ‚ö†Ô∏è 8004 registration failed: ' + (e8004.reason || e8004.message), 
                            'success'
                        );
                    }
                } else {
                    showStatus(
                        '‚úÖ Agent minted! Token ID: ' + agentDnaTokenId + ' ‚Äî TX: ' + tx.hash.slice(0, 10) + '...', 
                        'success'
                    );
                }
                
                // Register .agent name if provided
                const dotAgentInput = document.getElementById('dotAgentName').value.trim().toLowerCase().replace(/\.agent$/, '').replace(/[^a-z0-9-]/g, '');
                if (dotAgentInput && dotAgentInput.length >= 3 && signer) {
                    try {
                        showStatus('Registering ' + dotAgentInput + '.agent...', 'pending');
                        const namesCtx = new ethers.Contract(
                            '0xDE8c422D2076CbAE0cA8f5dA9027A03D48928F2d',
                            ['function register(string name) external', 'function linkAgent(string name, uint256 agentId) external'],
                            signer
                        );
                        const nameTx = await namesCtx.register(dotAgentInput);
                        await nameTx.wait();
                        const linkTx = await namesCtx.linkAgent(dotAgentInput, agentDnaTokenId);
                        await linkTx.wait();
                        showStatus('‚úÖ ' + dotAgentInput + '.agent registered! AgentDNA #' + agentDnaTokenId, 'success');
                    } catch (nameErr) {
                        console.log('.agent registration failed:', nameErr.message);
                        // Don't block mint success
                    }
                }
                
                // Show Soul Builder
                showSoulBuilder(parseInt(agentDnaTokenId));
                
                document.getElementById('mintBtn').disabled = false;
                loadStats();
                loadAgents();
                
            } catch (err) {
                showStatus('Mint failed: ' + (err.reason || err.message), 'error');
                document.getElementById('mintBtn').disabled = false;
            }
        }
        
        async function loadAgents() {
            const list = document.getElementById('agentList');
            try {
                const total = await rpcRetry(() => readOnlyContract.totalAgents());
                
                if (total == 0) {
                    list.innerHTML = '<p style="color: #666; text-align: center;">No agents registered yet. Be the first!</p>';
                    return;
                }
                
                list.innerHTML = '<p style="color: #ffaa00; text-align: center;">Loading ' + total.toString() + ' agents...</p>';
                const cards = [];
                for (let i = Number(total) - 1; i >= 0 && i >= Number(total) - 20; i--) {
                    try {
                        // Small delay between agents to avoid rate limits
                        if (i < Number(total) - 1) await new Promise(ok => setTimeout(ok, 200));
                        
                        const [agent, owner] = await Promise.all([
                            rpcRetry(() => readOnlyContract.getAgent(i)),
                            rpcRetry(() => readOnlyContract.ownerOf(i))
                        ]);
                        const addr = agent.agentAddress || agent[0];
                        const name = agent.name || agent[1];
                        const fw = agent.framework || agent[2];
                        const mintedAt = agent.mintedAt || agent[3];
                        const verified = agent.verified ?? agent[4];
                        const soulbound = agent.soulbound ?? agent[5];
                        const mutCount = Number(agent.mutationCount || agent[9] || 0);
                        
                        // Fetch personality + points with retry (non-blocking)
                        let personality = null, pts = 0;
                        try {
                            await new Promise(ok => setTimeout(ok, 150));
                            personality = await rpcRetry(() => readOnlyContract.getPersonality(i));
                            pts = Number(await rpcRetry(() => readOnlyContract.points(addr)));
                        } catch(e) {}
                        
                        const card = document.createElement('div');
                        card.className = 'agent-card' + (verified ? ' verified-card' : '');
                        card.dataset.verified = verified ? '1' : '0';
                        const thumbData = {
                            agentAddress: addr, framework: fw, name: name,
                            mutationCount: mutCount, points: pts, soulbound: soulbound,
                            traitCount: 0,
                            temperament: personality ? personality.temperament : 'analytical',
                            communicationStyle: personality ? personality.communicationStyle : 'formal',
                            riskTolerance: personality ? Number(personality.riskTolerance) : 5,
                            autonomyLevel: personality ? Number(personality.autonomyLevel) : 5,
                            alignment: personality ? personality.alignment : 'true-neutral',
                            specialization: personality ? personality.specialization : 'researcher',
                            generation: Number(agent.parentId || 0) > 0 ? 1 : 0,
                        };
                        const thumb = generateFaceQR(thumbData, 80);
                        card.innerHTML = `
                            <div class="faceqr-thumb">${thumb}</div>
                            <div class="card-info">
                                <div class="name">
                                    #${i} ‚Äî ${name} 
                                    ${verified ? '<span class="verified-badge">Verified</span>' : '<span class="unverified-label">unverified</span>'}
                                    ${soulbound ? 'üîí' : ''}
                                </div>
                                <div class="meta">
                                    Framework: ${fw} | 
                                    Address: ${addr.slice(0, 8)}... | 
                                    Owner: ${owner.slice(0, 8)}... |
                                    Minted: ${new Date(Number(mintedAt) * 1000).toLocaleDateString()}
                                </div>
                            </div>
                        `;
                        ((tid, ag, ow) => { card.onclick = () => showAgentDetail(tid, ag, ow); })(i, agent, owner);
                        cards.push(card);
                    } catch (e) { 
                        console.error('Agent #' + i + ' error:', e);
                        const errCard = document.createElement('div');
                        errCard.className = 'agent-card';
                        errCard.innerHTML = '<div class="card-info"><div class="name" style="color:#ff4444;">#' + i + ' ‚Äî Load error: ' + e.message + '</div></div>';
                        cards.push(errCard);
                    }
                }
                list.innerHTML = '';
                if (cards.length === 0) {
                    list.innerHTML = '<p style="color: #666; text-align: center;">No agents loaded. Check console for errors.</p>';
                }
                cards.forEach(c => list.appendChild(c));
            } catch (e) {
                list.innerHTML = '<p style="color: #ff4444; text-align: center;">Error: ' + e.message + '</p>';
            }
        }
        
        async function lookupAgent() {
            const input = document.getElementById('lookupInput').value.trim();
            const result = document.getElementById('lookupResult');
            
            // No wallet needed for lookups
            
            try {
                let agent, tokenId, owner;
                
                if (ethers.isAddress(input)) {
                    const data = await readOnlyContract.getAgentByAddress(input);
                    tokenId = data[0];
                    agent = data[1];
                } else {
                    tokenId = parseInt(input);
                    agent = await readOnlyContract.getAgent(tokenId);
                }
                
                owner = await readOnlyContract.ownerOf(tokenId);
                
                let lkPersonality = null, lkPts = 0;
                try {
                    lkPersonality = await readOnlyContract.getPersonality(tokenId);
                    lkPts = Number(await readOnlyContract.points(agent.agentAddress));
                } catch(e) {}
                const lkThumbData = {
                    agentAddress: agent.agentAddress, framework: agent.framework, name: agent.name,
                    mutationCount: Number(agent.mutationCount || 0), points: lkPts, soulbound: agent.soulbound,
                    traitCount: 0,
                    temperament: lkPersonality ? lkPersonality.temperament : 'analytical',
                    communicationStyle: lkPersonality ? lkPersonality.communicationStyle : 'formal',
                    riskTolerance: lkPersonality ? Number(lkPersonality.riskTolerance) : 5,
                    autonomyLevel: lkPersonality ? Number(lkPersonality.autonomyLevel) : 5,
                    alignment: lkPersonality ? lkPersonality.alignment : 'true-neutral',
                    specialization: lkPersonality ? lkPersonality.specialization : 'researcher',
                    generation: Number(agent.parentId || 0) > 0 ? 1 : 0,
                };
                const thumb = generateFaceQR(lkThumbData, 80);
                result.innerHTML = `
                    <div class="agent-card" id="lookupCard">
                        <div class="faceqr-thumb">${thumb}</div>
                        <div class="card-info">
                            <div class="name">#${tokenId} ‚Äî ${agent.name} ${agent.verified ? '<span class="verified">‚úì Verified</span>' : ''}</div>
                            <div class="meta">
                                Framework: ${agent.framework} | 
                                Address: ${agent.agentAddress.slice(0, 8)}... | 
                                Owner: ${owner.slice(0, 8)}... |
                                Soulbound: ${agent.soulbound ? 'Yes üîí' : 'No'}
                            </div>
                        </div>
                    </div>
                `;
                document.getElementById('lookupCard').onclick = () => showAgentDetail(tokenId, agent, owner);
            } catch (e) {
                result.innerHTML = '<p style="color: #ff4444;">Agent not found</p>';
            }
        }
        
        function showStatus(msg, type) {
            const el = document.getElementById('status');
            el.textContent = msg;
            el.className = type;
        }
        
        // ============ SOUL BUILDER ============
        let mintedTokenId = null;

        function showSoulBuilder(tokenId) {
            mintedTokenId = tokenId;
            document.getElementById('soulTokenId').textContent = '#' + tokenId;
            document.getElementById('traitRows').innerHTML = '';
            addTraitRow(); // Start with one empty row
            document.getElementById('soulBuilder').style.display = 'block';
            document.getElementById('soulBuilder').scrollIntoView({ behavior: 'smooth' });
        }

        function addTraitRow() {
            const container = document.getElementById('traitRows');
            if (container.children.length >= 8) return;
            const row = document.createElement('div');
            row.style.cssText = 'display:flex; gap:0.5rem; margin-bottom:0.5rem;';
            row.innerHTML = `
                <input type="text" placeholder="Trait name (e.g. Trading)" style="flex:1; margin:0;">
                <select style="flex:1; margin:0;">
                    <option value="capability">Capability</option>
                    <option value="skill">Skill</option>
                    <option value="knowledge">Knowledge</option>
                    <option value="behavior">Behavior</option>
                    <option value="integration">Integration</option>
                    <option value="custom">Custom</option>
                </select>
                <button onclick="this.parentElement.remove()" style="width:auto; padding:0.5rem; background:#ff444430; color:#ff4444; border:1px solid #ff444440; font-size:0.8rem;">‚úï</button>
            `;
            container.appendChild(row);
        }

        async function submitSoul() {
            if (!contract || mintedTokenId === null) return;
            const btn = document.getElementById('soulSubmitBtn');
            const status = document.getElementById('soulStatus');
            btn.disabled = true;

            try {
                // 1. Set personality
                status.innerHTML = '<span style="color:#ffaa00;">Setting personality...</span>';
                const tx1 = await contract.setPersonality(
                    mintedTokenId,
                    document.getElementById('soulTemperament').value,
                    document.getElementById('soulCommStyle').value,
                    parseInt(document.getElementById('soulRisk').value),
                    parseInt(document.getElementById('soulAutonomy').value),
                    document.getElementById('soulAlignment').value,
                    document.getElementById('soulSpec').value
                );
                await tx1.wait();

                // 2. Add traits
                const rows = document.getElementById('traitRows').children;
                let traitCount = 0;
                for (const row of rows) {
                    const name = row.querySelector('input').value.trim();
                    const category = row.querySelector('select').value;
                    if (!name) continue;
                    status.innerHTML = `<span style="color:#ffaa00;">Adding trait: ${name}...</span>`;
                    const traitFee = await contract.traitFee();
                    const tx = await contract.addTrait(mintedTokenId, name, category, { value: traitFee });
                    await tx.wait();
                    traitCount++;
                }

                // 3. Add x402 + payment infrastructure traits
                if (document.getElementById('x402Compatible').checked) {
                    status.innerHTML = '<span style="color:#ffaa00;">Adding x402 compatibility...</span>';
                    const traitFee = await contract.traitFee();
                    const tx = await contract.addTrait(mintedTokenId, 'x402-compatible', 'protocol', { value: traitFee });
                    await tx.wait();
                    traitCount++;
                    
                    // Add payment provider trait
                    const provider = document.getElementById('payProvider').value;
                    if (provider) {
                        status.innerHTML = `<span style="color:#ffaa00;">Adding payment provider: ${provider}...</span>`;
                        const tf2 = await contract.traitFee();
                        const tx2 = await contract.addTrait(mintedTokenId, provider, 'payment-provider', { value: tf2 });
                        await tx2.wait();
                        traitCount++;
                    }
                    
                    // Add accepted tokens as traits
                    const tokens = [...document.querySelectorAll('.payToken:checked')].map(cb => cb.value);
                    for (const token of tokens) {
                        status.innerHTML = `<span style="color:#ffaa00;">Adding accepted token: ${token}...</span>`;
                        const tf3 = await contract.traitFee();
                        const tx3 = await contract.addTrait(mintedTokenId, token, 'accepted-token', { value: tf3 });
                        await tx3.wait();
                        traitCount++;
                    }
                }

                // 4. Update metadata with payment info if x402
                if (document.getElementById('x402Compatible').checked) {
                    const payWallet = document.getElementById('payWallet').value.trim();
                    const payEndpoint = document.getElementById('payEndpoint').value.trim();
                    const payChain = document.getElementById('payChain').value;
                    const provider = document.getElementById('payProvider').value;
                    
                    if (payWallet || payEndpoint) {
                        status.innerHTML = '<span style="color:#ffaa00;">Updating metadata with payment info...</span>';
                        // Fetch current URI and update
                        try {
                            const currentURI = await readOnlyContract.tokenURI(mintedTokenId);
                            let meta = {};
                            if (currentURI.startsWith('data:application/json;base64,')) {
                                meta = JSON.parse(atob(currentURI.split(',')[1]));
                            }
                            if (payWallet) meta.paymentWallet = payWallet;
                            if (payEndpoint) meta.x402Endpoint = payEndpoint;
                            if (payChain) meta.paymentChain = payChain;
                            if (provider) meta.paymentProvider = provider;
                            const newURI = "data:application/json;base64," + btoa(JSON.stringify(meta));
                            const txURI = await contract.setAgentURI(mintedTokenId, newURI);
                            await txURI.wait();
                        } catch(e) { console.warn('Payment metadata update failed:', e); }
                    }
                }

                status.innerHTML = `<span style="color:#b388ff;">‚úÖ Soul set! Personality + ${traitCount} trait${traitCount !== 1 ? 's' : ''} saved onchain.</span>`;
                // Show share card
                showShareCard(mintedTokenId);
                setTimeout(() => { loadAgents(); }, 2000);
            } catch (err) {
                status.innerHTML = `<span style="color:#ff4444;">‚ùå ${err.reason || err.message}</span>`;
            }
            btn.disabled = false;
        }

        async function showShareCard(tokenId) {
            const card = document.getElementById('shareCard');
            const preview = document.getElementById('shareAuraPreview');
            const tweetText = document.getElementById('shareTweetText');
            const tweetLink = document.getElementById('shareTweetLink');
            
            // Generate Aura thumbnail
            try {
                const agent = await readOnlyContract.getAgent(tokenId);
                const name = agent.name || agent[1];
                const fw = agent.framework || agent[2];
                let personality = null, pts = 0;
                try { personality = await readOnlyContract.getPersonality(tokenId); pts = Number(await readOnlyContract.points(agent.agentAddress || agent[0])); } catch(e) {}
                const thumbData = {
                    agentAddress: agent.agentAddress || agent[0], framework: fw, name: name,
                    mutationCount: 0, points: pts, soulbound: agent.soulbound ?? agent[5],
                    traitCount: 0, temperament: personality?.temperament || 'analytical',
                    communicationStyle: personality?.communicationStyle || 'formal',
                    riskTolerance: personality ? Number(personality.riskTolerance) : 5,
                    autonomyLevel: personality ? Number(personality.autonomyLevel) : 5,
                    alignment: personality?.alignment || 'true-neutral',
                    specialization: personality?.specialization || 'researcher', generation: 0,
                };
                preview.innerHTML = generateFaceQR(thumbData, 160);
            } catch(e) { console.log('share preview err', e); }
            
            const tweet = `I just minted my Agent Aura on @HelixaXYZ üß¨\n\nAgentDNA #${tokenId} ‚Äî onchain identity for AI agents.\n\nFirst 100 mints are free. Get yours:\nhttps://helixa.xyz/mint.html`;
            tweetText.textContent = tweet;
            tweetLink.href = 'https://x.com/intent/tweet?text=' + encodeURIComponent(tweet);
            card.style.display = 'block';
            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // ============ VERIFICATION REQUEST ============
        async function requestVerification() {
            if (!contract || mintedTokenId === null) {
                document.getElementById('verifyStatus').innerHTML = '<div class="verify-status requested">Connect wallet and mint first</div>';
                return;
            }
            const btn = document.getElementById('verifyRequestBtn');
            const status = document.getElementById('verifyStatus');
            btn.disabled = true;
            
            try {
                // Check if already verified
                const isV = await readOnlyContract.isVerified(mintedTokenId);
                if (isV) {
                    status.innerHTML = '<div class="verify-status already">‚úì This agent is already verified!</div>';
                    btn.disabled = true;
                    return;
                }
                
                // Generate challenge
                const timestamp = Math.floor(Date.now() / 1000);
                const challenge = `Verify AgentDNA #${mintedTokenId} at timestamp ${timestamp}`;
                
                status.innerHTML = '<div class="verify-status requested">Sign the challenge message with your agent wallet...</div>';
                
                // Ask the connected wallet to sign
                const signature = await signer.signMessage(challenge);
                const signerAddr = await signer.getAddress();
                
                // Verify client-side that signature is valid
                const recovered = ethers.verifyMessage(challenge, signature);
                
                // Get the agent's address from contract
                const agent = await readOnlyContract.getAgent(mintedTokenId);
                const agentAddr = agent.agentAddress || agent[0];
                
                // Check: signer should be the owner or the agent address
                const owner = await readOnlyContract.ownerOf(mintedTokenId);
                if (recovered.toLowerCase() !== agentAddr.toLowerCase() && recovered.toLowerCase() !== owner.toLowerCase()) {
                    status.innerHTML = '<div class="verify-status requested">‚ö†Ô∏è Signature must be from the agent wallet (' + agentAddr.slice(0,8) + '...) or the owner wallet.</div>';
                    btn.disabled = false;
                    return;
                }
                
                // Store verification request in localStorage for cron job pickup
                const request = {
                    tokenId: mintedTokenId,
                    challenge: challenge,
                    signature: signature,
                    signerAddress: recovered,
                    agentAddress: agentAddr,
                    owner: owner,
                    timestamp: timestamp,
                    status: 'pending'
                };
                
                // Save to localStorage
                const requests = JSON.parse(localStorage.getItem('helixa_verify_requests') || '[]');
                requests.push(request);
                localStorage.setItem('helixa_verify_requests', JSON.stringify(requests));
                
                // Also log to console for monitoring
                console.log('VERIFICATION_REQUEST:', JSON.stringify(request));
                
                status.innerHTML = '<div class="verify-status requested">üïê Verification requested! Your agent will be verified shortly by the Helixa team.<br><small style="opacity:0.7;">Token #' + mintedTokenId + ' ¬∑ Signed by ' + recovered.slice(0,8) + '...</small></div>';
                btn.textContent = '‚úì Verification Requested';
                btn.disabled = true;
                
            } catch (err) {
                status.innerHTML = '<div class="verify-status requested">‚ùå ' + (err.reason || err.message) + '</div>';
                btn.disabled = false;
            }
        }

        // ============ EXPLORER FILTER ============
        function filterAgentList() {
            const verifiedOnly = document.getElementById('filterVerified').checked;
            const cards = document.querySelectorAll('#agentList .agent-card');
            cards.forEach(card => {
                if (verifiedOnly && card.dataset.verified !== '1') {
                    card.style.display = 'none';
                } else {
                    card.style.display = '';
                }
            });
        }

        // Load stats + agents on page load ‚Äî no wallet needed
        (async () => {
            if (typeof ethers === 'undefined') {
                document.getElementById('agentList').innerHTML = '<p style="color:#ff4444; text-align:center;">ethers.js failed to load. Try opening in a full browser.</p>';
                return;
            }
            try {
                await loadStats();
                await loadAgents();
            } catch (e) {
                console.log('Init load error:', e);
                document.getElementById('agentList').innerHTML = '<p style="color:#ff4444; text-align:center;">Load error: ' + e.message + '</p>';
            }
        })();
    </script>
<script src="qrcode.min.js?v=4"></script>
<script src="qr-overlay.js?v=4"></script>
</body>
</html>
